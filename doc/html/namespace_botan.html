<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>even-network: Botan Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="2018-12-27 at 10-36-23.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">even-network
   </div>
   <div id="projectbrief">EVEN Network â€” is an open cross-chain platform with EVEN cryptocurrency that allows users to interact with more than one blockchain at a time.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Botan Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_botan_1_1_cert___extension"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan_1_1_cert___extension.html">Cert_Extension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_botan_1_1_crypto_box"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan_1_1_crypto_box.html">CryptoBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_botan_1_1_f_p_e"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan_1_1_f_p_e.html">FPE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_botan_1_1_p_k_c_s8"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan_1_1_p_k_c_s8.html">PKCS8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_botan_1_1_p_k_i_x"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan_1_1_p_k_i_x.html">PKIX</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_botan_1_1_x509"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan_1_1_x509.html">X509</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_a_e_a_d___filter.html">AEAD_Filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_allocator___initializer.html">Allocator_Initializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_atomic.html">Atomic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_barrier.html">Barrier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_bear_s_s_l___error.html">BearSSL_Error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_block___cipher___fixed___params.html">Block_Cipher_Fixed_Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_c_e_c_p_q1__key.html">CECPQ1_key</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_botan_1_1_common_cryptor___opts.html">CommonCryptor_Opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_compression___alloc___info.html">Compression_Alloc_Info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_compression___stream.html">Compression_Stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_botan_1_1_c_r_l___data.html">CRL_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_botan_1_1_c_r_l___entry___data.html">CRL_Entry_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_curve_g_fp.html">CurveGFp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_curve_g_fp___repr.html">CurveGFp_Repr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_data___store.html">Data_Store</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_device___entropy_source.html">Device_EntropySource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_d_l___group___data.html">DL_Group_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1donna128.html">donna128</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_e_c___group___data.html">EC_Group_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_e_c___group___data___map.html">EC_Group_Data_Map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_f_e__25519.html">FE_25519</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_file___descriptor___source.html">File_Descriptor_Source</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_fixed___window___exponentiator.html">Fixed_Window_Exponentiator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_botan_1_1ge__p3.html">ge_p3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_getentropy.html">Getentropy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_intel___rdrand.html">Intel_Rdrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_intel___rdseed.html">Intel_Rdseed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_l__computer.html">L_computer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1lock__guard.html">lock_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_memory___pool.html">Memory_Pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_montgomery___exponentation___state.html">Montgomery_Exponentation_State</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_montgomery___exponentiator.html">Montgomery_Exponentiator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_montgomery___int.html">Montgomery_Int</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_montgomery___params.html">Montgomery_Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1newhope__poly.html">newhope_poly</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1noop__mutex.html">noop_mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_output___buffers.html">Output_Buffers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_botan_1_1_p_k_c_s10___data.html">PKCS10_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_point_g_fp___base___point___precompute.html">PointGFp_Base_Point_Precompute</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_point_g_fp___multi___point___precompute.html">PointGFp_Multi_Point_Precompute</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_point_g_fp___var___point___precompute.html">PointGFp_Var_Point_Precompute</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1polyn__gf2m.html">polyn_gf2m</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_proc_walking___entropy_source.html">ProcWalking_EntropySource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1secure__allocator.html">secure_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_secure_queue_node.html">SecureQueueNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_semaphore.html">Semaphore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_s_i_m_d__4x32.html">SIMD_4x32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_s_i_m_d__8x32.html">SIMD_8x32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_stream___compression.html">Stream_Compression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_stream___decompression.html">Stream_Decompression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_timer.html">Timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_u_u_i_d.html">UUID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_win32___entropy_source.html">Win32_EntropySource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_botan_1_1_x509___certificate___data.html">X509_Certificate_Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___address.html">XMSS_Address</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___common___ops.html">XMSS_Common_Ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___hash.html">XMSS_Hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___index___registry.html">XMSS_Index_Registry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___signature.html">XMSS_Signature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___signature___operation.html">XMSS_Signature_Operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___tools.html">XMSS_Tools</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___verification___operation.html">XMSS_Verification_Operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___w_o_t_s___addressed___private_key.html">XMSS_WOTS_Addressed_PrivateKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___w_o_t_s___addressed___public_key.html">XMSS_WOTS_Addressed_PublicKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___w_o_t_s___parameters.html">XMSS_WOTS_Parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___w_o_t_s___private_key.html">XMSS_WOTS_PrivateKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_x_m_s_s___w_o_t_s___public_key.html">XMSS_WOTS_PublicKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_botan_1_1_zlib___style___stream.html">Zlib_Style_Stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae90f7fcf7b0aa3dd88a59f186f6e6307"><td class="memTemplParams" colspan="2"><a id="ae90f7fcf7b0aa3dd88a59f186f6e6307"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae90f7fcf7b0aa3dd88a59f186f6e6307"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>secure_vector</b> = std::vector&lt; T, <a class="el" href="class_botan_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:ae90f7fcf7b0aa3dd88a59f186f6e6307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c6c2c9f6366dcefa326d40c7d0f281"><td class="memTemplParams" colspan="2"><a id="a15c6c2c9f6366dcefa326d40c7d0f281"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15c6c2c9f6366dcefa326d40c7d0f281"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>secure_deque</b> = std::deque&lt; T, <a class="el" href="class_botan_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a15c6c2c9f6366dcefa326d40c7d0f281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2f8a23186bf117dde5a6bf7f59fad9"><td class="memTemplParams" colspan="2"><a id="aee2f8a23186bf117dde5a6bf7f59fad9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee2f8a23186bf117dde5a6bf7f59fad9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SecureVector</b> = secure_vector&lt; T &gt;</td></tr>
<tr class="separator:aee2f8a23186bf117dde5a6bf7f59fad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cf6c3513428f524454d01830221a88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a89cf6c3513428f524454d01830221a88">SymmetricKey</a> = OctetString</td></tr>
<tr class="separator:a89cf6c3513428f524454d01830221a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbf5195ffe701adcabb1f8c41bfc557"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a2fbf5195ffe701adcabb1f8c41bfc557">InitializationVector</a> = OctetString</td></tr>
<tr class="separator:a2fbf5195ffe701adcabb1f8c41bfc557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f398856b09d29fedf055b9bb730357"><td class="memItemLeft" align="right" valign="top"><a id="a49f398856b09d29fedf055b9bb730357"></a>
typedef <a class="el" href="namespace_botan.html#a021ffc520728602cd2f027a40b68bc5f">Transform_Filter</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Transformation_Filter</b></td></tr>
<tr class="separator:a49f398856b09d29fedf055b9bb730357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5205c90055f402fac271c40e30dd64ba"><td class="memItemLeft" align="right" valign="top"><a id="a5205c90055f402fac271c40e30dd64ba"></a>
typedef PBKDF&#160;</td><td class="memItemRight" valign="bottom"><b>S2K</b></td></tr>
<tr class="separator:a5205c90055f402fac271c40e30dd64ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7f1f0b1e64d17eb434bd3f8e74d25b"><td class="memItemLeft" align="right" valign="top"><a id="a2c7f1f0b1e64d17eb434bd3f8e74d25b"></a>
typedef Curve25519_PrivateKey&#160;</td><td class="memItemRight" valign="bottom"><b>X25519_PrivateKey</b></td></tr>
<tr class="separator:a2c7f1f0b1e64d17eb434bd3f8e74d25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6ad46a3e0235b7d8fa64faa2a9f17a"><td class="memItemLeft" align="right" valign="top"><a id="a5a6ad46a3e0235b7d8fa64faa2a9f17a"></a>
typedef EC_Group&#160;</td><td class="memItemRight" valign="bottom"><b>EC_Domain_Params</b></td></tr>
<tr class="separator:a5a6ad46a3e0235b7d8fa64faa2a9f17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65370c3e6d6f8d2656d7fa66213b20c9"><td class="memItemLeft" align="right" valign="top"><a id="a65370c3e6d6f8d2656d7fa66213b20c9"></a>
typedef <a class="el" href="class_botan_1_1_f_e__25519.html">FE_25519</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fe</b></td></tr>
<tr class="separator:a65370c3e6d6f8d2656d7fa66213b20c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61fe047bd15ac9f2f4c57d42a4aaf09"><td class="memItemLeft" align="right" valign="top"><a id="af61fe047bd15ac9f2f4c57d42a4aaf09"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>gf2m</b></td></tr>
<tr class="separator:af61fe047bd15ac9f2f4c57d42a4aaf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b75a8456bda4f7b38264e848a7f2936"><td class="memItemLeft" align="right" valign="top"><a id="a0b75a8456bda4f7b38264e848a7f2936"></a>
typedef <a class="el" href="class_botan_1_1newhope__poly.html">newhope_poly</a>&#160;</td><td class="memItemRight" valign="bottom"><b>poly</b></td></tr>
<tr class="separator:a0b75a8456bda4f7b38264e848a7f2936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0fa31967ac5460a26278c11eb9142f"><td class="memItemLeft" align="right" valign="top"><a id="add0fa31967ac5460a26278c11eb9142f"></a>
typedef Public_Key&#160;</td><td class="memItemRight" valign="bottom"><b>X509_PublicKey</b></td></tr>
<tr class="separator:add0fa31967ac5460a26278c11eb9142f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa653260f8a83c2d5905a709495f2b61c"><td class="memItemLeft" align="right" valign="top"><a id="aa653260f8a83c2d5905a709495f2b61c"></a>
typedef Private_Key&#160;</td><td class="memItemRight" valign="bottom"><b>PKCS8_PrivateKey</b></td></tr>
<tr class="separator:aa653260f8a83c2d5905a709495f2b61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e465e0eda1d2e69044658b6827ad417"><td class="memItemLeft" align="right" valign="top"><a id="a3e465e0eda1d2e69044658b6827ad417"></a>
typedef SM2_PublicKey&#160;</td><td class="memItemRight" valign="bottom"><b>SM2_Signature_PublicKey</b></td></tr>
<tr class="separator:a3e465e0eda1d2e69044658b6827ad417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6a89815f08e0339626b3dc0f2e3bc1"><td class="memItemLeft" align="right" valign="top"><a id="a1d6a89815f08e0339626b3dc0f2e3bc1"></a>
typedef SM2_PublicKey&#160;</td><td class="memItemRight" valign="bottom"><b>SM2_Encryption_PublicKey</b></td></tr>
<tr class="separator:a1d6a89815f08e0339626b3dc0f2e3bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352d0f7e1c0aa6e6363adb6b2371e15f"><td class="memItemLeft" align="right" valign="top"><a id="a352d0f7e1c0aa6e6363adb6b2371e15f"></a>
typedef SM2_PrivateKey&#160;</td><td class="memItemRight" valign="bottom"><b>SM2_Signature_PrivateKey</b></td></tr>
<tr class="separator:a352d0f7e1c0aa6e6363adb6b2371e15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37405b19030e321df4154a1510ed88d"><td class="memItemLeft" align="right" valign="top"><a id="aa37405b19030e321df4154a1510ed88d"></a>
typedef SM2_PrivateKey&#160;</td><td class="memItemRight" valign="bottom"><b>SM2_Encryption_PrivateKey</b></td></tr>
<tr class="separator:aa37405b19030e321df4154a1510ed88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adeb3982e716829a15535f6dfe5d831"><td class="memItemLeft" align="right" valign="top"><a id="a6adeb3982e716829a15535f6dfe5d831"></a>
typedef std::vector&lt; secure_vector&lt; uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>wots_keysig_t</b></td></tr>
<tr class="separator:a6adeb3982e716829a15535f6dfe5d831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fbc8259840830135e2cf779839ddfa"><td class="memItemLeft" align="right" valign="top">typedef RandomNumberGenerator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a45fbc8259840830135e2cf779839ddfa">RNG</a></td></tr>
<tr class="separator:a45fbc8259840830135e2cf779839ddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad384cce1c3c4736c4d48904dd6dc5061"><td class="memItemLeft" align="right" valign="top"><a id="ad384cce1c3c4736c4d48904dd6dc5061"></a>
typedef <a class="el" href="class_botan_1_1noop__mutex.html">noop_mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mutex_type</b></td></tr>
<tr class="separator:ad384cce1c3c4736c4d48904dd6dc5061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023d45026d17fdd648ae3d4a8b27c5ff"><td class="memTemplParams" colspan="2"><a id="a023d45026d17fdd648ae3d4a8b27c5ff"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a023d45026d17fdd648ae3d4a8b27c5ff"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lock_guard_type</b> = <a class="el" href="class_botan_1_1lock__guard.html">lock_guard</a>&lt; T &gt;</td></tr>
<tr class="separator:a023d45026d17fdd648ae3d4a8b27c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a59e232983349d45427890c5286c94"><td class="memItemLeft" align="right" valign="top"><a id="ab8a59e232983349d45427890c5286c94"></a>
typedef <a class="el" href="class_botan_1_1_s_i_m_d__4x32.html">SIMD_4x32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SIMD_32</b></td></tr>
<tr class="separator:ab8a59e232983349d45427890c5286c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a6663b490db3d485027ee7703601d0"><td class="memItemLeft" align="right" valign="top"><a id="ac1a6663b490db3d485027ee7703601d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>byte</b> = std::uint8_t</td></tr>
<tr class="separator:ac1a6663b490db3d485027ee7703601d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505815f98fab07277691987697db779b"><td class="memItemLeft" align="right" valign="top"><a id="a505815f98fab07277691987697db779b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u16bit</b> = std::uint16_t</td></tr>
<tr class="separator:a505815f98fab07277691987697db779b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a94f72aafbd2a2f42d4fbc33b36a42"><td class="memItemLeft" align="right" valign="top"><a id="a27a94f72aafbd2a2f42d4fbc33b36a42"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u32bit</b> = std::uint32_t</td></tr>
<tr class="separator:a27a94f72aafbd2a2f42d4fbc33b36a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eb3f748538b76716c6868660cb6ab3"><td class="memItemLeft" align="right" valign="top"><a id="a05eb3f748538b76716c6868660cb6ab3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u64bit</b> = std::uint64_t</td></tr>
<tr class="separator:a05eb3f748538b76716c6868660cb6ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f63d988c9a6238cca19b2c32e79f9"><td class="memItemLeft" align="right" valign="top"><a id="a227f63d988c9a6238cca19b2c32e79f9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>s32bit</b> = std::int32_t</td></tr>
<tr class="separator:a227f63d988c9a6238cca19b2c32e79f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013252aabcb201e0d27b60b1e690886b"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::set&lt; <a class="el" href="namespace_botan.html#ae1e907dc90937bdda30f65216e68ff2b">Certificate_Status_Code</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a013252aabcb201e0d27b60b1e690886b">CertificatePathStatusCodes</a></td></tr>
<tr class="separator:a013252aabcb201e0d27b60b1e690886b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acc1ab433420bdddbcfe52dbbd94e8576"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#acc1ab433420bdddbcfe52dbbd94e8576">ASN1_Tag</a> : uint32_t { <br />
&#160;&#160;<b>UNIVERSAL</b> = 0x00, 
<b>APPLICATION</b> = 0x40, 
<b>CONTEXT_SPECIFIC</b> = 0x80, 
<b>CONSTRUCTED</b> = 0x20, 
<br />
&#160;&#160;<b>PRIVATE</b> = CONSTRUCTED | CONTEXT_SPECIFIC, 
<b>EOC</b> = 0x00, 
<b>BOOLEAN</b> = 0x01, 
<b>INTEGER</b> = 0x02, 
<br />
&#160;&#160;<b>BIT_STRING</b> = 0x03, 
<b>OCTET_STRING</b> = 0x04, 
<b>NULL_TAG</b> = 0x05, 
<b>OBJECT_ID</b> = 0x06, 
<br />
&#160;&#160;<b>ENUMERATED</b> = 0x0A, 
<b>SEQUENCE</b> = 0x10, 
<b>SET</b> = 0x11, 
<b>UTF8_STRING</b> = 0x0C, 
<br />
&#160;&#160;<b>NUMERIC_STRING</b> = 0x12, 
<b>PRINTABLE_STRING</b> = 0x13, 
<b>T61_STRING</b> = 0x14, 
<b>IA5_STRING</b> = 0x16, 
<br />
&#160;&#160;<b>VISIBLE_STRING</b> = 0x1A, 
<b>UNIVERSAL_STRING</b> = 0x1C, 
<b>BMP_STRING</b> = 0x1E, 
<b>UTC_TIME</b> = 0x17, 
<br />
&#160;&#160;<b>GENERALIZED_TIME</b> = 0x18, 
<b>UTC_OR_GENERALIZED_TIME</b> = 0x19, 
<b>NO_OBJECT</b> = 0xFF00, 
<b>DIRECTORY_STRING</b> = 0xFF01
<br />
 }</td></tr>
<tr class="separator:acc1ab433420bdddbcfe52dbbd94e8576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5baf937a9984c39f8b44104dde76ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#acd5baf937a9984c39f8b44104dde76ae">Decoder_Checking</a> { <b>NONE</b>, 
<b>IGNORE_WS</b>, 
<b>FULL_CHECK</b>
 }</td></tr>
<tr class="separator:acd5baf937a9984c39f8b44104dde76ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c9c4f3dbf31294f0a3b36f82e9d5c0"><td class="memItemLeft" align="right" valign="top"><a id="a00c9c4f3dbf31294f0a3b36f82e9d5c0"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SM3_BLOCK_BYTES</b> = 64, 
<b>SM3_DIGEST_BYTES</b> = 32
 }</td></tr>
<tr class="separator:a00c9c4f3dbf31294f0a3b36f82e9d5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9547a8fb3e868810b169b20ac389ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> : int { <b>ENCRYPTION</b>, 
<b>DECRYPTION</b>
 }</td></tr>
<tr class="separator:a8d9547a8fb3e868810b169b20ac389ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8cdb2a8f5312e6ed667347b065e9ec"><td class="memItemLeft" align="right" valign="top"><a id="a1e8cdb2a8f5312e6ed667347b065e9ec"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TPM_Storage_Type</b> { <b>User</b>, 
<b>System</b>
 }</td></tr>
<tr class="separator:a1e8cdb2a8f5312e6ed667347b065e9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ee6307c8f311388a2bc00426a7f858"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ad0ee6307c8f311388a2bc00426a7f858">EC_Group_Encoding</a> { <b>EC_DOMPAR_ENC_EXPLICIT</b> = 0, 
<b>EC_DOMPAR_ENC_IMPLICITCA</b> = 1, 
<b>EC_DOMPAR_ENC_OID</b> = 2
 }</td></tr>
<tr class="separator:ad0ee6307c8f311388a2bc00426a7f858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9633493dccb5f879eeafafe99c71f6e8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8">ECIES_Flags</a> : uint32_t { <br />
&#160;&#160;<b>NONE</b> = 0, 
<a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8a8f077adf8e11b076e88eee680527f81e">ECIES_Flags::SINGLE_HASH_MODE</a> = 1, 
<a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8a421ba92bce979a3ec3aafaa74a7103d7">ECIES_Flags::COFACTOR_MODE</a> = 2, 
<a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8a2165f0ab80715b5218d379471e4f59cb">ECIES_Flags::OLD_COFACTOR_MODE</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8a2376233bf1de21598ca22c5143aea223">ECIES_Flags::CHECK_MODE</a> = 8
<br />
 }</td></tr>
<tr class="separator:a9633493dccb5f879eeafafe99c71f6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afe4e4b818b57d67f00ee387c06721c"><td class="memItemLeft" align="right" valign="top"><a id="a6afe4e4b818b57d67f00ee387c06721c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Newhope_Params</b> { <br />
&#160;&#160;<b>NEWHOPE_SENDABYTES</b> = 1824, 
<b>NEWHOPE_SENDBBYTES</b> = 2048, 
<b>NEWHOPE_OFFER_BYTES</b> = 1824, 
<b>NEWHOPE_ACCEPT_BYTES</b> = 2048, 
<br />
&#160;&#160;<b>NEWHOPE_SHARED_KEY_BYTES</b> = 32, 
<b>NEWHOPE_SEED_BYTES</b> = 32, 
<b>NEWHOPE_POLY_BYTES</b> = 1792, 
<b>CECPQ1_OFFER_BYTES</b> = NEWHOPE_OFFER_BYTES + 32, 
<br />
&#160;&#160;<b>CECPQ1_ACCEPT_BYTES</b> = NEWHOPE_ACCEPT_BYTES + 32, 
<b>CECPQ1_SHARED_KEY_BYTES</b> = NEWHOPE_SHARED_KEY_BYTES + 32
<br />
 }</td></tr>
<tr class="separator:a6afe4e4b818b57d67f00ee387c06721c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a70d7cfb95e4f7773d3b52dc98ad61"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a42a70d7cfb95e4f7773d3b52dc98ad61">Newhope_Mode</a> { <b>SHA3</b>, 
<b>BoringSSL</b>
 }</td></tr>
<tr class="separator:a42a70d7cfb95e4f7773d3b52dc98ad61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a9578625edf847cbcba3ae15648cda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ad8a9578625edf847cbcba3ae15648cda">Signature_Format</a> { <b>IEEE_1363</b>, 
<b>DER_SEQUENCE</b>
 }</td></tr>
<tr class="separator:ad8a9578625edf847cbcba3ae15648cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53759b4ed1fb93549f307fcf68729d2f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a53759b4ed1fb93549f307fcf68729d2f">X509_Encoding</a> { <b>RAW_BER</b>, 
<b>PEM</b>
 }</td></tr>
<tr class="separator:a53759b4ed1fb93549f307fcf68729d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416eb1af7496d74b885a20ff833e9b33"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a416eb1af7496d74b885a20ff833e9b33">Character_Set</a> { <b>LOCAL_CHARSET</b>, 
<b>UCS2_CHARSET</b>, 
<b>UTF8_CHARSET</b>, 
<b>LATIN1_CHARSET</b>
 }</td></tr>
<tr class="separator:a416eb1af7496d74b885a20ff833e9b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e907dc90937bdda30f65216e68ff2b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ae1e907dc90937bdda30f65216e68ff2b">Certificate_Status_Code</a> { <br />
&#160;&#160;<b>OK</b> = 0, 
<b>VERIFIED</b> = 0, 
<b>OCSP_RESPONSE_GOOD</b> = 1, 
<b>OCSP_SIGNATURE_OK</b> = 2, 
<br />
&#160;&#160;<b>VALID_CRL_CHECKED</b> = 3, 
<b>OCSP_NO_HTTP</b> = 4, 
<b>FIRST_WARNING_STATUS</b> = 500, 
<b>CERT_SERIAL_NEGATIVE</b> = 500, 
<br />
&#160;&#160;<b>DN_TOO_LONG</b> = 501, 
<b>OSCP_NO_REVOCATION_URL</b> = 502, 
<b>OSCP_SERVER_NOT_AVAILABLE</b> = 503, 
<b>FIRST_ERROR_STATUS</b> = 1000, 
<br />
&#160;&#160;<b>SIGNATURE_METHOD_TOO_WEAK</b> = 1000, 
<b>UNTRUSTED_HASH</b> = 1001, 
<b>NO_REVOCATION_DATA</b> = 1002, 
<b>NO_MATCHING_CRLDP</b> = 1003, 
<br />
&#160;&#160;<b>CERT_NOT_YET_VALID</b> = 2000, 
<b>CERT_HAS_EXPIRED</b> = 2001, 
<b>OCSP_NOT_YET_VALID</b> = 2002, 
<b>OCSP_HAS_EXPIRED</b> = 2003, 
<br />
&#160;&#160;<b>CRL_NOT_YET_VALID</b> = 2004, 
<b>CRL_HAS_EXPIRED</b> = 2005, 
<b>CERT_ISSUER_NOT_FOUND</b> = 3000, 
<b>CANNOT_ESTABLISH_TRUST</b> = 3001, 
<br />
&#160;&#160;<b>CERT_CHAIN_LOOP</b> = 3002, 
<b>CHAIN_LACKS_TRUST_ROOT</b> = 3003, 
<b>CHAIN_NAME_MISMATCH</b> = 3004, 
<b>POLICY_ERROR</b> = 4000, 
<br />
&#160;&#160;<b>INVALID_USAGE</b> = 4001, 
<b>CERT_CHAIN_TOO_LONG</b> = 4002, 
<b>CA_CERT_NOT_FOR_CERT_ISSUER</b> = 4003, 
<b>NAME_CONSTRAINT_ERROR</b> = 4004, 
<br />
&#160;&#160;<b>CA_CERT_NOT_FOR_CRL_ISSUER</b> = 4005, 
<b>OCSP_CERT_NOT_LISTED</b> = 4006, 
<b>OCSP_BAD_STATUS</b> = 4007, 
<b>CERT_NAME_NOMATCH</b> = 4008, 
<br />
&#160;&#160;<b>UNKNOWN_CRITICAL_EXTENSION</b> = 4009, 
<b>DUPLICATE_CERT_EXTENSION</b> = 4010, 
<b>OCSP_SIGNATURE_ERROR</b> = 4501, 
<b>OCSP_ISSUER_NOT_FOUND</b> = 4502, 
<br />
&#160;&#160;<b>OCSP_RESPONSE_MISSING_KEYUSAGE</b> = 4503, 
<b>OCSP_RESPONSE_INVALID</b> = 4504, 
<b>EXT_IN_V1_V2_CERT</b> = 4505, 
<b>DUPLICATE_CERT_POLICY</b> = 4506, 
<br />
&#160;&#160;<b>CERT_IS_REVOKED</b> = 5000, 
<b>CRL_BAD_SIGNATURE</b> = 5001, 
<b>SIGNATURE_ERROR</b> = 5002, 
<b>CERT_PUBKEY_INVALID</b> = 5003, 
<br />
&#160;&#160;<b>SIGNATURE_ALGO_UNKNOWN</b> = 5004, 
<b>SIGNATURE_ALGO_BAD_PARAMS</b> = 5005
<br />
 }</td></tr>
<tr class="separator:ae1e907dc90937bdda30f65216e68ff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557e654e0c387a4ef2521e3ece516ca7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a557e654e0c387a4ef2521e3ece516ca7">CRL_Code</a> : uint32_t { <br />
&#160;&#160;<b>UNSPECIFIED</b> = 0, 
<b>KEY_COMPROMISE</b> = 1, 
<b>CA_COMPROMISE</b> = 2, 
<b>AFFILIATION_CHANGED</b> = 3, 
<br />
&#160;&#160;<b>SUPERSEDED</b> = 4, 
<b>CESSATION_OF_OPERATION</b> = 5, 
<b>CERTIFICATE_HOLD</b> = 6, 
<b>REMOVE_FROM_CRL</b> = 8, 
<br />
&#160;&#160;<b>PRIVLEDGE_WITHDRAWN</b> = 9, 
<b>AA_COMPROMISE</b> = 10, 
<b>DELETE_CRL_ENTRY</b> = 0xFF00, 
<b>OCSP_GOOD</b> = 0xFF01, 
<br />
&#160;&#160;<b>OCSP_UNKNOWN</b> = 0xFF02
<br />
 }</td></tr>
<tr class="separator:a557e654e0c387a4ef2521e3ece516ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0885e5c70627dd43827b966e727654"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aed0885e5c70627dd43827b966e727654">Key_Constraints</a> { <br />
&#160;&#160;<b>NO_CONSTRAINTS</b> = 0, 
<b>DIGITAL_SIGNATURE</b> = 1 &lt;&lt; 15, 
<b>NON_REPUDIATION</b> = 1 &lt;&lt; 14, 
<b>KEY_ENCIPHERMENT</b> = 1 &lt;&lt; 13, 
<br />
&#160;&#160;<b>DATA_ENCIPHERMENT</b> = 1 &lt;&lt; 12, 
<b>KEY_AGREEMENT</b> = 1 &lt;&lt; 11, 
<b>KEY_CERT_SIGN</b> = 1 &lt;&lt; 10, 
<b>CRL_SIGN</b> = 1 &lt;&lt; 9, 
<br />
&#160;&#160;<b>ENCIPHER_ONLY</b> = 1 &lt;&lt; 8, 
<b>DECIPHER_ONLY</b> = 1 &lt;&lt; 7
<br />
 }</td></tr>
<tr class="separator:aed0885e5c70627dd43827b966e727654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f60e06eee177e95f8b2fb017e0ecba"><td class="memItemLeft" align="right" valign="top"><a id="aa9f60e06eee177e95f8b2fb017e0ecba"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Usage_Type</b> { <br />
&#160;&#160;<b>UNSPECIFIED</b>, 
<b>TLS_SERVER_AUTH</b>, 
<b>TLS_CLIENT_AUTH</b>, 
<b>CERTIFICATE_AUTHORITY</b>, 
<br />
&#160;&#160;<b>OCSP_RESPONDER</b>
<br />
 }</td></tr>
<tr class="separator:aa9f60e06eee177e95f8b2fb017e0ecba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a92a080687352bfae710755e6d982f619"><td class="memItemLeft" align="right" valign="top"><a id="a92a080687352bfae710755e6d982f619"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const AlgorithmIdentifier &amp;a1, const AlgorithmIdentifier &amp;a2)</td></tr>
<tr class="separator:a92a080687352bfae710755e6d982f619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef372a2f77f37fe6f40b80fc5988e7c"><td class="memItemLeft" align="right" valign="top"><a id="a6ef372a2f77f37fe6f40b80fc5988e7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const AlgorithmIdentifier &amp;a1, const AlgorithmIdentifier &amp;a2)</td></tr>
<tr class="separator:a6ef372a2f77f37fe6f40b80fc5988e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9388030d872e586a4655b776ac9501"><td class="memItemLeft" align="right" valign="top">class BOTAN_PUBLIC_API(2, 0) AlgorithmIdentifier final bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a> (2, 0) NameConstraints final</td></tr>
<tr class="memdesc:a6b9388030d872e586a4655b776ac9501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name Constraints.  <a href="#a6b9388030d872e586a4655b776ac9501">More...</a><br /></td></tr>
<tr class="separator:a6b9388030d872e586a4655b776ac9501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fd3b8984ac014a97d4c7e88547f35c"><td class="memItemLeft" align="right" valign="top"><a id="ae3fd3b8984ac014a97d4c7e88547f35c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>asn1_class_to_string</b> (<a class="el" href="namespace_botan.html#acc1ab433420bdddbcfe52dbbd94e8576">ASN1_Tag</a> type)</td></tr>
<tr class="separator:ae3fd3b8984ac014a97d4c7e88547f35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d65b1f703d9c29527586b69bac0021"><td class="memItemLeft" align="right" valign="top"><a id="af5d65b1f703d9c29527586b69bac0021"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>asn1_tag_to_string</b> (<a class="el" href="namespace_botan.html#acc1ab433420bdddbcfe52dbbd94e8576">ASN1_Tag</a> type)</td></tr>
<tr class="separator:af5d65b1f703d9c29527586b69bac0021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25386a9e68f8a7fa3cfe2d576a14cce1"><td class="memItemLeft" align="right" valign="top"><a id="a25386a9e68f8a7fa3cfe2d576a14cce1"></a>
OID&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const OID &amp;oid, uint32_t component)</td></tr>
<tr class="separator:a25386a9e68f8a7fa3cfe2d576a14cce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628ad693dc802e2920e3a7efdea5d7c8"><td class="memItemLeft" align="right" valign="top"><a id="a628ad693dc802e2920e3a7efdea5d7c8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const OID &amp;a, const OID &amp;b)</td></tr>
<tr class="separator:a628ad693dc802e2920e3a7efdea5d7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bb1018a3447984046ed00e1450d81c"><td class="memItemLeft" align="right" valign="top"><a id="a39bb1018a3447984046ed00e1450d81c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const OID &amp;a, const OID &amp;b)</td></tr>
<tr class="separator:a39bb1018a3447984046ed00e1450d81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0df5a86f85160d4d4b3cfdb3fe37b55"><td class="memItemLeft" align="right" valign="top">class BOTAN_PUBLIC_API(2, 0) OID final OID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aa0df5a86f85160d4d4b3cfdb3fe37b55">BOTAN_PUBLIC_API</a> (2, 0) operator+(const OID &amp;oid</td></tr>
<tr class="separator:aa0df5a86f85160d4d4b3cfdb3fe37b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d82593a051b515b926e213e8040f2"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a306d82593a051b515b926e213e8040f2">BOTAN_PUBLIC_API</a> (2, 4) ASN1_Formatter</td></tr>
<tr class="separator:a306d82593a051b515b926e213e8040f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b43fcc4133692ad6928db2b415566"><td class="memItemLeft" align="right" valign="top"><a id="afb4b43fcc4133692ad6928db2b415566"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const X509_Time &amp;t1, const X509_Time &amp;t2)</td></tr>
<tr class="separator:afb4b43fcc4133692ad6928db2b415566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff323a3542d27167ba9c00743fad212"><td class="memItemLeft" align="right" valign="top"><a id="a0ff323a3542d27167ba9c00743fad212"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const X509_Time &amp;t1, const X509_Time &amp;t2)</td></tr>
<tr class="separator:a0ff323a3542d27167ba9c00743fad212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2d002845cc77dc8a5f963cdd2b5a12"><td class="memItemLeft" align="right" valign="top"><a id="a5e2d002845cc77dc8a5f963cdd2b5a12"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const X509_Time &amp;t1, const X509_Time &amp;t2)</td></tr>
<tr class="separator:a5e2d002845cc77dc8a5f963cdd2b5a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9975acda25a0cd4318c48c517fda27"><td class="memItemLeft" align="right" valign="top"><a id="a7b9975acda25a0cd4318c48c517fda27"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const X509_Time &amp;t1, const X509_Time &amp;t2)</td></tr>
<tr class="separator:a7b9975acda25a0cd4318c48c517fda27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3031a14cc3964a29e8f70c877bd8adad"><td class="memItemLeft" align="right" valign="top"><a id="a3031a14cc3964a29e8f70c877bd8adad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const X509_Time &amp;t1, const X509_Time &amp;t2)</td></tr>
<tr class="separator:a3031a14cc3964a29e8f70c877bd8adad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7d7146cb3792c80bbaf1760ced589e"><td class="memItemLeft" align="right" valign="top"><a id="a2d7d7146cb3792c80bbaf1760ced589e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const X509_Time &amp;t1, const X509_Time &amp;t2)</td></tr>
<tr class="separator:a2d7d7146cb3792c80bbaf1760ced589e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8ae79f2e15f3ed4a57feabd42c6b9a"><td class="memTemplParams" colspan="2"><a id="a2c8ae79f2e15f3ed4a57feabd42c6b9a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c8ae79f2e15f3ed4a57feabd42c6b9a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>probe_providers_of</b> (const std::string &amp;algo_spec, const std::vector&lt; std::string &gt; &amp;possible)</td></tr>
<tr class="separator:a2c8ae79f2e15f3ed4a57feabd42c6b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af642902e51060ac64f0278fcfaae25bc"><td class="memTemplParams" colspan="2"><a id="af642902e51060ac64f0278fcfaae25bc"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af642902e51060ac64f0278fcfaae25bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_botan_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="class_botan_1_1secure__allocator.html">secure_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:af642902e51060ac64f0278fcfaae25bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4317d3fed122a6763016f7d0194925"><td class="memTemplParams" colspan="2"><a id="a0f4317d3fed122a6763016f7d0194925"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0f4317d3fed122a6763016f7d0194925"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_botan_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="class_botan_1_1secure__allocator.html">secure_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a0f4317d3fed122a6763016f7d0194925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b99a8cd5ed8949c8645dc15c8b6659"><td class="memTemplParams" colspan="2"><a id="a07b99a8cd5ed8949c8645dc15c8b6659"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07b99a8cd5ed8949c8645dc15c8b6659"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unlock</b> (const secure_vector&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a07b99a8cd5ed8949c8645dc15c8b6659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19af9a711ecf7ae0dd3a64138fc6dc3b"><td class="memTemplParams" colspan="2"><a id="a19af9a711ecf7ae0dd3a64138fc6dc3b"></a>
template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a19af9a711ecf7ae0dd3a64138fc6dc3b"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>buffer_insert</b> (std::vector&lt; T, Alloc &gt; &amp;buf, size_t buf_offset, const T input[], size_t input_length)</td></tr>
<tr class="separator:a19af9a711ecf7ae0dd3a64138fc6dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22388053c63ffb34d665e5fcae148e14"><td class="memTemplParams" colspan="2"><a id="a22388053c63ffb34d665e5fcae148e14"></a>
template&lt;typename T , typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:a22388053c63ffb34d665e5fcae148e14"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>buffer_insert</b> (std::vector&lt; T, Alloc &gt; &amp;buf, size_t buf_offset, const std::vector&lt; T, Alloc2 &gt; &amp;input)</td></tr>
<tr class="separator:a22388053c63ffb34d665e5fcae148e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbc58ad326d5e720297c3f29a1d9dd1"><td class="memTemplParams" colspan="2"><a id="a9bbc58ad326d5e720297c3f29a1d9dd1"></a>
template&lt;typename T , typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:a9bbc58ad326d5e720297c3f29a1d9dd1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (std::vector&lt; T, Alloc &gt; &amp;out, const std::vector&lt; T, Alloc2 &gt; &amp;in)</td></tr>
<tr class="separator:a9bbc58ad326d5e720297c3f29a1d9dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906697de956a6e0d5a61249aa3bb525f"><td class="memTemplParams" colspan="2"><a id="a906697de956a6e0d5a61249aa3bb525f"></a>
template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a906697de956a6e0d5a61249aa3bb525f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (std::vector&lt; T, Alloc &gt; &amp;out, T in)</td></tr>
<tr class="separator:a906697de956a6e0d5a61249aa3bb525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723c2af7ffb9a2e5165f95db713c55d3"><td class="memTemplParams" colspan="2"><a id="a723c2af7ffb9a2e5165f95db713c55d3"></a>
template&lt;typename T , typename Alloc , typename L &gt; </td></tr>
<tr class="memitem:a723c2af7ffb9a2e5165f95db713c55d3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (std::vector&lt; T, Alloc &gt; &amp;out, const std::pair&lt; const T *, L &gt; &amp;in)</td></tr>
<tr class="separator:a723c2af7ffb9a2e5165f95db713c55d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777e3c75fe36a1a4933b1ad4a8ce9b07"><td class="memTemplParams" colspan="2"><a id="a777e3c75fe36a1a4933b1ad4a8ce9b07"></a>
template&lt;typename T , typename Alloc , typename L &gt; </td></tr>
<tr class="memitem:a777e3c75fe36a1a4933b1ad4a8ce9b07"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (std::vector&lt; T, Alloc &gt; &amp;out, const std::pair&lt; T *, L &gt; &amp;in)</td></tr>
<tr class="separator:a777e3c75fe36a1a4933b1ad4a8ce9b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ce987463cc4e1b7682f31bb486fdb1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a09ce987463cc4e1b7682f31bb486fdb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a09ce987463cc4e1b7682f31bb486fdb1">zeroise</a> (std::vector&lt; T, Alloc &gt; &amp;vec)</td></tr>
<tr class="separator:a09ce987463cc4e1b7682f31bb486fdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2534f0fffcfe960b963990832bd1d26e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a2534f0fffcfe960b963990832bd1d26e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a2534f0fffcfe960b963990832bd1d26e">zap</a> (std::vector&lt; T, Alloc &gt; &amp;vec)</td></tr>
<tr class="separator:a2534f0fffcfe960b963990832bd1d26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551a515f0c61404596b130f180baca42"><td class="memItemLeft" align="right" valign="top"><a id="a551a515f0c61404596b130f180baca42"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const OctetString &amp;s1, const OctetString &amp;s2)</td></tr>
<tr class="separator:a551a515f0c61404596b130f180baca42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1b5d6af0e8a9c167560d38612b9093"><td class="memItemLeft" align="right" valign="top"><a id="ada1b5d6af0e8a9c167560d38612b9093"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const OctetString &amp;s1, const OctetString &amp;s2)</td></tr>
<tr class="separator:ada1b5d6af0e8a9c167560d38612b9093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416b93dfc9f85cf4cd340496569771df"><td class="memItemLeft" align="right" valign="top"><a id="a416b93dfc9f85cf4cd340496569771df"></a>
OctetString&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const OctetString &amp;k1, const OctetString &amp;k2)</td></tr>
<tr class="separator:a416b93dfc9f85cf4cd340496569771df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3865365c1278cbbd08338bc0936d42ca"><td class="memItemLeft" align="right" valign="top"><a id="a3865365c1278cbbd08338bc0936d42ca"></a>
OctetString&#160;</td><td class="memItemRight" valign="bottom"><b>operator^</b> (const OctetString &amp;k1, const OctetString &amp;k2)</td></tr>
<tr class="separator:a3865365c1278cbbd08338bc0936d42ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf51f448f98c6bd2a7c6589fb251e115"><td class="memItemLeft" align="right" valign="top"><a id="adf51f448f98c6bd2a7c6589fb251e115"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base32_encode</b> (char out[], const uint8_t in[], size_t input_length, size_t &amp;input_consumed, bool final_inputs)</td></tr>
<tr class="separator:adf51f448f98c6bd2a7c6589fb251e115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b85657b0a03e7cc65f3974b13917e71"><td class="memItemLeft" align="right" valign="top"><a id="a5b85657b0a03e7cc65f3974b13917e71"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base32_encode</b> (const uint8_t input[], size_t input_length)</td></tr>
<tr class="separator:a5b85657b0a03e7cc65f3974b13917e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f86ba057620dffed61d624100cfd775"><td class="memItemLeft" align="right" valign="top"><a id="a8f86ba057620dffed61d624100cfd775"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base32_decode</b> (uint8_t out[], const char in[], size_t input_length, size_t &amp;input_consumed, bool final_inputs, bool ignore_ws)</td></tr>
<tr class="separator:a8f86ba057620dffed61d624100cfd775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5444d427e473115a7ce981269a8dd40"><td class="memItemLeft" align="right" valign="top"><a id="ab5444d427e473115a7ce981269a8dd40"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base32_decode</b> (uint8_t output[], const char input[], size_t input_length, bool ignore_ws)</td></tr>
<tr class="separator:ab5444d427e473115a7ce981269a8dd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f01fa22d60b66958a2140f811a2292b"><td class="memItemLeft" align="right" valign="top"><a id="a0f01fa22d60b66958a2140f811a2292b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base32_decode</b> (uint8_t output[], const std::string &amp;input, bool ignore_ws)</td></tr>
<tr class="separator:a0f01fa22d60b66958a2140f811a2292b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f2e9ca4f6822309f5181f2f9b78cb7"><td class="memItemLeft" align="right" valign="top"><a id="af9f2e9ca4f6822309f5181f2f9b78cb7"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>base32_decode</b> (const char input[], size_t input_length, bool ignore_ws)</td></tr>
<tr class="separator:af9f2e9ca4f6822309f5181f2f9b78cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f9ae2ab50dd932d9ecae7dc988bdb9"><td class="memItemLeft" align="right" valign="top"><a id="a03f9ae2ab50dd932d9ecae7dc988bdb9"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>base32_decode</b> (const std::string &amp;input, bool ignore_ws)</td></tr>
<tr class="separator:a03f9ae2ab50dd932d9ecae7dc988bdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87a88225cfb55247f4a91b0b50da678"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ad87a88225cfb55247f4a91b0b50da678">BOTAN_PUBLIC_API</a> (2, 7) base32_encode(char output[]</td></tr>
<tr class="separator:ad87a88225cfb55247f4a91b0b50da678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72149230362af50f830a4ee04d7a9786"><td class="memTemplParams" colspan="2">template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a72149230362af50f830a4ee04d7a9786"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a72149230362af50f830a4ee04d7a9786">base32_encode</a> (const std::vector&lt; uint8_t, Alloc &gt; &amp;input)</td></tr>
<tr class="separator:a72149230362af50f830a4ee04d7a9786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6523ad22d65fe36562fd3c6ab12f5b6b"><td class="memItemLeft" align="right" valign="top"><a id="a6523ad22d65fe36562fd3c6ab12f5b6b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base64_encode</b> (char out[], const uint8_t in[], size_t input_length, size_t &amp;input_consumed, bool final_inputs)</td></tr>
<tr class="separator:a6523ad22d65fe36562fd3c6ab12f5b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043fc1f11e0639e191f3735355b76c08"><td class="memItemLeft" align="right" valign="top"><a id="a043fc1f11e0639e191f3735355b76c08"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>base64_encode</b> (const uint8_t input[], size_t input_length)</td></tr>
<tr class="separator:a043fc1f11e0639e191f3735355b76c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840616cbb8c9fffedde8508a10f06e9f"><td class="memItemLeft" align="right" valign="top"><a id="a840616cbb8c9fffedde8508a10f06e9f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base64_decode</b> (uint8_t out[], const char in[], size_t input_length, size_t &amp;input_consumed, bool final_inputs, bool ignore_ws)</td></tr>
<tr class="separator:a840616cbb8c9fffedde8508a10f06e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fbd9eed5cd70c5ac34015f9c6578a1"><td class="memItemLeft" align="right" valign="top"><a id="a44fbd9eed5cd70c5ac34015f9c6578a1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base64_decode</b> (uint8_t output[], const char input[], size_t input_length, bool ignore_ws)</td></tr>
<tr class="separator:a44fbd9eed5cd70c5ac34015f9c6578a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b5a2020a00373f789d3c81dccba41b"><td class="memItemLeft" align="right" valign="top"><a id="a74b5a2020a00373f789d3c81dccba41b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base64_decode</b> (uint8_t output[], const std::string &amp;input, bool ignore_ws)</td></tr>
<tr class="separator:a74b5a2020a00373f789d3c81dccba41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcc604809015edf46a9e5d1a6118754"><td class="memItemLeft" align="right" valign="top"><a id="adbcc604809015edf46a9e5d1a6118754"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>base64_decode</b> (const char input[], size_t input_length, bool ignore_ws)</td></tr>
<tr class="separator:adbcc604809015edf46a9e5d1a6118754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e42438968d9eb2c77cb6c84f2e6480"><td class="memItemLeft" align="right" valign="top"><a id="ad3e42438968d9eb2c77cb6c84f2e6480"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>base64_decode</b> (const std::string &amp;input, bool ignore_ws)</td></tr>
<tr class="separator:ad3e42438968d9eb2c77cb6c84f2e6480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f58590365a92ccd97fac90b7d1fe53c"><td class="memItemLeft" align="right" valign="top"><a id="a9f58590365a92ccd97fac90b7d1fe53c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base64_encode_max_output</b> (size_t input_length)</td></tr>
<tr class="separator:a9f58590365a92ccd97fac90b7d1fe53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac87499eb132d9d0c6231099e83b8c5b"><td class="memItemLeft" align="right" valign="top"><a id="aac87499eb132d9d0c6231099e83b8c5b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>base64_decode_max_output</b> (size_t input_length)</td></tr>
<tr class="separator:aac87499eb132d9d0c6231099e83b8c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae612d0f1287d36555adbe7ed4d8f171f"><td class="memTemplParams" colspan="2">template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:ae612d0f1287d36555adbe7ed4d8f171f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ae612d0f1287d36555adbe7ed4d8f171f">base64_encode</a> (const std::vector&lt; uint8_t, Alloc &gt; &amp;input)</td></tr>
<tr class="separator:ae612d0f1287d36555adbe7ed4d8f171f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835833515e6080a0d56a13ff99ef4958"><td class="memItemLeft" align="right" valign="top">secure_vector&lt; uint8_t &gt; BOTAN_PUBLIC_API(2, 0) base64_decode(const std size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a835833515e6080a0d56a13ff99ef4958">BOTAN_PUBLIC_API</a> (2, 1) base64_encode_max_output(size_t input_length)</td></tr>
<tr class="separator:a835833515e6080a0d56a13ff99ef4958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa010aeebafe9ae6ba3134760b3fe3236"><td class="memItemLeft" align="right" valign="top"><a id="aa010aeebafe9ae6ba3134760b3fe3236"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>hex_encode</b> (char output[], const uint8_t input[], size_t input_length, bool uppercase)</td></tr>
<tr class="separator:aa010aeebafe9ae6ba3134760b3fe3236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1855c262ee9f7be53e49811ac94c4f20"><td class="memItemLeft" align="right" valign="top"><a id="a1855c262ee9f7be53e49811ac94c4f20"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>hex_encode</b> (const uint8_t input[], size_t input_length, bool uppercase)</td></tr>
<tr class="separator:a1855c262ee9f7be53e49811ac94c4f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93c5a46ff7edd2c3803b3d43c677131"><td class="memItemLeft" align="right" valign="top"><a id="ab93c5a46ff7edd2c3803b3d43c677131"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hex_decode</b> (uint8_t output[], const char input[], size_t input_length, size_t &amp;input_consumed, bool ignore_ws)</td></tr>
<tr class="separator:ab93c5a46ff7edd2c3803b3d43c677131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa937b612b7607a0bb4407a93633c4f7e"><td class="memItemLeft" align="right" valign="top"><a id="aa937b612b7607a0bb4407a93633c4f7e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hex_decode</b> (uint8_t output[], const char input[], size_t input_length, bool ignore_ws)</td></tr>
<tr class="separator:aa937b612b7607a0bb4407a93633c4f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285ac19269646074a6c40a54bde70c3e"><td class="memItemLeft" align="right" valign="top"><a id="a285ac19269646074a6c40a54bde70c3e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hex_decode</b> (uint8_t output[], const std::string &amp;input, bool ignore_ws)</td></tr>
<tr class="separator:a285ac19269646074a6c40a54bde70c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4200b7862f58f433e8f9f1a1a3979e36"><td class="memItemLeft" align="right" valign="top"><a id="a4200b7862f58f433e8f9f1a1a3979e36"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hex_decode_locked</b> (const char input[], size_t input_length, bool ignore_ws)</td></tr>
<tr class="separator:a4200b7862f58f433e8f9f1a1a3979e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426ca3673c2465a190f37e38b1fd6dfb"><td class="memItemLeft" align="right" valign="top"><a id="a426ca3673c2465a190f37e38b1fd6dfb"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hex_decode_locked</b> (const std::string &amp;input, bool ignore_ws)</td></tr>
<tr class="separator:a426ca3673c2465a190f37e38b1fd6dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fbf80da5e9135f06f8d365028cab7c"><td class="memItemLeft" align="right" valign="top"><a id="a71fbf80da5e9135f06f8d365028cab7c"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hex_decode</b> (const char input[], size_t input_length, bool ignore_ws)</td></tr>
<tr class="separator:a71fbf80da5e9135f06f8d365028cab7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbe2b31215abb865813b82afed3d5ab"><td class="memItemLeft" align="right" valign="top"><a id="a3fbe2b31215abb865813b82afed3d5ab"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hex_decode</b> (const std::string &amp;input, bool ignore_ws)</td></tr>
<tr class="separator:a3fbe2b31215abb865813b82afed3d5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a63d270351924b382780ee6d5b80c3"><td class="memTemplParams" colspan="2">template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a02a63d270351924b382780ee6d5b80c3"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a02a63d270351924b382780ee6d5b80c3">hex_encode</a> (const std::vector&lt; uint8_t, Alloc &gt; &amp;input, bool uppercase=true)</td></tr>
<tr class="separator:a02a63d270351924b382780ee6d5b80c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf74fd3f39d9002f4ecdb5d0f4c298a"><td class="memItemLeft" align="right" valign="top"><a id="afaf74fd3f39d9002f4ecdb5d0f4c298a"></a>
Compression_Algorithm *&#160;</td><td class="memItemRight" valign="bottom"><b>make_compressor</b> (const std::string &amp;name)</td></tr>
<tr class="separator:afaf74fd3f39d9002f4ecdb5d0f4c298a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30aeec33fee5a682981b7881f226d7f4"><td class="memItemLeft" align="right" valign="top"><a id="a30aeec33fee5a682981b7881f226d7f4"></a>
Decompression_Algorithm *&#160;</td><td class="memItemRight" valign="bottom"><b>make_decompressor</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a30aeec33fee5a682981b7881f226d7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba93d9533451120c2ccbf20d98e36174"><td class="memItemLeft" align="right" valign="top"><a id="aba93d9533451120c2ccbf20d98e36174"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (int fd, Pipe &amp;pipe)</td></tr>
<tr class="separator:aba93d9533451120c2ccbf20d98e36174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad754977484e0b22a355e21a532a03f2"><td class="memItemLeft" align="right" valign="top"><a id="aad754977484e0b22a355e21a532a03f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (int fd, Pipe &amp;pipe)</td></tr>
<tr class="separator:aad754977484e0b22a355e21a532a03f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78d533e2e82a7d2b4faa81c5d4224f0"><td class="memItemLeft" align="right" valign="top"><a id="ac78d533e2e82a7d2b4faa81c5d4224f0"></a>
Keyed_Filter *&#160;</td><td class="memItemRight" valign="bottom"><b>get_cipher</b> (const std::string &amp;algo_spec, <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> direction)</td></tr>
<tr class="separator:ac78d533e2e82a7d2b4faa81c5d4224f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dafb0ec13984e6f235962840ed739d"><td class="memItemLeft" align="right" valign="top"><a id="af3dafb0ec13984e6f235962840ed739d"></a>
Keyed_Filter *&#160;</td><td class="memItemRight" valign="bottom"><b>get_cipher</b> (const std::string &amp;algo_spec, const <a class="el" href="namespace_botan.html#a89cf6c3513428f524454d01830221a88">SymmetricKey</a> &amp;key, const <a class="el" href="namespace_botan.html#a2fbf5195ffe701adcabb1f8c41bfc557">InitializationVector</a> &amp;iv, <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> direction)</td></tr>
<tr class="separator:af3dafb0ec13984e6f235962840ed739d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4812fd30c23cfef674079a880f77d488"><td class="memItemLeft" align="right" valign="top"><a id="a4812fd30c23cfef674079a880f77d488"></a>
Keyed_Filter *&#160;</td><td class="memItemRight" valign="bottom"><b>get_cipher</b> (const std::string &amp;algo_spec, const <a class="el" href="namespace_botan.html#a89cf6c3513428f524454d01830221a88">SymmetricKey</a> &amp;key, <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> direction)</td></tr>
<tr class="separator:a4812fd30c23cfef674079a880f77d488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aef852313d73e0e847a5470244004c3"><td class="memItemLeft" align="right" valign="top"><a id="a2aef852313d73e0e847a5470244004c3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;stream, Pipe &amp;pipe)</td></tr>
<tr class="separator:a2aef852313d73e0e847a5470244004c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c6e40d8646fceedeeb2a9bf662ff2c"><td class="memItemLeft" align="right" valign="top"><a id="a48c6e40d8646fceedeeb2a9bf662ff2c"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;stream, Pipe &amp;pipe)</td></tr>
<tr class="separator:a48c6e40d8646fceedeeb2a9bf662ff2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c19b037c4ae9e0c73c604d4df75ebe"><td class="memItemLeft" align="right" valign="top"><a id="af1c19b037c4ae9e0c73c604d4df75ebe"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>hkdf_expand_label</b> (const std::string &amp;hash_fn, const uint8_t secret[], size_t secret_len, const std::string &amp;label, const uint8_t hash_val[], size_t hash_val_len, size_t length)</td></tr>
<tr class="separator:af1c19b037c4ae9e0c73c604d4df75ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95618c8fe8fd211f5a92853007228bc7"><td class="memItemLeft" align="right" valign="top"><a id="a95618c8fe8fd211f5a92853007228bc7"></a>
KDF *&#160;</td><td class="memItemRight" valign="bottom"><b>get_kdf</b> (const std::string &amp;algo_spec)</td></tr>
<tr class="separator:a95618c8fe8fd211f5a92853007228bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6229f0096f2241baaddf1b905077c4e0"><td class="memItemLeft" align="right" valign="top"><a id="a6229f0096f2241baaddf1b905077c4e0"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;stream, const BigInt &amp;n)</td></tr>
<tr class="separator:a6229f0096f2241baaddf1b905077c4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33d22bc29cd11c4edfa5ba1ff05895b"><td class="memItemLeft" align="right" valign="top"><a id="ae33d22bc29cd11c4edfa5ba1ff05895b"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;stream, BigInt &amp;n)</td></tr>
<tr class="separator:ae33d22bc29cd11c4edfa5ba1ff05895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e32cc5fc8e75531b11c6e6f51310d83"><td class="memItemLeft" align="right" valign="top"><a id="a9e32cc5fc8e75531b11c6e6f51310d83"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const BigInt &amp;x, const BigInt &amp;y)</td></tr>
<tr class="separator:a9e32cc5fc8e75531b11c6e6f51310d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37adccc7857d4594e403bf41c5a8476d"><td class="memItemLeft" align="right" valign="top"><a id="a37adccc7857d4594e403bf41c5a8476d"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const BigInt &amp;x, word y)</td></tr>
<tr class="separator:a37adccc7857d4594e403bf41c5a8476d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66643ed3bed15c00235afd74dc52f674"><td class="memItemLeft" align="right" valign="top"><a id="a66643ed3bed15c00235afd74dc52f674"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const BigInt &amp;x, const BigInt &amp;y)</td></tr>
<tr class="separator:a66643ed3bed15c00235afd74dc52f674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d38462775851d306e1381ccf3468c9"><td class="memItemLeft" align="right" valign="top"><a id="a19d38462775851d306e1381ccf3468c9"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const BigInt &amp;x, word y)</td></tr>
<tr class="separator:a19d38462775851d306e1381ccf3468c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2517208e22a450179542421e18fb22ae"><td class="memItemLeft" align="right" valign="top"><a id="a2517208e22a450179542421e18fb22ae"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const BigInt &amp;x, const BigInt &amp;y)</td></tr>
<tr class="separator:a2517208e22a450179542421e18fb22ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadad0f30765384d067cd7fedb9cfb8c"><td class="memItemLeft" align="right" valign="top"><a id="aeadad0f30765384d067cd7fedb9cfb8c"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const BigInt &amp;x, word y)</td></tr>
<tr class="separator:aeadad0f30765384d067cd7fedb9cfb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58016166908e4a05f874f81447c2afde"><td class="memItemLeft" align="right" valign="top"><a id="a58016166908e4a05f874f81447c2afde"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const BigInt &amp;x, const BigInt &amp;y)</td></tr>
<tr class="separator:a58016166908e4a05f874f81447c2afde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1b142817836cb6fd85c1b551542fab"><td class="memItemLeft" align="right" valign="top"><a id="a5b1b142817836cb6fd85c1b551542fab"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator%</b> (const BigInt &amp;n, const BigInt &amp;mod)</td></tr>
<tr class="separator:a5b1b142817836cb6fd85c1b551542fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6c3b632ccafdd69f927e9a72c10d9a"><td class="memItemLeft" align="right" valign="top"><a id="a3c6c3b632ccafdd69f927e9a72c10d9a"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>operator%</b> (const BigInt &amp;n, word mod)</td></tr>
<tr class="separator:a3c6c3b632ccafdd69f927e9a72c10d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16efbc1028d2c66f6d683370ab2596c5"><td class="memItemLeft" align="right" valign="top"><a id="a16efbc1028d2c66f6d683370ab2596c5"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const BigInt &amp;x, size_t shift)</td></tr>
<tr class="separator:a16efbc1028d2c66f6d683370ab2596c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab9781dbf9f27b3a71c009f70b90bd2"><td class="memItemLeft" align="right" valign="top"><a id="a0ab9781dbf9f27b3a71c009f70b90bd2"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const BigInt &amp;x, size_t shift)</td></tr>
<tr class="separator:a0ab9781dbf9f27b3a71c009f70b90bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad149e905ab31f7795dbf2ca0c4b336"><td class="memItemLeft" align="right" valign="top">BigInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a1ad149e905ab31f7795dbf2ca0c4b336">BOTAN_PUBLIC_API</a> (2, 7) operator+(const BigInt &amp;x</td></tr>
<tr class="separator:a1ad149e905ab31f7795dbf2ca0c4b336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adb28cb65a6ef57526c285a2c1870bc"><td class="memItemLeft" align="right" valign="top"><a id="a5adb28cb65a6ef57526c285a2c1870bc"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (word x, const BigInt &amp;y)</td></tr>
<tr class="separator:a5adb28cb65a6ef57526c285a2c1870bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bceeeb9c924b9a9600daa1fe19b073"><td class="memItemLeft" align="right" valign="top">BigInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a33bceeeb9c924b9a9600daa1fe19b073">BOTAN_PUBLIC_API</a> (2, 8) operator*(const BigInt &amp;x</td></tr>
<tr class="separator:a33bceeeb9c924b9a9600daa1fe19b073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d21ef0e33c52a3d4624003b0d002bc7"><td class="memItemLeft" align="right" valign="top"><a id="a0d21ef0e33c52a3d4624003b0d002bc7"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (word x, const BigInt &amp;y)</td></tr>
<tr class="separator:a0d21ef0e33c52a3d4624003b0d002bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af911990ac0bbc2915a52d87b8be9829c"><td class="memItemLeft" align="right" valign="top"><a id="af911990ac0bbc2915a52d87b8be9829c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const BigInt &amp;a, const BigInt &amp;b)</td></tr>
<tr class="separator:af911990ac0bbc2915a52d87b8be9829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3134b689eace5f745309ca642881255c"><td class="memItemLeft" align="right" valign="top"><a id="a3134b689eace5f745309ca642881255c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const BigInt &amp;a, const BigInt &amp;b)</td></tr>
<tr class="separator:a3134b689eace5f745309ca642881255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac161333faf41df65f4bee80dc198c0e6"><td class="memItemLeft" align="right" valign="top"><a id="ac161333faf41df65f4bee80dc198c0e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const BigInt &amp;a, const BigInt &amp;b)</td></tr>
<tr class="separator:ac161333faf41df65f4bee80dc198c0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdc148618d75af7f7dffb989bbc5ed7"><td class="memItemLeft" align="right" valign="top"><a id="a4cdc148618d75af7f7dffb989bbc5ed7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const BigInt &amp;a, const BigInt &amp;b)</td></tr>
<tr class="separator:a4cdc148618d75af7f7dffb989bbc5ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661756a0681456da17b09d32d0f66a9e"><td class="memItemLeft" align="right" valign="top"><a id="a661756a0681456da17b09d32d0f66a9e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const BigInt &amp;a, const BigInt &amp;b)</td></tr>
<tr class="separator:a661756a0681456da17b09d32d0f66a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2298f10cbf9e9d22db9fe7a3f8fb062"><td class="memItemLeft" align="right" valign="top"><a id="af2298f10cbf9e9d22db9fe7a3f8fb062"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const BigInt &amp;a, const BigInt &amp;b)</td></tr>
<tr class="separator:af2298f10cbf9e9d22db9fe7a3f8fb062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1f005950763c0ae5f7f4a16f8c638f"><td class="memItemLeft" align="right" valign="top"><a id="a1b1f005950763c0ae5f7f4a16f8c638f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const BigInt &amp;a, word b)</td></tr>
<tr class="separator:a1b1f005950763c0ae5f7f4a16f8c638f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c510e40758e809adbfe81e6ccbae84"><td class="memItemLeft" align="right" valign="top"><a id="a93c510e40758e809adbfe81e6ccbae84"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const BigInt &amp;a, word b)</td></tr>
<tr class="separator:a93c510e40758e809adbfe81e6ccbae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5f6ab5fd90bdaf8872135205bee956"><td class="memItemLeft" align="right" valign="top"><a id="aae5f6ab5fd90bdaf8872135205bee956"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const BigInt &amp;a, word b)</td></tr>
<tr class="separator:aae5f6ab5fd90bdaf8872135205bee956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3cb7aa80d65613274b6ecaa5136951"><td class="memItemLeft" align="right" valign="top"><a id="a7d3cb7aa80d65613274b6ecaa5136951"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const BigInt &amp;a, word b)</td></tr>
<tr class="separator:a7d3cb7aa80d65613274b6ecaa5136951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ec8a493a84e4b8a0cc9c3c6090a6c"><td class="memItemLeft" align="right" valign="top"><a id="a3b1ec8a493a84e4b8a0cc9c3c6090a6c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const BigInt &amp;a, word b)</td></tr>
<tr class="separator:a3b1ec8a493a84e4b8a0cc9c3c6090a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef792f3bade66468fe384572286f983d"><td class="memItemLeft" align="right" valign="top"><a id="aef792f3bade66468fe384572286f983d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const BigInt &amp;a, word b)</td></tr>
<tr class="separator:aef792f3bade66468fe384572286f983d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b337ea48c9d452210206c8480fec7ab"><td class="memItemLeft" align="right" valign="top"><a id="a7b337ea48c9d452210206c8480fec7ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>divide</b> (const BigInt &amp;x, const BigInt &amp;y_arg, BigInt &amp;q, BigInt &amp;r)</td></tr>
<tr class="separator:a7b337ea48c9d452210206c8480fec7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf18b236a09407a575bc44df6581ba1"><td class="memItemLeft" align="right" valign="top"><a id="aadf18b236a09407a575bc44df6581ba1"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word_add</b> (word x, word y, word *carry)</td></tr>
<tr class="separator:aadf18b236a09407a575bc44df6581ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5898d196aabbdf38c74b7f03b52cfb76"><td class="memItemLeft" align="right" valign="top"><a id="a5898d196aabbdf38c74b7f03b52cfb76"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word8_add2</b> (word x[8], const word y[8], word carry)</td></tr>
<tr class="separator:a5898d196aabbdf38c74b7f03b52cfb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82aa291d5f3438ec4c380a86eb8893a6"><td class="memItemLeft" align="right" valign="top"><a id="a82aa291d5f3438ec4c380a86eb8893a6"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word8_add3</b> (word z[8], const word x[8], const word y[8], word carry)</td></tr>
<tr class="separator:a82aa291d5f3438ec4c380a86eb8893a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111b44a20862b5c882c6e916c5b74126"><td class="memItemLeft" align="right" valign="top"><a id="a111b44a20862b5c882c6e916c5b74126"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word_sub</b> (word x, word y, word *carry)</td></tr>
<tr class="separator:a111b44a20862b5c882c6e916c5b74126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2438179f85074db546171eeddcff9bef"><td class="memItemLeft" align="right" valign="top"><a id="a2438179f85074db546171eeddcff9bef"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word8_sub2</b> (word x[8], const word y[8], word carry)</td></tr>
<tr class="separator:a2438179f85074db546171eeddcff9bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91e1138f9d281c77c89f1ecc892e717"><td class="memItemLeft" align="right" valign="top"><a id="ac91e1138f9d281c77c89f1ecc892e717"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word8_sub2_rev</b> (word x[8], const word y[8], word carry)</td></tr>
<tr class="separator:ac91e1138f9d281c77c89f1ecc892e717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d94b0082a82368807a32080797a845"><td class="memItemLeft" align="right" valign="top"><a id="a04d94b0082a82368807a32080797a845"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word8_sub3</b> (word z[8], const word x[8], const word y[8], word carry)</td></tr>
<tr class="separator:a04d94b0082a82368807a32080797a845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c98a507837662f72fde19b95fe17410"><td class="memItemLeft" align="right" valign="top"><a id="a6c98a507837662f72fde19b95fe17410"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word8_linmul2</b> (word x[8], word y, word carry)</td></tr>
<tr class="separator:a6c98a507837662f72fde19b95fe17410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b52521e8eb536fa0c5818344a143f86"><td class="memItemLeft" align="right" valign="top"><a id="a5b52521e8eb536fa0c5818344a143f86"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word8_linmul3</b> (word z[8], const word x[8], word y, word carry)</td></tr>
<tr class="separator:a5b52521e8eb536fa0c5818344a143f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05970f4cd10cae2e0d0404fec0a0422f"><td class="memItemLeft" align="right" valign="top"><a id="a05970f4cd10cae2e0d0404fec0a0422f"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word8_madd3</b> (word z[8], const word x[8], word y, word carry)</td></tr>
<tr class="separator:a05970f4cd10cae2e0d0404fec0a0422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811a309dd3ad51a5f63f9100337ad144"><td class="memItemLeft" align="right" valign="top"><a id="a811a309dd3ad51a5f63f9100337ad144"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>word3_muladd</b> (word *w2, word *w1, word *w0, word x, word y)</td></tr>
<tr class="separator:a811a309dd3ad51a5f63f9100337ad144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe47ded26fff4bf68d95106af8879c22"><td class="memItemLeft" align="right" valign="top"><a id="abe47ded26fff4bf68d95106af8879c22"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>word3_add</b> (word *w2, word *w1, word *w0, word x)</td></tr>
<tr class="separator:abe47ded26fff4bf68d95106af8879c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cdfd76496ff340c2e1970d1cde1337"><td class="memItemLeft" align="right" valign="top"><a id="ab8cdfd76496ff340c2e1970d1cde1337"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>word3_muladd_2</b> (word *w2, word *w1, word *w0, word x, word y)</td></tr>
<tr class="separator:ab8cdfd76496ff340c2e1970d1cde1337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6860ccbbfd8836827cd5bf6c3bfae807"><td class="memItemLeft" align="right" valign="top"><a id="a6860ccbbfd8836827cd5bf6c3bfae807"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_sqr4</b> (word z[8], const word x[4])</td></tr>
<tr class="separator:a6860ccbbfd8836827cd5bf6c3bfae807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd2af85783a80acdb744dd0a13c346d"><td class="memItemLeft" align="right" valign="top"><a id="a1fd2af85783a80acdb744dd0a13c346d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_mul4</b> (word z[8], const word x[4], const word y[4])</td></tr>
<tr class="separator:a1fd2af85783a80acdb744dd0a13c346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c556b6e52529aee71f16bdd2d8e10c0"><td class="memItemLeft" align="right" valign="top"><a id="a2c556b6e52529aee71f16bdd2d8e10c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_sqr6</b> (word z[12], const word x[6])</td></tr>
<tr class="separator:a2c556b6e52529aee71f16bdd2d8e10c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae228fc8d81499547ab6d629b0864f54f"><td class="memItemLeft" align="right" valign="top"><a id="ae228fc8d81499547ab6d629b0864f54f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_mul6</b> (word z[12], const word x[6], const word y[6])</td></tr>
<tr class="separator:ae228fc8d81499547ab6d629b0864f54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1eb8900e753075962ec4a8ea38536f"><td class="memItemLeft" align="right" valign="top"><a id="aee1eb8900e753075962ec4a8ea38536f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_sqr8</b> (word z[16], const word x[8])</td></tr>
<tr class="separator:aee1eb8900e753075962ec4a8ea38536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59661689c552486b99c1e7a56e610835"><td class="memItemLeft" align="right" valign="top"><a id="a59661689c552486b99c1e7a56e610835"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_mul8</b> (word z[16], const word x[8], const word y[8])</td></tr>
<tr class="separator:a59661689c552486b99c1e7a56e610835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d10e3bca2dbd969fd2e232ed8dec03"><td class="memItemLeft" align="right" valign="top"><a id="a79d10e3bca2dbd969fd2e232ed8dec03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_sqr9</b> (word z[18], const word x[9])</td></tr>
<tr class="separator:a79d10e3bca2dbd969fd2e232ed8dec03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39ab0e2749117461149c90d7257165b"><td class="memItemLeft" align="right" valign="top"><a id="ab39ab0e2749117461149c90d7257165b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_mul9</b> (word z[18], const word x[9], const word y[9])</td></tr>
<tr class="separator:ab39ab0e2749117461149c90d7257165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ebe1c6ee7857c89289468549532a3e"><td class="memItemLeft" align="right" valign="top"><a id="a30ebe1c6ee7857c89289468549532a3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_sqr16</b> (word z[32], const word x[16])</td></tr>
<tr class="separator:a30ebe1c6ee7857c89289468549532a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5900b5388f9c73ab26a964a45f734c"><td class="memItemLeft" align="right" valign="top"><a id="adf5900b5388f9c73ab26a964a45f734c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_mul16</b> (word z[32], const word x[16], const word y[16])</td></tr>
<tr class="separator:adf5900b5388f9c73ab26a964a45f734c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0ff2f5395f16456b301a51f460fd7"><td class="memItemLeft" align="right" valign="top"><a id="aa1c0ff2f5395f16456b301a51f460fd7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_sqr24</b> (word z[48], const word x[24])</td></tr>
<tr class="separator:aa1c0ff2f5395f16456b301a51f460fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c9784ce152ae5b93e069c17dda9efc"><td class="memItemLeft" align="right" valign="top"><a id="a95c9784ce152ae5b93e069c17dda9efc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_comba_mul24</b> (word z[48], const word x[24], const word y[24])</td></tr>
<tr class="separator:a95c9784ce152ae5b93e069c17dda9efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01ddbecf986eb6cfa5f827329e597f1"><td class="memItemLeft" align="right" valign="top"><a id="ab01ddbecf986eb6cfa5f827329e597f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_cnd_swap</b> (word cnd, word x[], word y[], size_t size)</td></tr>
<tr class="separator:ab01ddbecf986eb6cfa5f827329e597f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61087c72df0cb4e48c6e592e3dc33504"><td class="memItemLeft" align="right" valign="top"><a id="a61087c72df0cb4e48c6e592e3dc33504"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_cnd_add</b> (word cnd, word x[], const word y[], size_t size)</td></tr>
<tr class="separator:a61087c72df0cb4e48c6e592e3dc33504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cfc5af3085f44856d3656b802c0d2a"><td class="memItemLeft" align="right" valign="top"><a id="a90cfc5af3085f44856d3656b802c0d2a"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_cnd_sub</b> (word cnd, word x[], const word y[], size_t size)</td></tr>
<tr class="separator:a90cfc5af3085f44856d3656b802c0d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd797de418a99fb564dc3b347be5de09"><td class="memItemLeft" align="right" valign="top"><a id="afd797de418a99fb564dc3b347be5de09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_cnd_addsub</b> (word mask, word x[], const word y[], size_t size)</td></tr>
<tr class="separator:afd797de418a99fb564dc3b347be5de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae189b06d3f78a38ff6f91241f3e51cdf"><td class="memItemLeft" align="right" valign="top"><a id="ae189b06d3f78a38ff6f91241f3e51cdf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_cnd_abs</b> (word cnd, word x[], size_t size)</td></tr>
<tr class="separator:ae189b06d3f78a38ff6f91241f3e51cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f4a27c1c5bf03f1a8dab57f2a41a13"><td class="memItemLeft" align="right" valign="top">word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ab8f4a27c1c5bf03f1a8dab57f2a41a13">bigint_add2_nc</a> (word x[], size_t x_size, const word y[], size_t y_size)</td></tr>
<tr class="separator:ab8f4a27c1c5bf03f1a8dab57f2a41a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b0c61acfab2f864b2cf3999ca76c01"><td class="memItemLeft" align="right" valign="top">word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ac6b0c61acfab2f864b2cf3999ca76c01">bigint_add3_nc</a> (word z[], const word x[], size_t x_size, const word y[], size_t y_size)</td></tr>
<tr class="separator:ac6b0c61acfab2f864b2cf3999ca76c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909ae118a4227e2c3b1d6dac8cde629c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a909ae118a4227e2c3b1d6dac8cde629c">bigint_add2</a> (word x[], size_t x_size, const word y[], size_t y_size)</td></tr>
<tr class="separator:a909ae118a4227e2c3b1d6dac8cde629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b90c82b13db8553eaa2701a8dd5975f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a2b90c82b13db8553eaa2701a8dd5975f">bigint_add3</a> (word z[], const word x[], size_t x_size, const word y[], size_t y_size)</td></tr>
<tr class="separator:a2b90c82b13db8553eaa2701a8dd5975f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2b962eb5d832116befc5957a6c975e"><td class="memItemLeft" align="right" valign="top">word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a1d2b962eb5d832116befc5957a6c975e">bigint_sub2</a> (word x[], size_t x_size, const word y[], size_t y_size)</td></tr>
<tr class="separator:a1d2b962eb5d832116befc5957a6c975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108c3a5b46712583de64a39d5fa6841b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a108c3a5b46712583de64a39d5fa6841b">bigint_sub2_rev</a> (word x[], const word y[], size_t y_size)</td></tr>
<tr class="separator:a108c3a5b46712583de64a39d5fa6841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea10868dfcff0fcf7e44adc40192908"><td class="memItemLeft" align="right" valign="top">word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a8ea10868dfcff0fcf7e44adc40192908">bigint_sub_abs</a> (word z[], const word x[], const word y[], size_t N, word ws[])</td></tr>
<tr class="separator:a8ea10868dfcff0fcf7e44adc40192908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdda04dbd8f4ec5aab85af9983e9c7a"><td class="memItemLeft" align="right" valign="top">word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aecdda04dbd8f4ec5aab85af9983e9c7a">bigint_sub3</a> (word z[], const word x[], size_t x_size, const word y[], size_t y_size)</td></tr>
<tr class="separator:aecdda04dbd8f4ec5aab85af9983e9c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaae60574552cb9732a25e7dc343b31d"><td class="memItemLeft" align="right" valign="top"><a id="adaae60574552cb9732a25e7dc343b31d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_linmul2</b> (word x[], size_t x_size, word y)</td></tr>
<tr class="separator:adaae60574552cb9732a25e7dc343b31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0dbb64f0550a99fa972cb7400be41"><td class="memItemLeft" align="right" valign="top"><a id="a13a0dbb64f0550a99fa972cb7400be41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_linmul3</b> (word z[], const word x[], size_t x_size, word y)</td></tr>
<tr class="separator:a13a0dbb64f0550a99fa972cb7400be41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24872afc46265755e52a59856c98454d"><td class="memItemLeft" align="right" valign="top"><a id="a24872afc46265755e52a59856c98454d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_shl1</b> (word x[], size_t x_size, size_t word_shift, size_t bit_shift)</td></tr>
<tr class="separator:a24872afc46265755e52a59856c98454d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b30e71e7edbaffbf2cc2064a523c3e"><td class="memItemLeft" align="right" valign="top"><a id="a11b30e71e7edbaffbf2cc2064a523c3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_shr1</b> (word x[], size_t x_size, size_t word_shift, size_t bit_shift)</td></tr>
<tr class="separator:a11b30e71e7edbaffbf2cc2064a523c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbf6925cd8001d366fd3fb5f50ddc7e"><td class="memItemLeft" align="right" valign="top"><a id="a7dbf6925cd8001d366fd3fb5f50ddc7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_shl2</b> (word y[], const word x[], size_t x_size, size_t word_shift, size_t bit_shift)</td></tr>
<tr class="separator:a7dbf6925cd8001d366fd3fb5f50ddc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac391d5980517de118fb57b798ab9e48a"><td class="memItemLeft" align="right" valign="top"><a id="ac391d5980517de118fb57b798ab9e48a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_shr2</b> (word y[], const word x[], size_t x_size, size_t word_shift, size_t bit_shift)</td></tr>
<tr class="separator:ac391d5980517de118fb57b798ab9e48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2360db2beff295a13a8e3a96136a61"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ada2360db2beff295a13a8e3a96136a61">bigint_cmp</a> (const word x[], size_t x_size, const word y[], size_t y_size)</td></tr>
<tr class="separator:ada2360db2beff295a13a8e3a96136a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cea0cc0c767a608413ba0cac4e74c4"><td class="memItemLeft" align="right" valign="top">word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a02cea0cc0c767a608413ba0cac4e74c4">bigint_divop</a> (word n1, word n0, word d)</td></tr>
<tr class="separator:a02cea0cc0c767a608413ba0cac4e74c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd94b3a9b524da12c07a88fdda1eb7"><td class="memItemLeft" align="right" valign="top">word&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#acffd94b3a9b524da12c07a88fdda1eb7">bigint_modop</a> (word n1, word n0, word d)</td></tr>
<tr class="separator:acffd94b3a9b524da12c07a88fdda1eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafff2116e1ca1980d42a3efdf85c9287"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aafff2116e1ca1980d42a3efdf85c9287">bigint_monty_redc</a> (word z[], const word p[], size_t p_size, word p_dash, word workspace[], size_t ws_size)</td></tr>
<tr class="separator:aafff2116e1ca1980d42a3efdf85c9287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b73ab3c85a16543c15c3a307f381998"><td class="memItemLeft" align="right" valign="top"><a id="a4b73ab3c85a16543c15c3a307f381998"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_mul</b> (word z[], size_t z_size, const word x[], size_t x_size, size_t x_sw, const word y[], size_t y_size, size_t y_sw, word workspace[], size_t ws_size)</td></tr>
<tr class="separator:a4b73ab3c85a16543c15c3a307f381998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416511ccb202ccb0ba5706e67bd82bdc"><td class="memItemLeft" align="right" valign="top"><a id="a416511ccb202ccb0ba5706e67bd82bdc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_sqr</b> (word z[], size_t z_size, const word x[], size_t x_size, size_t x_sw, word workspace[], size_t ws_size)</td></tr>
<tr class="separator:a416511ccb202ccb0ba5706e67bd82bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa514bc78b9f0d9357573283e43efda66"><td class="memItemLeft" align="right" valign="top"><a id="aa514bc78b9f0d9357573283e43efda66"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word_madd2</b> (word a, word b, word *c)</td></tr>
<tr class="separator:aa514bc78b9f0d9357573283e43efda66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7619806b10d1b3e4f18da3a48f11138b"><td class="memItemLeft" align="right" valign="top"><a id="a7619806b10d1b3e4f18da3a48f11138b"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>word_madd3</b> (word a, word b, word c, word *d)</td></tr>
<tr class="separator:a7619806b10d1b3e4f18da3a48f11138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd7e8bdca06264c6618d623449fb12b"><td class="memItemLeft" align="right" valign="top"><a id="aafd7e8bdca06264c6618d623449fb12b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_4</b> (word z[], const word p[], word p_dash, word ws[])</td></tr>
<tr class="separator:aafd7e8bdca06264c6618d623449fb12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25af6d3eb409a844145f2a9700acc69"><td class="memItemLeft" align="right" valign="top"><a id="ad25af6d3eb409a844145f2a9700acc69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_6</b> (word z[], const word p[], word p_dash, word ws[])</td></tr>
<tr class="separator:ad25af6d3eb409a844145f2a9700acc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9287bd9b06abfbe9bf381bf6c2afd540"><td class="memItemLeft" align="right" valign="top"><a id="a9287bd9b06abfbe9bf381bf6c2afd540"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_8</b> (word z[], const word p[], word p_dash, word ws[])</td></tr>
<tr class="separator:a9287bd9b06abfbe9bf381bf6c2afd540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b90ddb705000e79c5ca5fa2b8d6772"><td class="memItemLeft" align="right" valign="top"><a id="aa5b90ddb705000e79c5ca5fa2b8d6772"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_16</b> (word z[], const word p[], word p_dash, word ws[])</td></tr>
<tr class="separator:aa5b90ddb705000e79c5ca5fa2b8d6772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b791e811e15d36f26b423c942096ff1"><td class="memItemLeft" align="right" valign="top"><a id="a8b791e811e15d36f26b423c942096ff1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_24</b> (word z[], const word p[], word p_dash, word ws[])</td></tr>
<tr class="separator:a8b791e811e15d36f26b423c942096ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12884a43301a1179180749131a26c3f"><td class="memItemLeft" align="right" valign="top"><a id="ad12884a43301a1179180749131a26c3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_32</b> (word z[], const word p[], word p_dash, word ws[])</td></tr>
<tr class="separator:ad12884a43301a1179180749131a26c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078383cf9442a9cc51f7a529a94bca49"><td class="memItemLeft" align="right" valign="top"><a id="a078383cf9442a9cc51f7a529a94bca49"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_4</b> (word z[], const word p[4], word p_dash, word ws[])</td></tr>
<tr class="separator:a078383cf9442a9cc51f7a529a94bca49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bfaa5b64934aa73e9aaff2509d0512"><td class="memItemLeft" align="right" valign="top"><a id="a45bfaa5b64934aa73e9aaff2509d0512"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_6</b> (word z[], const word p[6], word p_dash, word ws[])</td></tr>
<tr class="separator:a45bfaa5b64934aa73e9aaff2509d0512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7612c53942a7bee031c2f2fe62ca5c99"><td class="memItemLeft" align="right" valign="top"><a id="a7612c53942a7bee031c2f2fe62ca5c99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_8</b> (word z[], const word p[8], word p_dash, word ws[])</td></tr>
<tr class="separator:a7612c53942a7bee031c2f2fe62ca5c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f31b35e75693e061e8399d1e94648f"><td class="memItemLeft" align="right" valign="top"><a id="a38f31b35e75693e061e8399d1e94648f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_16</b> (word z[], const word p[16], word p_dash, word ws[])</td></tr>
<tr class="separator:a38f31b35e75693e061e8399d1e94648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeff3f2c79b113b4f00866b0536356b9"><td class="memItemLeft" align="right" valign="top"><a id="adeff3f2c79b113b4f00866b0536356b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_24</b> (word z[], const word p[24], word p_dash, word ws[])</td></tr>
<tr class="separator:adeff3f2c79b113b4f00866b0536356b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07891c2173ac4966800b2869a01e7572"><td class="memItemLeft" align="right" valign="top"><a id="a07891c2173ac4966800b2869a01e7572"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bigint_monty_redc_32</b> (word z[], const word p[32], word p_dash, word ws[])</td></tr>
<tr class="separator:a07891c2173ac4966800b2869a01e7572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866ab55bde5fea42a0925fa9fd461e8e"><td class="memItemLeft" align="right" valign="top"><a id="a866ab55bde5fea42a0925fa9fd461e8e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>generate_dsa_primes</b> (RandomNumberGenerator &amp;rng, BigInt &amp;p, BigInt &amp;q, size_t pbits, size_t qbits, const std::vector&lt; uint8_t &gt; &amp;seed_c, size_t offset)</td></tr>
<tr class="separator:a866ab55bde5fea42a0925fa9fd461e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8423b7454f670cd52ca9f0ab2f31db4a"><td class="memItemLeft" align="right" valign="top"><a id="a8423b7454f670cd52ca9f0ab2f31db4a"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generate_dsa_primes</b> (RandomNumberGenerator &amp;rng, BigInt &amp;p, BigInt &amp;q, size_t pbits, size_t qbits)</td></tr>
<tr class="separator:a8423b7454f670cd52ca9f0ab2f31db4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70a33bf1947a3243c80bffdc307fa19"><td class="memItemLeft" align="right" valign="top"><a id="ad70a33bf1947a3243c80bffdc307fa19"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>jacobi</b> (const BigInt &amp;a, const BigInt &amp;n)</td></tr>
<tr class="separator:ad70a33bf1947a3243c80bffdc307fa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2573e701a37658306ac0a4badc7b4d92"><td class="memItemLeft" align="right" valign="top"><a id="a2573e701a37658306ac0a4badc7b4d92"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>random_prime</b> (RandomNumberGenerator &amp;rng, size_t bits, const BigInt &amp;coprime, size_t equiv, size_t modulo, size_t prob)</td></tr>
<tr class="separator:a2573e701a37658306ac0a4badc7b4d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d66d8763a90430722520436620b33e"><td class="memItemLeft" align="right" valign="top"><a id="aa6d66d8763a90430722520436620b33e"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>generate_rsa_prime</b> (RandomNumberGenerator &amp;keygen_rng, RandomNumberGenerator &amp;prime_test_rng, size_t bits, const BigInt &amp;coprime, size_t prob)</td></tr>
<tr class="separator:aa6d66d8763a90430722520436620b33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:added9e0a54d2f373c513e50d7b16db63"><td class="memItemLeft" align="right" valign="top"><a id="added9e0a54d2f373c513e50d7b16db63"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>random_safe_prime</b> (RandomNumberGenerator &amp;rng, size_t bits)</td></tr>
<tr class="separator:added9e0a54d2f373c513e50d7b16db63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98120f4969f801e88531188c48b70574"><td class="memItemLeft" align="right" valign="top"><a id="a98120f4969f801e88531188c48b70574"></a>
std::shared_ptr&lt; const <a class="el" href="class_botan_1_1_montgomery___exponentation___state.html">Montgomery_Exponentation_State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>monty_precompute</b> (std::shared_ptr&lt; const <a class="el" href="class_botan_1_1_montgomery___params.html">Montgomery_Params</a> &gt; params, const BigInt &amp;g, size_t window_bits, bool const_time)</td></tr>
<tr class="separator:a98120f4969f801e88531188c48b70574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76236caf2041748af588f6354babd7e"><td class="memItemLeft" align="right" valign="top"><a id="ae76236caf2041748af588f6354babd7e"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>monty_execute</b> (const <a class="el" href="class_botan_1_1_montgomery___exponentation___state.html">Montgomery_Exponentation_State</a> &amp;precomputed_state, const BigInt &amp;k, size_t max_k_bits)</td></tr>
<tr class="separator:ae76236caf2041748af588f6354babd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd57171ed4f053774dd31d8c25b7f115"><td class="memItemLeft" align="right" valign="top"><a id="acd57171ed4f053774dd31d8c25b7f115"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>monty_execute_vartime</b> (const <a class="el" href="class_botan_1_1_montgomery___exponentation___state.html">Montgomery_Exponentation_State</a> &amp;precomputed_state, const BigInt &amp;k)</td></tr>
<tr class="separator:acd57171ed4f053774dd31d8c25b7f115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569119add8b600e92227182777726fb1"><td class="memItemLeft" align="right" valign="top">BigInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a569119add8b600e92227182777726fb1">monty_multi_exp</a> (std::shared_ptr&lt; const <a class="el" href="class_botan_1_1_montgomery___params.html">Montgomery_Params</a> &gt; params_p, const BigInt &amp;x_bn, const BigInt &amp;z1, const BigInt &amp;y_bn, const BigInt &amp;z2)</td></tr>
<tr class="separator:a569119add8b600e92227182777726fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e24e3959f79ce73964bea77ae6e3fa3"><td class="memItemLeft" align="right" valign="top"><a id="a3e24e3959f79ce73964bea77ae6e3fa3"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>square</b> (const BigInt &amp;x)</td></tr>
<tr class="separator:a3e24e3959f79ce73964bea77ae6e3fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af255ffd065161f14569ceedfc2df37a1"><td class="memItemLeft" align="right" valign="top"><a id="af255ffd065161f14569ceedfc2df37a1"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>mul_add</b> (const BigInt &amp;a, const BigInt &amp;b, const BigInt &amp;c)</td></tr>
<tr class="separator:af255ffd065161f14569ceedfc2df37a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30e7f34834b72d78333fb2c907218d7"><td class="memItemLeft" align="right" valign="top"><a id="ad30e7f34834b72d78333fb2c907218d7"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>sub_mul</b> (const BigInt &amp;a, const BigInt &amp;b, const BigInt &amp;c)</td></tr>
<tr class="separator:ad30e7f34834b72d78333fb2c907218d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4827349925501c035bc218b9c5de57"><td class="memItemLeft" align="right" valign="top"><a id="aaa4827349925501c035bc218b9c5de57"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>mul_sub</b> (const BigInt &amp;a, const BigInt &amp;b, const BigInt &amp;c)</td></tr>
<tr class="separator:aaa4827349925501c035bc218b9c5de57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0af50947a9b3e2d43f7edea7b0f12"><td class="memItemLeft" align="right" valign="top"><a id="ac0e0af50947a9b3e2d43f7edea7b0f12"></a>
const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>prime_p521</b> ()</td></tr>
<tr class="separator:ac0e0af50947a9b3e2d43f7edea7b0f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a980d7c9136ea8eb15d775bc907fe0"><td class="memItemLeft" align="right" valign="top"><a id="a08a980d7c9136ea8eb15d775bc907fe0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>redc_p521</b> (BigInt &amp;x, secure_vector&lt; word &gt; &amp;ws)</td></tr>
<tr class="separator:a08a980d7c9136ea8eb15d775bc907fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ab48f5e53973460726471b57bf1742"><td class="memItemLeft" align="right" valign="top"><a id="a43ab48f5e53973460726471b57bf1742"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>low_zero_bits</b> (const BigInt &amp;n)</td></tr>
<tr class="separator:a43ab48f5e53973460726471b57bf1742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a7ea8e61510d23d2eab11dd88c0e24"><td class="memItemLeft" align="right" valign="top"><a id="ab3a7ea8e61510d23d2eab11dd88c0e24"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>gcd</b> (const BigInt &amp;a, const BigInt &amp;b)</td></tr>
<tr class="separator:ab3a7ea8e61510d23d2eab11dd88c0e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3440b6ae2e3737516760560a668e200d"><td class="memItemLeft" align="right" valign="top"><a id="a3440b6ae2e3737516760560a668e200d"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>lcm</b> (const BigInt &amp;a, const BigInt &amp;b)</td></tr>
<tr class="separator:a3440b6ae2e3737516760560a668e200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae560deeabf1e0fd634a150b90f0bfaf2"><td class="memItemLeft" align="right" valign="top"><a id="ae560deeabf1e0fd634a150b90f0bfaf2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>almost_montgomery_inverse</b> (BigInt &amp;result, const BigInt &amp;a, const BigInt &amp;p)</td></tr>
<tr class="separator:ae560deeabf1e0fd634a150b90f0bfaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72ef3fd852fc2235bb873a1b107316c"><td class="memItemLeft" align="right" valign="top"><a id="ac72ef3fd852fc2235bb873a1b107316c"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>normalized_montgomery_inverse</b> (const BigInt &amp;a, const BigInt &amp;p)</td></tr>
<tr class="separator:ac72ef3fd852fc2235bb873a1b107316c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eab400e6f4197af47cd7916177182a7"><td class="memItemLeft" align="right" valign="top"><a id="a9eab400e6f4197af47cd7916177182a7"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>ct_inverse_mod_odd_modulus</b> (const BigInt &amp;n, const BigInt &amp;mod)</td></tr>
<tr class="separator:a9eab400e6f4197af47cd7916177182a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b73405806a0c8078b7f06aa7eea9bc"><td class="memItemLeft" align="right" valign="top"><a id="ae4b73405806a0c8078b7f06aa7eea9bc"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>inverse_mod</b> (const BigInt &amp;n, const BigInt &amp;mod)</td></tr>
<tr class="separator:ae4b73405806a0c8078b7f06aa7eea9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f4bf762f257c84ecec1ab8fd9fcf8e"><td class="memItemLeft" align="right" valign="top"><a id="a01f4bf762f257c84ecec1ab8fd9fcf8e"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>inverse_euclid</b> (const BigInt &amp;n, const BigInt &amp;mod)</td></tr>
<tr class="separator:a01f4bf762f257c84ecec1ab8fd9fcf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa737eba328adb36d77da6af925bbbc9"><td class="memItemLeft" align="right" valign="top"><a id="afa737eba328adb36d77da6af925bbbc9"></a>
word&#160;</td><td class="memItemRight" valign="bottom"><b>monty_inverse</b> (word input)</td></tr>
<tr class="separator:afa737eba328adb36d77da6af925bbbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6591d0e9bc0c4c75c46032fe3aa048"><td class="memItemLeft" align="right" valign="top"><a id="a0d6591d0e9bc0c4c75c46032fe3aa048"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>power_mod</b> (const BigInt &amp;base, const BigInt &amp;exp, const BigInt &amp;mod)</td></tr>
<tr class="separator:a0d6591d0e9bc0c4c75c46032fe3aa048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cad18832eb12cc47d3adf4d3767b79"><td class="memItemLeft" align="right" valign="top"><a id="ac8cad18832eb12cc47d3adf4d3767b79"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>is_perfect_square</b> (const BigInt &amp;C)</td></tr>
<tr class="separator:ac8cad18832eb12cc47d3adf4d3767b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aedffce7573b1c1a8c747c4fc1d52a9"><td class="memItemLeft" align="right" valign="top"><a id="a6aedffce7573b1c1a8c747c4fc1d52a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_prime</b> (const BigInt &amp;n, RandomNumberGenerator &amp;rng, size_t prob, bool is_random)</td></tr>
<tr class="separator:a6aedffce7573b1c1a8c747c4fc1d52a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481ae8e7fe0268600101ab74663f3f16"><td class="memItemLeft" align="right" valign="top">BigInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a481ae8e7fe0268600101ab74663f3f16">abs</a> (const BigInt &amp;n)</td></tr>
<tr class="separator:a481ae8e7fe0268600101ab74663f3f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f25b10ed41d28e8a0f7026b35b96838"><td class="memItemLeft" align="right" valign="top">BigInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a0f25b10ed41d28e8a0f7026b35b96838">BOTAN_PUBLIC_API</a> (2, 5) inverse_euclid(const BigInt &amp;x</td></tr>
<tr class="separator:a0f25b10ed41d28e8a0f7026b35b96838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84349165e2e06442d77db64cdb76bfee"><td class="memItemLeft" align="right" valign="top"><a id="a84349165e2e06442d77db64cdb76bfee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>quick_check_prime</b> (const BigInt &amp;n, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:a84349165e2e06442d77db64cdb76bfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f2e869065b1860fa41959f72ce6dd8"><td class="memItemLeft" align="right" valign="top"><a id="af6f2e869065b1860fa41959f72ce6dd8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_prime</b> (const BigInt &amp;n, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:af6f2e869065b1860fa41959f72ce6dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafcd26fc5a710d6c4656e1201d4d1be"><td class="memItemLeft" align="right" valign="top"><a id="aaafcd26fc5a710d6c4656e1201d4d1be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>verify_prime</b> (const BigInt &amp;n, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:aaafcd26fc5a710d6c4656e1201d4d1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa47db9abf09a2846078163792d949c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#adfa47db9abf09a2846078163792d949c">is_lucas_probable_prime</a> (const BigInt &amp;C, const Modular_Reducer &amp;mod_C)</td></tr>
<tr class="separator:adfa47db9abf09a2846078163792d949c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa000b3df41820d97dbeef2594dd82843"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aa000b3df41820d97dbeef2594dd82843">is_bailie_psw_probable_prime</a> (const BigInt &amp;n, const Modular_Reducer &amp;mod_n)</td></tr>
<tr class="separator:aa000b3df41820d97dbeef2594dd82843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3972bbdb57116e08e72c3559d8db5bf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a3972bbdb57116e08e72c3559d8db5bf2">is_bailie_psw_probable_prime</a> (const BigInt &amp;n)</td></tr>
<tr class="separator:a3972bbdb57116e08e72c3559d8db5bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fa2ef88c6068dab54c14e9b5571b51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a72fa2ef88c6068dab54c14e9b5571b51">passes_miller_rabin_test</a> (const BigInt &amp;n, const Modular_Reducer &amp;mod_n, const std::shared_ptr&lt; <a class="el" href="class_botan_1_1_montgomery___params.html">Montgomery_Params</a> &gt; &amp;monty_n, const BigInt &amp;a)</td></tr>
<tr class="separator:a72fa2ef88c6068dab54c14e9b5571b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e0f4d2a60382f64d3bc66e5643d1b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a83e0f4d2a60382f64d3bc66e5643d1b3">is_miller_rabin_probable_prime</a> (const BigInt &amp;n, const Modular_Reducer &amp;mod_n, RandomNumberGenerator &amp;rng, size_t test_iterations)</td></tr>
<tr class="separator:a83e0f4d2a60382f64d3bc66e5643d1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d5621df44479136319b391ff899802"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ad2d5621df44479136319b391ff899802">miller_rabin_test_iterations</a> (size_t n_bits, size_t prob, bool random)</td></tr>
<tr class="separator:ad2d5621df44479136319b391ff899802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ae5649eb61c01dc8f824e97ab386fd"><td class="memItemLeft" align="right" valign="top"><a id="a11ae5649eb61c01dc8f824e97ab386fd"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>ressol</b> (const BigInt &amp;a, const BigInt &amp;p)</td></tr>
<tr class="separator:a11ae5649eb61c01dc8f824e97ab386fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746811da38c5d4ffb4d4d8a4016fbf3b"><td class="memItemLeft" align="right" valign="top"><a id="a746811da38c5d4ffb4d4d8a4016fbf3b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>aont_package</b> (RandomNumberGenerator &amp;rng, BlockCipher *cipher, const uint8_t input[], size_t input_len, uint8_t output[])</td></tr>
<tr class="separator:a746811da38c5d4ffb4d4d8a4016fbf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffab170cbbe7958e0999119feccf542"><td class="memItemLeft" align="right" valign="top"><a id="adffab170cbbe7958e0999119feccf542"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>aont_unpackage</b> (BlockCipher *cipher, const uint8_t input[], size_t input_len, uint8_t output[])</td></tr>
<tr class="separator:adffab170cbbe7958e0999119feccf542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af945fa6198fa0d818e398c3e50303ddf"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#af945fa6198fa0d818e398c3e50303ddf">BOTAN_PUBLIC_API</a> (2, 2) HOTP final</td></tr>
<tr class="separator:af945fa6198fa0d818e398c3e50303ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd375cd98986aa257173c5023d6f361"><td class="memItemLeft" align="right" valign="top"><a id="aabd375cd98986aa257173c5023d6f361"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nist_key_wrap</b> (const uint8_t input[], size_t input_len, const BlockCipher &amp;bc)</td></tr>
<tr class="separator:aabd375cd98986aa257173c5023d6f361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa193a41f7a5a433af6648e05412d7927"><td class="memItemLeft" align="right" valign="top"><a id="aa193a41f7a5a433af6648e05412d7927"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nist_key_unwrap</b> (const uint8_t input[], size_t input_len, const BlockCipher &amp;bc)</td></tr>
<tr class="separator:aa193a41f7a5a433af6648e05412d7927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bae35f87ea07faaaf2375a8dfd96958"><td class="memItemLeft" align="right" valign="top"><a id="a5bae35f87ea07faaaf2375a8dfd96958"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nist_key_wrap_padded</b> (const uint8_t input[], size_t input_len, const BlockCipher &amp;bc)</td></tr>
<tr class="separator:a5bae35f87ea07faaaf2375a8dfd96958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6058b9d2ad2f93bddfb99ed6e6d6c7e"><td class="memItemLeft" align="right" valign="top"><a id="af6058b9d2ad2f93bddfb99ed6e6d6c7e"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nist_key_unwrap_padded</b> (const uint8_t input[], size_t input_len, const BlockCipher &amp;bc)</td></tr>
<tr class="separator:af6058b9d2ad2f93bddfb99ed6e6d6c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9093b300739b9305dcddeef2fdabd4f"><td class="memItemLeft" align="right" valign="top"><a id="ad9093b300739b9305dcddeef2fdabd4f"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rfc3394_keywrap</b> (const secure_vector&lt; uint8_t &gt; &amp;key, const <a class="el" href="namespace_botan.html#a89cf6c3513428f524454d01830221a88">SymmetricKey</a> &amp;kek)</td></tr>
<tr class="separator:ad9093b300739b9305dcddeef2fdabd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd37554903b2d7dc23b582e866b7b44"><td class="memItemLeft" align="right" valign="top"><a id="afbd37554903b2d7dc23b582e866b7b44"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rfc3394_keyunwrap</b> (const secure_vector&lt; uint8_t &gt; &amp;key, const <a class="el" href="namespace_botan.html#a89cf6c3513428f524454d01830221a88">SymmetricKey</a> &amp;kek)</td></tr>
<tr class="separator:afbd37554903b2d7dc23b582e866b7b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bd21cfb41d35b060ae22dfbc366c22"><td class="memItemLeft" align="right" valign="top"><a id="a93bd21cfb41d35b060ae22dfbc366c22"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>srp6_group_identifier</b> (const BigInt &amp;N, const BigInt &amp;g)</td></tr>
<tr class="separator:a93bd21cfb41d35b060ae22dfbc366c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b9d9cc8d0b378865bcc049a88b7a78"><td class="memItemLeft" align="right" valign="top"><a id="a23b9d9cc8d0b378865bcc049a88b7a78"></a>
std::pair&lt; BigInt, <a class="el" href="namespace_botan.html#a89cf6c3513428f524454d01830221a88">SymmetricKey</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>srp6_client_agree</b> (const std::string &amp;identifier, const std::string &amp;password, const std::string &amp;group_id, const std::string &amp;hash_id, const std::vector&lt; uint8_t &gt; &amp;salt, const BigInt &amp;B, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:a23b9d9cc8d0b378865bcc049a88b7a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1967cc8d60add19e44753e8d74c8667e"><td class="memItemLeft" align="right" valign="top"><a id="a1967cc8d60add19e44753e8d74c8667e"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>generate_srp6_verifier</b> (const std::string &amp;identifier, const std::string &amp;password, const std::vector&lt; uint8_t &gt; &amp;salt, const std::string &amp;group_id, const std::string &amp;hash_id)</td></tr>
<tr class="separator:a1967cc8d60add19e44753e8d74c8667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22646ab3e050b0bf8f3ec55184c467c6"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) AEAD_Mode AEAD_Mode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a22646ab3e050b0bf8f3ec55184c467c6">get_aead</a> (const std::string &amp;name, <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> direction)</td></tr>
<tr class="separator:a22646ab3e050b0bf8f3ec55184c467c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaeb0902dcc750384b1b16719be1b39c"><td class="memItemLeft" align="right" valign="top"><a id="abaeb0902dcc750384b1b16719be1b39c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gcm_clmul_precompute</b> (const uint8_t H_bytes[16], uint64_t H_pow[4 *2])</td></tr>
<tr class="separator:abaeb0902dcc750384b1b16719be1b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa7355bae753bd73e73258f37d79a4c"><td class="memItemLeft" align="right" valign="top"><a id="acfa7355bae753bd73e73258f37d79a4c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gcm_multiply_clmul</b> (uint8_t x[16], const uint64_t H_pow[8], const uint8_t input_bytes[], size_t blocks)</td></tr>
<tr class="separator:acfa7355bae753bd73e73258f37d79a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf958ceb4e98635a1393e9bcfaaf458e"><td class="memItemLeft" align="right" valign="top"><a id="acf958ceb4e98635a1393e9bcfaaf458e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gcm_multiply_clmul</b> (uint8_t x[16], const uint64_t H_pow[4 *2], const uint8_t input[], size_t blocks)</td></tr>
<tr class="separator:acf958ceb4e98635a1393e9bcfaaf458e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53f90378aaccb4b9608b467ee421cf8"><td class="memItemLeft" align="right" valign="top"><a id="ad53f90378aaccb4b9608b467ee421cf8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gcm_multiply_ssse3</b> (uint8_t x[16], const uint64_t HM[256], const uint8_t input_bytes[], size_t blocks)</td></tr>
<tr class="separator:ad53f90378aaccb4b9608b467ee421cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0687dab8892053b8b0dc6600a37a2d46"><td class="memItemLeft" align="right" valign="top"><a id="a0687dab8892053b8b0dc6600a37a2d46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gcm_pmull_precompute</b> (const uint8_t H_bytes[16], uint64_t H_pow[4 *2])</td></tr>
<tr class="separator:a0687dab8892053b8b0dc6600a37a2d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae014acaf562e66a1137bfb574fae275d"><td class="memItemLeft" align="right" valign="top"><a id="ae014acaf562e66a1137bfb574fae275d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gcm_multiply_pmull</b> (uint8_t x[16], const uint64_t H64[8], const uint8_t input[], size_t blocks)</td></tr>
<tr class="separator:ae014acaf562e66a1137bfb574fae275d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9074784e382345388cdeb6db3e69c823"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) Cipher_Mode Cipher_Mode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a9074784e382345388cdeb6db3e69c823">get_cipher_mode</a> (const std::string &amp;algo_spec, <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> direction, const std::string &amp;provider=&quot;&quot;)</td></tr>
<tr class="separator:a9074784e382345388cdeb6db3e69c823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22e1d5609dbde74a5f45f729f4c4c6a"><td class="memItemLeft" align="right" valign="top">BlockCipherModePaddingMethod *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ac22e1d5609dbde74a5f45f729f4c4c6a">get_bc_pad</a> (const std::string &amp;algo_spec)</td></tr>
<tr class="separator:ac22e1d5609dbde74a5f45f729f4c4c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cb36777eb93bb3b2ee508a712cf116"><td class="memItemLeft" align="right" valign="top"><a id="a49cb36777eb93bb3b2ee508a712cf116"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>generate_bcrypt</b> (const std::string &amp;pass, RandomNumberGenerator &amp;rng, uint16_t work_factor, char version)</td></tr>
<tr class="separator:a49cb36777eb93bb3b2ee508a712cf116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970c31b2eaaeec4fb9262eeabf0e37a1"><td class="memItemLeft" align="right" valign="top"><a id="a970c31b2eaaeec4fb9262eeabf0e37a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_bcrypt</b> (const std::string &amp;pass, const std::string &amp;hash)</td></tr>
<tr class="separator:a970c31b2eaaeec4fb9262eeabf0e37a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dbec5bc18c846714aac5fe71708388"><td class="memItemLeft" align="right" valign="top"><a id="ad3dbec5bc18c846714aac5fe71708388"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>generate_passhash9</b> (const std::string &amp;pass, RandomNumberGenerator &amp;rng, uint16_t work_factor, uint8_t alg_id)</td></tr>
<tr class="separator:ad3dbec5bc18c846714aac5fe71708388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9082402c1ec67dfa5dfcf73261814058"><td class="memItemLeft" align="right" valign="top"><a id="a9082402c1ec67dfa5dfcf73261814058"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_passhash9</b> (const std::string &amp;pass, const std::string &amp;hash)</td></tr>
<tr class="separator:a9082402c1ec67dfa5dfcf73261814058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9014e15d2214508d6508f31f4e697b78"><td class="memItemLeft" align="right" valign="top"><a id="a9014e15d2214508d6508f31f4e697b78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_passhash9_alg_supported</b> (uint8_t alg_id)</td></tr>
<tr class="separator:a9014e15d2214508d6508f31f4e697b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae2ea6a22f08742864267f1a2a7a91c"><td class="memItemLeft" align="right" valign="top">std::string BOTAN_PUBLIC_API(2, 0) generate_passhash9(const std bool BOTAN_PUBLIC_API(2, 0) check_passhash9(const std bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a3ae2ea6a22f08742864267f1a2a7a91c">BOTAN_PUBLIC_API</a> (2, 3) is_passhash9_alg_supported(uint8_t alg_id)</td></tr>
<tr class="separator:a3ae2ea6a22f08742864267f1a2a7a91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053bdfc377dda32b5d3c116e19c9d394"><td class="memItemLeft" align="right" valign="top">PBKDF *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a053bdfc377dda32b5d3c116e19c9d394">get_pbkdf</a> (const std::string &amp;algo_spec, const std::string &amp;provider=&quot;&quot;)</td></tr>
<tr class="separator:a053bdfc377dda32b5d3c116e19c9d394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5612cc6316fbfb5d5a5b100c9cf7064e"><td class="memItemLeft" align="right" valign="top"><a id="a5612cc6316fbfb5d5a5b100c9cf7064e"></a>
PBKDF *&#160;</td><td class="memItemRight" valign="bottom"><b>get_s2k</b> (const std::string &amp;algo_spec)</td></tr>
<tr class="separator:a5612cc6316fbfb5d5a5b100c9cf7064e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f528f347ada25931bc355672b427b5b"><td class="memItemLeft" align="right" valign="top"><a id="a7f528f347ada25931bc355672b427b5b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>pbkdf2</b> (MessageAuthenticationCode &amp;prf, uint8_t out[], size_t out_len, const std::string &amp;password, const uint8_t salt[], size_t salt_len, size_t iterations, std::chrono::milliseconds msec)</td></tr>
<tr class="separator:a7f528f347ada25931bc355672b427b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dcd18a2948fc87b0f1811dff14f627"><td class="memItemLeft" align="right" valign="top"><a id="a63dcd18a2948fc87b0f1811dff14f627"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pbkdf2</b> (MessageAuthenticationCode &amp;prf, uint8_t out[], size_t out_len, const uint8_t salt[], size_t salt_len, size_t iterations)</td></tr>
<tr class="separator:a63dcd18a2948fc87b0f1811dff14f627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548b8da3169fa2bde2617477d7827f30"><td class="memItemLeft" align="right" valign="top"><a id="a548b8da3169fa2bde2617477d7827f30"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>RFC4880_encode_count</b> (size_t desired_iterations)</td></tr>
<tr class="separator:a548b8da3169fa2bde2617477d7827f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dabb8ac0ebdcad5ce8d7da372ccb0be"><td class="memItemLeft" align="right" valign="top"><a id="a8dabb8ac0ebdcad5ce8d7da372ccb0be"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>RFC4880_decode_count</b> (uint8_t iter)</td></tr>
<tr class="separator:a8dabb8ac0ebdcad5ce8d7da372ccb0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7349411411e52a65630e3e607ed504"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ace7349411411e52a65630e3e607ed504">BOTAN_PUBLIC_API</a> (2, 8) RFC4880_encode_count(size_t iterations)</td></tr>
<tr class="separator:ace7349411411e52a65630e3e607ed504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdcf273bc754092e425287b1cf05208"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aebdcf273bc754092e425287b1cf05208">RFC4880_round_iterations</a> (size_t iterations)</td></tr>
<tr class="separator:aebdcf273bc754092e425287b1cf05208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e95bbc38635f4f5ab0be6c88797eb56"><td class="memItemLeft" align="right" valign="top"><a id="a5e95bbc38635f4f5ab0be6c88797eb56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scrypt</b> (uint8_t output[], size_t output_len, const char *password, size_t password_len, const uint8_t salt[], size_t salt_len, size_t N, size_t r, size_t p)</td></tr>
<tr class="separator:a5e95bbc38635f4f5ab0be6c88797eb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b6ad71a73156fb774a71db9e99eb5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ae1b6ad71a73156fb774a71db9e99eb5a">scrypt</a> (uint8_t output[], size_t output_len, const std::string &amp;password, const uint8_t salt[], size_t salt_len, size_t N, size_t r, size_t p)</td></tr>
<tr class="separator:ae1b6ad71a73156fb774a71db9e99eb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c00a4b36c5eb825bbb255f4c3a1ad8f"><td class="memItemLeft" align="right" valign="top"><a id="a5c00a4b36c5eb825bbb255f4c3a1ad8f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>scrypt_memory_usage</b> (size_t N, size_t r, size_t p)</td></tr>
<tr class="separator:a5c00a4b36c5eb825bbb255f4c3a1ad8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be9e702614ad3e7041e11bcfe58ca35"><td class="memItemLeft" align="right" valign="top"><a id="a2be9e702614ad3e7041e11bcfe58ca35"></a>
EME *&#160;</td><td class="memItemRight" valign="bottom"><b>get_eme</b> (const std::string &amp;algo_spec)</td></tr>
<tr class="separator:a2be9e702614ad3e7041e11bcfe58ca35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3778103665c2cb22e4f311002755cd53"><td class="memItemLeft" align="right" valign="top">secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a3778103665c2cb22e4f311002755cd53">oaep_find_delim</a> (uint8_t &amp;valid_mask, const uint8_t input[], size_t input_len, const secure_vector&lt; uint8_t &gt; &amp;Phash)</td></tr>
<tr class="separator:a3778103665c2cb22e4f311002755cd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac97b092d7b217da05528ac462e5622"><td class="memItemLeft" align="right" valign="top"><a id="a4ac97b092d7b217da05528ac462e5622"></a>
EMSA *&#160;</td><td class="memItemRight" valign="bottom"><b>get_emsa</b> (const std::string &amp;algo_spec)</td></tr>
<tr class="separator:a4ac97b092d7b217da05528ac462e5622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312997431c545c396ff37598d7788fe0"><td class="memItemLeft" align="right" valign="top"><a id="a312997431c545c396ff37598d7788fe0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>hash_for_emsa</b> (const std::string &amp;algo_spec)</td></tr>
<tr class="separator:a312997431c545c396ff37598d7788fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8823bb54b388389f618f9ae896d38992"><td class="memItemLeft" align="right" valign="top"><a id="a8823bb54b388389f618f9ae896d38992"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pkcs_hash_id</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a8823bb54b388389f618f9ae896d38992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4be2d703e9ade53826bc2ab6c899f4d"><td class="memItemLeft" align="right" valign="top"><a id="af4be2d703e9ade53826bc2ab6c899f4d"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>ieee1363_hash_id</b> (const std::string &amp;name)</td></tr>
<tr class="separator:af4be2d703e9ade53826bc2ab6c899f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b321657543140cf44d468926021790"><td class="memItemLeft" align="right" valign="top"><a id="a00b321657543140cf44d468926021790"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mgf1_mask</b> (HashFunction &amp;hash, const uint8_t in[], size_t in_len, uint8_t out[], size_t out_len)</td></tr>
<tr class="separator:a00b321657543140cf44d468926021790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b05d4e236673d9d185cbfb1144cebc"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a68b05d4e236673d9d185cbfb1144cebc">get_sig_paddings</a> (const std::string algo)</td></tr>
<tr class="separator:a68b05d4e236673d9d185cbfb1144cebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2167ee9b593409c1ca300b1fbec0691"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ae2167ee9b593409c1ca300b1fbec0691">sig_algo_and_pad_ok</a> (const std::string algo, const std::string padding)</td></tr>
<tr class="separator:ae2167ee9b593409c1ca300b1fbec0691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af523a98284b3b7e6706dcfb5d7c97b45"><td class="memItemLeft" align="right" valign="top"><a id="af523a98284b3b7e6706dcfb5d7c97b45"></a>
std::unique_ptr&lt; HashFunction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_bearssl_hash</b> (const std::string &amp;name)</td></tr>
<tr class="separator:af523a98284b3b7e6706dcfb5d7c97b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4ac4b9f0330fe727238480ce1a41e0"><td class="memItemLeft" align="right" valign="top"><a id="a8e4ac4b9f0330fe727238480ce1a41e0"></a>
enum <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> int typedef int32_t CCCryptorStatus class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) CommonCrypto_Error final Cipher_Mode *&#160;</td><td class="memItemRight" valign="bottom"><b>make_commoncrypto_cipher_mode</b> (const std::string &amp;name, <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> direction)</td></tr>
<tr class="separator:a8e4ac4b9f0330fe727238480ce1a41e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ec83a4c566611f6d8e01920f322947"><td class="memItemLeft" align="right" valign="top"><a id="a61ec83a4c566611f6d8e01920f322947"></a>
std::unique_ptr&lt; BlockCipher &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_commoncrypto_block_cipher</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a61ec83a4c566611f6d8e01920f322947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23db8ff34063e064a19ae264b8c5c667"><td class="memItemLeft" align="right" valign="top"><a id="a23db8ff34063e064a19ae264b8c5c667"></a>
std::unique_ptr&lt; HashFunction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_commoncrypto_hash</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a23db8ff34063e064a19ae264b8c5c667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5942b9b209ae01153944ae8978c29393"><td class="memItemLeft" align="right" valign="top"><a id="a5942b9b209ae01153944ae8978c29393"></a>
<a class="el" href="struct_botan_1_1_common_cryptor___opts.html">CommonCryptor_Opts</a>&#160;</td><td class="memItemRight" valign="bottom"><b>commoncrypto_opts_from_algo</b> (const std::string &amp;algo)</td></tr>
<tr class="separator:a5942b9b209ae01153944ae8978c29393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15b87b0369fc942ac52560131898341"><td class="memItemLeft" align="right" valign="top"><a id="aa15b87b0369fc942ac52560131898341"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>commoncrypto_adjust_key_size</b> (const uint8_t key[], size_t length, const <a class="el" href="struct_botan_1_1_common_cryptor___opts.html">CommonCryptor_Opts</a> &amp;opts, secure_vector&lt; uint8_t &gt; &amp;full_key)</td></tr>
<tr class="separator:aa15b87b0369fc942ac52560131898341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f58d35329314c734a414c0dc8e8ba81"><td class="memItemLeft" align="right" valign="top"><a id="a3f58d35329314c734a414c0dc8e8ba81"></a>
enum <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> int class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) OpenSSL_Error final std::unique_ptr&lt; BlockCipher &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_openssl_block_cipher</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a3f58d35329314c734a414c0dc8e8ba81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e1222669c530a37f4862179980fc5e"><td class="memItemLeft" align="right" valign="top"><a id="a65e1222669c530a37f4862179980fc5e"></a>
Cipher_Mode *&#160;</td><td class="memItemRight" valign="bottom"><b>make_openssl_cipher_mode</b> (const std::string &amp;name, <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a> direction)</td></tr>
<tr class="separator:a65e1222669c530a37f4862179980fc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc79a98a16fa3d4ce049fd73df31b03"><td class="memItemLeft" align="right" valign="top"><a id="acfc79a98a16fa3d4ce049fd73df31b03"></a>
std::unique_ptr&lt; HashFunction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>make_openssl_hash</b> (const std::string &amp;name)</td></tr>
<tr class="separator:acfc79a98a16fa3d4ce049fd73df31b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0f09284076ff0d5db9e2820f81e6ba"><td class="memItemLeft" align="right" valign="top"><a id="a1e0f09284076ff0d5db9e2820f81e6ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CECPQ1_offer</b> (uint8_t send[CECPQ1_OFFER_BYTES], <a class="el" href="class_botan_1_1_c_e_c_p_q1__key.html">CECPQ1_key</a> *offer_key_output, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:a1e0f09284076ff0d5db9e2820f81e6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ffabdf78ac511782ecb0b12641bf24"><td class="memItemLeft" align="right" valign="top"><a id="ac7ffabdf78ac511782ecb0b12641bf24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CECPQ1_accept</b> (uint8_t shared_key[CECPQ1_SHARED_KEY_BYTES], uint8_t send[CECPQ1_ACCEPT_BYTES], const uint8_t received[CECPQ1_OFFER_BYTES], RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:ac7ffabdf78ac511782ecb0b12641bf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abb6e143b6dff32624c05dd6ef4a45a"><td class="memItemLeft" align="right" valign="top"><a id="a4abb6e143b6dff32624c05dd6ef4a45a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CECPQ1_finish</b> (uint8_t shared_key[CECPQ1_SHARED_KEY_BYTES], const <a class="el" href="class_botan_1_1_c_e_c_p_q1__key.html">CECPQ1_key</a> &amp;offer_key, const uint8_t received[CECPQ1_ACCEPT_BYTES])</td></tr>
<tr class="separator:a4abb6e143b6dff32624c05dd6ef4a45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ce071367a388e3ee45f4e6ae9df65c"><td class="memItemLeft" align="right" valign="top"><a id="ae6ce071367a388e3ee45f4e6ae9df65c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>curve25519_basepoint</b> (uint8_t mypublic[32], const uint8_t secret[32])</td></tr>
<tr class="separator:ae6ce071367a388e3ee45f4e6ae9df65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7babab84c98997eeecd402fb50d74b8b"><td class="memItemLeft" align="right" valign="top"><a id="a7babab84c98997eeecd402fb50d74b8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>curve25519_donna</b> (uint8_t *mypublic, const uint8_t *secret, const uint8_t *basepoint)</td></tr>
<tr class="separator:a7babab84c98997eeecd402fb50d74b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd2cd53144b9dd0eafcf6f8d0c5d3a1"><td class="memItemLeft" align="right" valign="top"><a id="a0dd2cd53144b9dd0eafcf6f8d0c5d3a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_botan_1_1_curve_g_fp.html">CurveGFp</a> &amp;lhs, const <a class="el" href="class_botan_1_1_curve_g_fp.html">CurveGFp</a> &amp;rhs)</td></tr>
<tr class="separator:a0dd2cd53144b9dd0eafcf6f8d0c5d3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0a0af0ddf73a8188e0773592b994db"><td class="memItemLeft" align="right" valign="top"><a id="a4d0a0af0ddf73a8188e0773592b994db"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const EC_Group &amp;lhs, const EC_Group &amp;rhs)</td></tr>
<tr class="separator:a4d0a0af0ddf73a8188e0773592b994db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c371fa5a447f50ee58bd9b3f127e1"><td class="memItemLeft" align="right" valign="top"><a id="a8f3c371fa5a447f50ee58bd9b3f127e1"></a>
PointGFp&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const BigInt &amp;scalar, const PointGFp &amp;point)</td></tr>
<tr class="separator:a8f3c371fa5a447f50ee58bd9b3f127e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cd2fb9f54c4ab5c16033767480ca43"><td class="memItemLeft" align="right" valign="top"><a id="a15cd2fb9f54c4ab5c16033767480ca43"></a>
PointGFp&#160;</td><td class="memItemRight" valign="bottom"><b>OS2ECP</b> (const uint8_t data[], size_t data_len, const <a class="el" href="class_botan_1_1_curve_g_fp.html">CurveGFp</a> &amp;curve)</td></tr>
<tr class="separator:a15cd2fb9f54c4ab5c16033767480ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa477faffd5421eda38e1760113cd52a5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; BigInt, BigInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aa477faffd5421eda38e1760113cd52a5">OS2ECP</a> (const uint8_t data[], size_t data_len, const BigInt &amp;curve_p, const BigInt &amp;curve_a, const BigInt &amp;curve_b)</td></tr>
<tr class="separator:aa477faffd5421eda38e1760113cd52a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92cb68537b7bb61311f7b214c6a01ca"><td class="memItemLeft" align="right" valign="top"><a id="ac92cb68537b7bb61311f7b214c6a01ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const PointGFp &amp;lhs, const PointGFp &amp;rhs)</td></tr>
<tr class="separator:ac92cb68537b7bb61311f7b214c6a01ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec2a919f0d3e9a53b081f3647ef0831"><td class="memItemLeft" align="right" valign="top"><a id="a3ec2a919f0d3e9a53b081f3647ef0831"></a>
PointGFp&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const PointGFp &amp;lhs)</td></tr>
<tr class="separator:a3ec2a919f0d3e9a53b081f3647ef0831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cb3ef72a835fa7742d7514a4aedab1"><td class="memItemLeft" align="right" valign="top"><a id="ac3cb3ef72a835fa7742d7514a4aedab1"></a>
PointGFp&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const PointGFp &amp;lhs, const PointGFp &amp;rhs)</td></tr>
<tr class="separator:ac3cb3ef72a835fa7742d7514a4aedab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e066f87e0618c623684de6276d71fe"><td class="memItemLeft" align="right" valign="top"><a id="aa7e066f87e0618c623684de6276d71fe"></a>
PointGFp&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const PointGFp &amp;lhs, const PointGFp &amp;rhs)</td></tr>
<tr class="separator:aa7e066f87e0618c623684de6276d71fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad833dc0e005704e4e640e7090b1d2753"><td class="memItemLeft" align="right" valign="top"><a id="ad833dc0e005704e4e640e7090b1d2753"></a>
PointGFp&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const PointGFp &amp;point, const BigInt &amp;scalar)</td></tr>
<tr class="separator:ad833dc0e005704e4e640e7090b1d2753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed298213506b23172a7cc53b1a84327f"><td class="memItemLeft" align="right" valign="top"><a id="aed298213506b23172a7cc53b1a84327f"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BOTAN_DEPRECATED</b> (&quot;Use PointGFp::encode&quot;) EC2OSP(const PointGFp &amp;point</td></tr>
<tr class="separator:aed298213506b23172a7cc53b1a84327f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7dfc89a9ffff38439f28d6d2e26121"><td class="memItemLeft" align="right" valign="top"><a id="a2f7dfc89a9ffff38439f28d6d2e26121"></a>
return&#160;</td><td class="memItemRight" valign="bottom"><b>secure_vector&lt; uint8_t &gt;</b> (enc.begin(), enc.end())</td></tr>
<tr class="separator:a2f7dfc89a9ffff38439f28d6d2e26121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d9540ebd0f083ea462cccfd0c095a4"><td class="memTemplParams" colspan="2"><a id="a05d9540ebd0f083ea462cccfd0c095a4"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a05d9540ebd0f083ea462cccfd0c095a4"><td class="memTemplItemLeft" align="right" valign="top">PointGFp&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OS2ECP</b> (const std::vector&lt; uint8_t, Alloc &gt; &amp;data, const <a class="el" href="class_botan_1_1_curve_g_fp.html">CurveGFp</a> &amp;curve)</td></tr>
<tr class="separator:a05d9540ebd0f083ea462cccfd0c095a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070abcff25ba10769893c5fd603084b2"><td class="memItemLeft" align="right" valign="top"><a id="a070abcff25ba10769893c5fd603084b2"></a>
PointGFp&#160;</td><td class="memItemRight" valign="bottom"><b>multi_exponentiate</b> (const PointGFp &amp;x, const BigInt &amp;z1, const PointGFp &amp;y, const BigInt &amp;z2)</td></tr>
<tr class="separator:a070abcff25ba10769893c5fd603084b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff752f8dbf6614ace0d74e981ab2d80"><td class="memItemLeft" align="right" valign="top"><a id="a9ff752f8dbf6614ace0d74e981ab2d80"></a>
<a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8">ECIES_Flags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (<a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8">ECIES_Flags</a> a, <a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8">ECIES_Flags</a> b)</td></tr>
<tr class="separator:a9ff752f8dbf6614ace0d74e981ab2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13be8f6b6160759047c0549b85055d43"><td class="memItemLeft" align="right" valign="top"><a id="a13be8f6b6160759047c0549b85055d43"></a>
<a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8">ECIES_Flags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (<a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8">ECIES_Flags</a> a, <a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8">ECIES_Flags</a> b)</td></tr>
<tr class="separator:a13be8f6b6160759047c0549b85055d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e320e332f0864eefe5c84e40abe7b0d"><td class="memItemLeft" align="right" valign="top"><a id="a5e320e332f0864eefe5c84e40abe7b0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ed25519_gen_keypair</b> (uint8_t *pk, uint8_t *sk, const uint8_t seed[32])</td></tr>
<tr class="separator:a5e320e332f0864eefe5c84e40abe7b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e36e9fdc130d658129a97dbd8a2730"><td class="memItemLeft" align="right" valign="top"><a id="ae0e36e9fdc130d658129a97dbd8a2730"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ed25519_sign</b> (uint8_t sig[64], const uint8_t *m, size_t mlen, const uint8_t *sk)</td></tr>
<tr class="separator:ae0e36e9fdc130d658129a97dbd8a2730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19da308b70ce780f2895275863fb84"><td class="memItemLeft" align="right" valign="top"><a id="a5a19da308b70ce780f2895275863fb84"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ed25519_verify</b> (const uint8_t *m, size_t mlen, const uint8_t sig[64], const uint8_t *pk)</td></tr>
<tr class="separator:a5a19da308b70ce780f2895275863fb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c04ff64a486db50cc6e3b72fd6329a"><td class="memItemLeft" align="right" valign="top"><a id="a06c04ff64a486db50cc6e3b72fd6329a"></a>
class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 2) Ed25519_PublicKey class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 2) Ed25519_PrivateKey final void&#160;</td><td class="memItemRight" valign="bottom"><b>ed25519_gen_keypair</b> (uint8_t pk[32], uint8_t sk[64], const uint8_t seed[32])</td></tr>
<tr class="separator:a06c04ff64a486db50cc6e3b72fd6329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f80dc55d276a7421eadfbf91c2bcb69"><td class="memItemLeft" align="right" valign="top"><a id="a4f80dc55d276a7421eadfbf91c2bcb69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ed25519_sign</b> (uint8_t sig[64], const uint8_t msg[], size_t msg_len, const uint8_t sk[64])</td></tr>
<tr class="separator:a4f80dc55d276a7421eadfbf91c2bcb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcfbdead133000fa479ef04954bda6d"><td class="memItemLeft" align="right" valign="top"><a id="adfcfbdead133000fa479ef04954bda6d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ed25519_verify</b> (const uint8_t msg[], size_t msg_len, const uint8_t sig[64], const uint8_t pk[32])</td></tr>
<tr class="separator:adfcfbdead133000fa479ef04954bda6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6c34106e10d22d332f6887d8c01437"><td class="memItemLeft" align="right" valign="top"><a id="adf6c34106e10d22d332f6887d8c01437"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_frombytes</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const uint8_t *b)</td></tr>
<tr class="separator:adf6c34106e10d22d332f6887d8c01437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab311fe985a4bdbbd8cc598e4dceb66e2"><td class="memItemLeft" align="right" valign="top"><a id="ab311fe985a4bdbbd8cc598e4dceb66e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_tobytes</b> (uint8_t *b, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x)</td></tr>
<tr class="separator:ab311fe985a4bdbbd8cc598e4dceb66e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a50926647b22ed63fd2dc1fb50d1897"><td class="memItemLeft" align="right" valign="top"><a id="a8a50926647b22ed63fd2dc1fb50d1897"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_copy</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;a, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;b)</td></tr>
<tr class="separator:a8a50926647b22ed63fd2dc1fb50d1897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fdb4ac19fb039b9a039b2285ceb23a"><td class="memItemLeft" align="right" valign="top"><a id="a26fdb4ac19fb039b9a039b2285ceb23a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fe_isnonzero</b> (const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x)</td></tr>
<tr class="separator:a26fdb4ac19fb039b9a039b2285ceb23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2e407abbc01bdb7b06079eec1dfd4a"><td class="memItemLeft" align="right" valign="top"><a id="a1b2e407abbc01bdb7b06079eec1dfd4a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fe_isnegative</b> (const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x)</td></tr>
<tr class="separator:a1b2e407abbc01bdb7b06079eec1dfd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbf1667ea700a9a596bc162beeb3159"><td class="memItemLeft" align="right" valign="top"><a id="a0fbf1667ea700a9a596bc162beeb3159"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_0</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x)</td></tr>
<tr class="separator:a0fbf1667ea700a9a596bc162beeb3159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b29e60f7d8520c75475e3335ee40dd0"><td class="memItemLeft" align="right" valign="top"><a id="a2b29e60f7d8520c75475e3335ee40dd0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_1</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x)</td></tr>
<tr class="separator:a2b29e60f7d8520c75475e3335ee40dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d17fe1ecae437aa72d7ea4f137b3fb"><td class="memItemLeft" align="right" valign="top"><a id="a96d17fe1ecae437aa72d7ea4f137b3fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_add</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;a, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;b)</td></tr>
<tr class="separator:a96d17fe1ecae437aa72d7ea4f137b3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28ac796a4df6e972e8cd6a980e9e4ad"><td class="memItemLeft" align="right" valign="top"><a id="ab28ac796a4df6e972e8cd6a980e9e4ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_sub</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;a, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;b)</td></tr>
<tr class="separator:ab28ac796a4df6e972e8cd6a980e9e4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617d3446623f8831158d2503c6a4ce06"><td class="memItemLeft" align="right" valign="top"><a id="a617d3446623f8831158d2503c6a4ce06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_neg</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;z)</td></tr>
<tr class="separator:a617d3446623f8831158d2503c6a4ce06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce1d20bf07c1e678958b5c74ef07ccd"><td class="memItemLeft" align="right" valign="top"><a id="a3ce1d20bf07c1e678958b5c74ef07ccd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_mul</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;a, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;b)</td></tr>
<tr class="separator:a3ce1d20bf07c1e678958b5c74ef07ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f88f9636fa47623645448d4d52c7e45"><td class="memItemLeft" align="right" valign="top"><a id="a3f88f9636fa47623645448d4d52c7e45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_sq</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;z)</td></tr>
<tr class="separator:a3f88f9636fa47623645448d4d52c7e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8306b19d159b043ca97a236eb5263403"><td class="memItemLeft" align="right" valign="top"><a id="a8306b19d159b043ca97a236eb5263403"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_sq_iter</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;z, size_t iter)</td></tr>
<tr class="separator:a8306b19d159b043ca97a236eb5263403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a667c0ba087b4f6b01e5c908d9beb8"><td class="memItemLeft" align="right" valign="top"><a id="a06a667c0ba087b4f6b01e5c908d9beb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_sq2</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;z)</td></tr>
<tr class="separator:a06a667c0ba087b4f6b01e5c908d9beb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75997d63a88e4646109b76c948a5ce2"><td class="memItemLeft" align="right" valign="top"><a id="ad75997d63a88e4646109b76c948a5ce2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_invert</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;z)</td></tr>
<tr class="separator:ad75997d63a88e4646109b76c948a5ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab850de8e122c98669376fcb23f03c594"><td class="memItemLeft" align="right" valign="top"><a id="ab850de8e122c98669376fcb23f03c594"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fe_pow22523</b> (<a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;x, const <a class="el" href="class_botan_1_1_f_e__25519.html">fe</a> &amp;y)</td></tr>
<tr class="separator:ab850de8e122c98669376fcb23f03c594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63dda6bed09a4ae4de38ecbcae27522"><td class="memItemLeft" align="right" valign="top"><a id="af63dda6bed09a4ae4de38ecbcae27522"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>load_3</b> (const uint8_t in[3])</td></tr>
<tr class="separator:af63dda6bed09a4ae4de38ecbcae27522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb0aec76fd135ec65af8cd598208211"><td class="memItemLeft" align="right" valign="top"><a id="a2eb0aec76fd135ec65af8cd598208211"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>load_4</b> (const uint8_t *in)</td></tr>
<tr class="separator:a2eb0aec76fd135ec65af8cd598208211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa2a8e6f1bb4378f2923d52e4987d15"><td class="memTemplParams" colspan="2"><a id="a6aa2a8e6f1bb4378f2923d52e4987d15"></a>
template&lt;size_t S, int64_t MUL = 1&gt; </td></tr>
<tr class="memitem:a6aa2a8e6f1bb4378f2923d52e4987d15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>carry</b> (int64_t &amp;h0, int64_t &amp;h1)</td></tr>
<tr class="separator:a6aa2a8e6f1bb4378f2923d52e4987d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aaf0806b92cd052849c1b5d9e0c817"><td class="memTemplParams" colspan="2"><a id="a31aaf0806b92cd052849c1b5d9e0c817"></a>
template&lt;size_t S&gt; </td></tr>
<tr class="memitem:a31aaf0806b92cd052849c1b5d9e0c817"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>carry0</b> (int64_t &amp;h0, int64_t &amp;h1)</td></tr>
<tr class="separator:a31aaf0806b92cd052849c1b5d9e0c817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264a33bae1766f6ca4cb6625fe85e051"><td class="memTemplParams" colspan="2"><a id="a264a33bae1766f6ca4cb6625fe85e051"></a>
template&lt;size_t S&gt; </td></tr>
<tr class="memitem:a264a33bae1766f6ca4cb6625fe85e051"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>carry0</b> (int32_t &amp;h0, int32_t &amp;h1)</td></tr>
<tr class="separator:a264a33bae1766f6ca4cb6625fe85e051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa6d45cedbb7555da6110278b7e1a67"><td class="memItemLeft" align="right" valign="top"><a id="a1fa6d45cedbb7555da6110278b7e1a67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>redc_mul</b> (int64_t &amp;s1, int64_t &amp;s2, int64_t &amp;s3, int64_t &amp;s4, int64_t &amp;s5, int64_t &amp;s6, int64_t &amp;X)</td></tr>
<tr class="separator:a1fa6d45cedbb7555da6110278b7e1a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de961f09f7d26e343a2941f4a2730e9"><td class="memItemLeft" align="right" valign="top"><a id="a9de961f09f7d26e343a2941f4a2730e9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ge_frombytes_negate_vartime</b> (<a class="el" href="struct_botan_1_1ge__p3.html">ge_p3</a> *, const uint8_t *)</td></tr>
<tr class="separator:a9de961f09f7d26e343a2941f4a2730e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a7fb99e87bb1169999adf1a522a90e"><td class="memItemLeft" align="right" valign="top"><a id="a78a7fb99e87bb1169999adf1a522a90e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ge_scalarmult_base</b> (uint8_t out[32], const uint8_t in[32])</td></tr>
<tr class="separator:a78a7fb99e87bb1169999adf1a522a90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af899be8efb17c6b77d3107e185a26600"><td class="memItemLeft" align="right" valign="top"><a id="af899be8efb17c6b77d3107e185a26600"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ge_double_scalarmult_vartime</b> (uint8_t out[32], const uint8_t a[], const <a class="el" href="struct_botan_1_1ge__p3.html">ge_p3</a> *A, const uint8_t b[])</td></tr>
<tr class="separator:af899be8efb17c6b77d3107e185a26600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fc375792120b2cae2b0b58ec000f2e"><td class="memItemLeft" align="right" valign="top"><a id="af4fc375792120b2cae2b0b58ec000f2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sc_reduce</b> (uint8_t *)</td></tr>
<tr class="separator:af4fc375792120b2cae2b0b58ec000f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf5fb74f75f8e8a672618c5778882d8"><td class="memItemLeft" align="right" valign="top"><a id="afbf5fb74f75f8e8a672618c5778882d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sc_muladd</b> (uint8_t *, const uint8_t *, const uint8_t *, const uint8_t *)</td></tr>
<tr class="separator:afbf5fb74f75f8e8a672618c5778882d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0a91dc71fee53c2fee96871c7f7615"><td class="memItemLeft" align="right" valign="top"><a id="abb0a91dc71fee53c2fee96871c7f7615"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ge_double_scalarmult_vartime</b> (uint8_t out[32], const uint8_t *a, const <a class="el" href="struct_botan_1_1ge__p3.html">ge_p3</a> *A, const uint8_t *b)</td></tr>
<tr class="separator:abb0a91dc71fee53c2fee96871c7f7615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a00d178520dc81df3cc56aeb05c090"><td class="memItemLeft" align="right" valign="top"><a id="a00a00d178520dc81df3cc56aeb05c090"></a>
McEliece_PrivateKey&#160;</td><td class="memItemRight" valign="bottom"><b>generate_mceliece_key</b> (RandomNumberGenerator &amp;rng, uint32_t ext_deg, uint32_t code_length, uint32_t t)</td></tr>
<tr class="separator:a00a00d178520dc81df3cc56aeb05c090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0b6b61c8483eb1efca4564bb144828"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a0b6b61c8483eb1efca4564bb144828"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a2a0b6b61c8483eb1efca4564bb144828">expand_mask_16bit</a> (T tst)</td></tr>
<tr class="separator:a2a0b6b61c8483eb1efca4564bb144828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a034f6ffbedf7c310fb4de5babe0e2f"><td class="memItemLeft" align="right" valign="top"><a id="a8a034f6ffbedf7c310fb4de5babe0e2f"></a>
gf2m&#160;</td><td class="memItemRight" valign="bottom"><b>gray_to_lex</b> (gf2m gray)</td></tr>
<tr class="separator:a8a034f6ffbedf7c310fb4de5babe0e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f805af14a8443cddfb254ff07410ac3"><td class="memItemLeft" align="right" valign="top"><a id="a0f805af14a8443cddfb254ff07410ac3"></a>
gf2m&#160;</td><td class="memItemRight" valign="bottom"><b>lex_to_gray</b> (gf2m lex)</td></tr>
<tr class="separator:a0f805af14a8443cddfb254ff07410ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511ec83b0f8c9a684ca5b486626714e9"><td class="memItemLeft" align="right" valign="top"><a id="a511ec83b0f8c9a684ca5b486626714e9"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>bit_size_to_byte_size</b> (uint32_t bit_size)</td></tr>
<tr class="separator:a511ec83b0f8c9a684ca5b486626714e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d097bb936f18978fac8f201b9445ad"><td class="memItemLeft" align="right" valign="top"><a id="a21d097bb936f18978fac8f201b9445ad"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>bit_size_to_32bit_size</b> (uint32_t bit_size)</td></tr>
<tr class="separator:a21d097bb936f18978fac8f201b9445ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664573e9a1043c872e3d0c03d4d9f2ec"><td class="memItemLeft" align="right" valign="top">secure_vector&lt; gf2m &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a664573e9a1043c872e3d0c03d4d9f2ec">find_roots_gf2m_decomp</a> (const <a class="el" href="class_botan_1_1polyn__gf2m.html">polyn_gf2m</a> &amp;polyn, uint32_t code_length)</td></tr>
<tr class="separator:a664573e9a1043c872e3d0c03d4d9f2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7ce066cb6c98ece3bfc7ed40ba665b"><td class="memItemLeft" align="right" valign="top"><a id="acc7ce066cb6c98ece3bfc7ed40ba665b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>encode_gf2m</b> (gf2m to_enc, uint8_t *mem)</td></tr>
<tr class="separator:acc7ce066cb6c98ece3bfc7ed40ba665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67aa49c644e0c2e5c1a8ed30e6e319a"><td class="memItemLeft" align="right" valign="top"><a id="ac67aa49c644e0c2e5c1a8ed30e6e319a"></a>
gf2m&#160;</td><td class="memItemRight" valign="bottom"><b>decode_gf2m</b> (const uint8_t *mem)</td></tr>
<tr class="separator:ac67aa49c644e0c2e5c1a8ed30e6e319a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18febd75324fc74a6f1004e3f8d118ad"><td class="memItemLeft" align="right" valign="top"><a id="a18febd75324fc74a6f1004e3f8d118ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mceliece_decrypt</b> (secure_vector&lt; uint8_t &gt; &amp;plaintext_out, secure_vector&lt; uint8_t &gt; &amp;error_mask_out, const secure_vector&lt; uint8_t &gt; &amp;ciphertext, const McEliece_PrivateKey &amp;key)</td></tr>
<tr class="separator:a18febd75324fc74a6f1004e3f8d118ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0b3e6872a88e36041d2ee95af513da"><td class="memItemLeft" align="right" valign="top"><a id="a0c0b3e6872a88e36041d2ee95af513da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mceliece_decrypt</b> (secure_vector&lt; uint8_t &gt; &amp;plaintext, secure_vector&lt; uint8_t &gt; &amp;error_mask, const uint8_t ciphertext[], size_t ciphertext_len, const McEliece_PrivateKey &amp;key)</td></tr>
<tr class="separator:a0c0b3e6872a88e36041d2ee95af513da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84dac7bdfb3e9c9ecb19a2e55596ded"><td class="memItemLeft" align="right" valign="top">secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ac84dac7bdfb3e9c9ecb19a2e55596ded">mceliece_decrypt</a> (secure_vector&lt; gf2m &gt; &amp;error_pos, const uint8_t *ciphertext, uint32_t ciphertext_len, const McEliece_PrivateKey &amp;key)</td></tr>
<tr class="separator:ac84dac7bdfb3e9c9ecb19a2e55596ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2abc4158149f6afc3f2a8d7f139c7d"><td class="memItemLeft" align="right" valign="top"><a id="a4b2abc4158149f6afc3f2a8d7f139c7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mceliece_encrypt</b> (secure_vector&lt; uint8_t &gt; &amp;ciphertext_out, secure_vector&lt; uint8_t &gt; &amp;error_mask_out, const secure_vector&lt; uint8_t &gt; &amp;plaintext, const McEliece_PublicKey &amp;key, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:a4b2abc4158149f6afc3f2a8d7f139c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8822e6d236cbde80b706061c49ee340f"><td class="memItemLeft" align="right" valign="top"><a id="a8822e6d236cbde80b706061c49ee340f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>mceliece_work_factor</b> (size_t n, size_t t)</td></tr>
<tr class="separator:a8822e6d236cbde80b706061c49ee340f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfd25b09667ccc4f9fc801ff2577d46"><td class="memItemLeft" align="right" valign="top"><a id="a8dfd25b09667ccc4f9fc801ff2577d46"></a>
gf2m&#160;</td><td class="memItemRight" valign="bottom"><b>random_gf2m</b> (RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:a8dfd25b09667ccc4f9fc801ff2577d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7b7c44821bc546a8d4ae730966c89e"><td class="memItemLeft" align="right" valign="top"><a id="adb7b7c44821bc546a8d4ae730966c89e"></a>
gf2m&#160;</td><td class="memItemRight" valign="bottom"><b>random_code_element</b> (unsigned code_length, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:adb7b7c44821bc546a8d4ae730966c89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b38a4a205cd087803b9a9b3c109d304"><td class="memItemLeft" align="right" valign="top"><a id="a1b38a4a205cd087803b9a9b3c109d304"></a>
std::vector&lt; <a class="el" href="class_botan_1_1polyn__gf2m.html">polyn_gf2m</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>syndrome_init</b> (<a class="el" href="class_botan_1_1polyn__gf2m.html">polyn_gf2m</a> const &amp;generator, std::vector&lt; gf2m &gt; const &amp;support, int n)</td></tr>
<tr class="separator:a1b38a4a205cd087803b9a9b3c109d304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd43fb69186e28b8d97fecaad70c4ef"><td class="memItemLeft" align="right" valign="top"><a id="a7cd43fb69186e28b8d97fecaad70c4ef"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mceies_encrypt</b> (const McEliece_PublicKey &amp;pubkey, const uint8_t pt[], size_t pt_len, const uint8_t ad[], size_t ad_len, RandomNumberGenerator &amp;rng, const std::string &amp;algo)</td></tr>
<tr class="separator:a7cd43fb69186e28b8d97fecaad70c4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9e5d5d1c169cf94500786f338d1f85"><td class="memItemLeft" align="right" valign="top"><a id="a6c9e5d5d1c169cf94500786f338d1f85"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mceies_decrypt</b> (const McEliece_PrivateKey &amp;privkey, const uint8_t ct[], size_t ct_len, const uint8_t ad[], size_t ad_len, const std::string &amp;algo)</td></tr>
<tr class="separator:a6c9e5d5d1c169cf94500786f338d1f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e5c383ece5e6d467494a75ff0d5d66"><td class="memItemLeft" align="right" valign="top"><a id="ab5e5c383ece5e6d467494a75ff0d5d66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>newhope_keygen</b> (uint8_t *send, <a class="el" href="class_botan_1_1newhope__poly.html">poly</a> *sk, RandomNumberGenerator &amp;rng, <a class="el" href="namespace_botan.html#a42a70d7cfb95e4f7773d3b52dc98ad61">Newhope_Mode</a> mode)</td></tr>
<tr class="separator:ab5e5c383ece5e6d467494a75ff0d5d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9324c0b322f6247eab2d9ecc727ce6"><td class="memItemLeft" align="right" valign="top"><a id="aaa9324c0b322f6247eab2d9ecc727ce6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>newhope_sharedb</b> (uint8_t *sharedkey, uint8_t *send, const uint8_t *received, RandomNumberGenerator &amp;rng, <a class="el" href="namespace_botan.html#a42a70d7cfb95e4f7773d3b52dc98ad61">Newhope_Mode</a> mode)</td></tr>
<tr class="separator:aaa9324c0b322f6247eab2d9ecc727ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d06dbd7866aa3268a24a89c7b5d56a7"><td class="memItemLeft" align="right" valign="top"><a id="a9d06dbd7866aa3268a24a89c7b5d56a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>newhope_shareda</b> (uint8_t sharedkey[], const <a class="el" href="class_botan_1_1newhope__poly.html">poly</a> *sk, const uint8_t received[], <a class="el" href="namespace_botan.html#a42a70d7cfb95e4f7773d3b52dc98ad61">Newhope_Mode</a> mode)</td></tr>
<tr class="separator:a9d06dbd7866aa3268a24a89c7b5d56a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa296e21a83107dbfd7d33a05976598fd"><td class="memItemLeft" align="right" valign="top"><a id="aa296e21a83107dbfd7d33a05976598fd"></a>
std::pair&lt; AlgorithmIdentifier, std::vector&lt; uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pbes2_encrypt</b> (const secure_vector&lt; uint8_t &gt; &amp;key_bits, const std::string &amp;passphrase, std::chrono::milliseconds msec, const std::string &amp;cipher, const std::string &amp;digest, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:aa296e21a83107dbfd7d33a05976598fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740ed14057fc918d954be3c9846e327"><td class="memItemLeft" align="right" valign="top"><a id="af740ed14057fc918d954be3c9846e327"></a>
std::pair&lt; AlgorithmIdentifier, std::vector&lt; uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pbes2_encrypt_msec</b> (const secure_vector&lt; uint8_t &gt; &amp;key_bits, const std::string &amp;passphrase, std::chrono::milliseconds msec, size_t *out_iterations_if_nonnull, const std::string &amp;cipher, const std::string &amp;digest, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:af740ed14057fc918d954be3c9846e327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0eb6721b79d35fec1c25fdabc259d0"><td class="memItemLeft" align="right" valign="top"><a id="a1d0eb6721b79d35fec1c25fdabc259d0"></a>
std::pair&lt; AlgorithmIdentifier, std::vector&lt; uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pbes2_encrypt_iter</b> (const secure_vector&lt; uint8_t &gt; &amp;key_bits, const std::string &amp;passphrase, size_t pbkdf_iter, const std::string &amp;cipher, const std::string &amp;digest, RandomNumberGenerator &amp;rng)</td></tr>
<tr class="separator:a1d0eb6721b79d35fec1c25fdabc259d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d487947d7dcf39c8a546f4843acb153"><td class="memItemLeft" align="right" valign="top"><a id="a0d487947d7dcf39c8a546f4843acb153"></a>
secure_vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pbes2_decrypt</b> (const secure_vector&lt; uint8_t &gt; &amp;key_bits, const std::string &amp;passphrase, const std::vector&lt; uint8_t &gt; &amp;params)</td></tr>
<tr class="separator:a0d487947d7dcf39c8a546f4843acb153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8936d9d14b59d25507d664d4e631b605"><td class="memItemLeft" align="right" valign="top">std::pair&lt; AlgorithmIdentifier, std::vector&lt; uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a8936d9d14b59d25507d664d4e631b605">BOTAN_PUBLIC_API</a> (2, 1) pbes2_encrypt_msec(const secure_vector&lt; uint8_t &gt; &amp;key_bits</td></tr>
<tr class="separator:a8936d9d14b59d25507d664d4e631b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f60379e6b6d63760ff2f008b2336482"><td class="memItemLeft" align="right" valign="top"><a id="a2f60379e6b6d63760ff2f008b2336482"></a>
std::unique_ptr&lt; Public_Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>load_public_key</b> (const AlgorithmIdentifier &amp;alg_id, const std::vector&lt; uint8_t &gt; &amp;key_bits)</td></tr>
<tr class="separator:a2f60379e6b6d63760ff2f008b2336482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ebf459fd248e8172060e75c9f0e7b9"><td class="memItemLeft" align="right" valign="top"><a id="a21ebf459fd248e8172060e75c9f0e7b9"></a>
std::unique_ptr&lt; Private_Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>load_private_key</b> (const AlgorithmIdentifier &amp;alg_id, const secure_vector&lt; uint8_t &gt; &amp;key_bits)</td></tr>
<tr class="separator:a21ebf459fd248e8172060e75c9f0e7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4678f1d5c0f5bef2a0ac213587c1e53f"><td class="memItemLeft" align="right" valign="top"><a id="a4678f1d5c0f5bef2a0ac213587c1e53f"></a>
std::unique_ptr&lt; Private_Key &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create_private_key</b> (const std::string &amp;alg_name, RandomNumberGenerator &amp;rng, const std::string &amp;params, const std::string &amp;provider)</td></tr>
<tr class="separator:a4678f1d5c0f5bef2a0ac213587c1e53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80126ae204756cd304ffeab9085c6f4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ac80126ae204756cd304ffeab9085c6f4">probe_provider_private_key</a> (const std::string &amp;alg_name, const std::vector&lt; std::string &gt; possible)</td></tr>
<tr class="separator:ac80126ae204756cd304ffeab9085c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9af5b1d05ba0ff3aa227c9cec30414"><td class="memItemLeft" align="right" valign="top"><a id="abc9af5b1d05ba0ff3aa227c9cec30414"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>create_hex_fingerprint</b> (const uint8_t bits[], size_t bits_len, const std::string &amp;hash_name)</td></tr>
<tr class="separator:abc9af5b1d05ba0ff3aa227c9cec30414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ef503f22a2ecf449c39d1a42b6fea"><td class="memTemplParams" colspan="2"><a id="a2c2ef503f22a2ecf449c39d1a42b6fea"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a2c2ef503f22a2ecf449c39d1a42b6fea"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_hex_fingerprint</b> (const std::vector&lt; uint8_t, Alloc &gt; &amp;vec, const std::string &amp;hash_name)</td></tr>
<tr class="separator:a2c2ef503f22a2ecf449c39d1a42b6fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855627e1a2d03d45cd260fee98e20034"><td class="memItemLeft" align="right" valign="top"><a id="a855627e1a2d03d45cd260fee98e20034"></a>
BigInt&#160;</td><td class="memItemRight" valign="bottom"><b>generate_rfc6979_nonce</b> (const BigInt &amp;x, const BigInt &amp;q, const BigInt &amp;h, const std::string &amp;hash)</td></tr>
<tr class="separator:a855627e1a2d03d45cd260fee98e20034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff738894189bc8efe9b9fd1627bfa87b"><td class="memItemLeft" align="right" valign="top"><a id="aff738894189bc8efe9b9fd1627bfa87b"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sm2_compute_za</b> (HashFunction &amp;hash, const std::string &amp;user_id, const EC_Group &amp;domain, const PointGFp &amp;pubkey)</td></tr>
<tr class="separator:aff738894189bc8efe9b9fd1627bfa87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052be30bea341e348a9799089e9487a1"><td class="memItemLeft" align="right" valign="top"><a id="a052be30bea341e348a9799089e9487a1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ecp_work_factor</b> (size_t bits)</td></tr>
<tr class="separator:a052be30bea341e348a9799089e9487a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39d3f87c846b73489224288fed48816"><td class="memItemLeft" align="right" valign="top"><a id="ab39d3f87c846b73489224288fed48816"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>if_work_factor</b> (size_t bits)</td></tr>
<tr class="separator:ab39d3f87c846b73489224288fed48816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad494d424e7cb89e7bf62d64858099d"><td class="memItemLeft" align="right" valign="top"><a id="a3ad494d424e7cb89e7bf62d64858099d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>dl_work_factor</b> (size_t bits)</td></tr>
<tr class="separator:a3ad494d424e7cb89e7bf62d64858099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c03a0ad579b6f211a02d53f0f66477"><td class="memItemLeft" align="right" valign="top"><a id="a68c03a0ad579b6f211a02d53f0f66477"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>dl_exponent_size</b> (size_t bits)</td></tr>
<tr class="separator:a68c03a0ad579b6f211a02d53f0f66477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8626e977565dc7b6ee31fb9e3d772764"><td class="memItemLeft" align="right" valign="top"><a id="a8626e977565dc7b6ee31fb9e3d772764"></a>
RandomNumberGenerator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>system_rng</b> ()</td></tr>
<tr class="separator:a8626e977565dc7b6ee31fb9e3d772764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf096546028928a2d760aa504a9a2a74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aaf096546028928a2d760aa504a9a2a74">throw_invalid_argument</a> (const char *message, const char *func, const char *file)</td></tr>
<tr class="separator:aaf096546028928a2d760aa504a9a2a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46752d75e4f165d48d1ab2c5c33033b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ad46752d75e4f165d48d1ab2c5c33033b">throw_invalid_state</a> (const char *expr, const char *func, const char *file)</td></tr>
<tr class="separator:ad46752d75e4f165d48d1ab2c5c33033b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2929788bbcbcd1783f96d26ecabdba"><td class="memItemLeft" align="right" valign="top"><a id="aea2929788bbcbcd1783f96d26ecabdba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assertion_failure</b> (const char *expr_str, const char *assertion_made, const char *func, const char *file, int line)</td></tr>
<tr class="separator:aea2929788bbcbcd1783f96d26ecabdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab1f8b408a2ea772778740017bddcd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeab1f8b408a2ea772778740017bddcd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aeab1f8b408a2ea772778740017bddcd5">is_power_of_2</a> (T arg)</td></tr>
<tr class="separator:aeab1f8b408a2ea772778740017bddcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c09360d3936ba7077b2d8b14d6cbaa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6c09360d3936ba7077b2d8b14d6cbaa"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ad6c09360d3936ba7077b2d8b14d6cbaa">high_bit</a> (T n)</td></tr>
<tr class="separator:ad6c09360d3936ba7077b2d8b14d6cbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0c04508a1e70c5d4ecf363e8b75f00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae0c04508a1e70c5d4ecf363e8b75f00"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aae0c04508a1e70c5d4ecf363e8b75f00">low_bit</a> (T n)</td></tr>
<tr class="separator:aae0c04508a1e70c5d4ecf363e8b75f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec63fb9306fc59d57604c157777361d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acec63fb9306fc59d57604c157777361d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#acec63fb9306fc59d57604c157777361d">significant_bytes</a> (T n)</td></tr>
<tr class="separator:acec63fb9306fc59d57604c157777361d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6896c37db627e3ab8e1fa7c72f79fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb6896c37db627e3ab8e1fa7c72f79fd"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#abb6896c37db627e3ab8e1fa7c72f79fd">hamming_weight</a> (T n)</td></tr>
<tr class="separator:abb6896c37db627e3ab8e1fa7c72f79fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4045abfe1da803ec251fcfd4d04b0c10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4045abfe1da803ec251fcfd4d04b0c10"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a4045abfe1da803ec251fcfd4d04b0c10">ctz</a> (T n)</td></tr>
<tr class="separator:a4045abfe1da803ec251fcfd4d04b0c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c49c7bd13d7c6648a543775d4a1354"><td class="memTemplParams" colspan="2"><a id="a03c49c7bd13d7c6648a543775d4a1354"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03c49c7bd13d7c6648a543775d4a1354"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ceil_log2</b> (T x)</td></tr>
<tr class="separator:a03c49c7bd13d7c6648a543775d4a1354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124bfd8e6621e1ad0d19d902ce10f149"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a124bfd8e6621e1ad0d19d902ce10f149">reverse_bytes</a> (uint16_t val)</td></tr>
<tr class="separator:a124bfd8e6621e1ad0d19d902ce10f149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0e57eb245139c321b18d1d242c9e9f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a5c0e57eb245139c321b18d1d242c9e9f">reverse_bytes</a> (uint32_t val)</td></tr>
<tr class="separator:a5c0e57eb245139c321b18d1d242c9e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04de07006f5cfa825328813ea7d3985"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ae04de07006f5cfa825328813ea7d3985">reverse_bytes</a> (uint64_t val)</td></tr>
<tr class="separator:ae04de07006f5cfa825328813ea7d3985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec087b9959d7ffcbc195dcedbf10513"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ec087b9959d7ffcbc195dcedbf10513"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a5ec087b9959d7ffcbc195dcedbf10513">bswap_4</a> (T x[4])</td></tr>
<tr class="separator:a5ec087b9959d7ffcbc195dcedbf10513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed98df0cf6f5b39eee2e12ddfefcde5"><td class="memItemLeft" align="right" valign="top"><a id="afed98df0cf6f5b39eee2e12ddfefcde5"></a>
calendar_point&#160;</td><td class="memItemRight" valign="bottom"><b>calendar_value</b> (const std::chrono::system_clock::time_point &amp;time_point)</td></tr>
<tr class="separator:afed98df0cf6f5b39eee2e12ddfefcde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7ee67f502279fc24a01b42c5451c3c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a2d7ee67f502279fc24a01b42c5451c3c">ucs2_to_utf8</a> (const uint8_t ucs2[], size_t len)</td></tr>
<tr class="separator:a2d7ee67f502279fc24a01b42c5451c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb4359def9a750e534e6ece252bd319"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a2bb4359def9a750e534e6ece252bd319">ucs4_to_utf8</a> (const uint8_t ucs4[], size_t len)</td></tr>
<tr class="separator:a2bb4359def9a750e534e6ece252bd319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590c935190a5568639820d98a911f7cd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a590c935190a5568639820d98a911f7cd">utf8_to_latin1</a> (const std::string &amp;utf8)</td></tr>
<tr class="separator:a590c935190a5568639820d98a911f7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4a5ffdca168ee94c08a5b20de0065a"><td class="memTemplParams" colspan="2">template&lt;class Base &gt; </td></tr>
<tr class="memitem:a8a4a5ffdca168ee94c08a5b20de0065a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a8a4a5ffdca168ee94c08a5b20de0065a">base_encode</a> (Base &amp;&amp;base, char output[], const uint8_t input[], size_t input_length, size_t &amp;input_consumed, bool final_inputs)</td></tr>
<tr class="separator:a8a4a5ffdca168ee94c08a5b20de0065a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9ed5028ed938ee4d8f6929c91e157a"><td class="memTemplParams" colspan="2"><a id="abb9ed5028ed938ee4d8f6929c91e157a"></a>
template&lt;typename Base &gt; </td></tr>
<tr class="memitem:abb9ed5028ed938ee4d8f6929c91e157a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>base_encode_to_string</b> (Base &amp;&amp;base, const uint8_t input[], size_t input_length)</td></tr>
<tr class="separator:abb9ed5028ed938ee4d8f6929c91e157a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d8df562b6507ed384c0f214f9b6a07"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:ab1d8df562b6507ed384c0f214f9b6a07"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ab1d8df562b6507ed384c0f214f9b6a07">base_decode</a> (Base &amp;&amp;base, uint8_t output[], const char input[], size_t input_length, size_t &amp;input_consumed, bool final_inputs, bool ignore_ws=true)</td></tr>
<tr class="separator:ab1d8df562b6507ed384c0f214f9b6a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf80d42ee926400476065a190891bc7"><td class="memTemplParams" colspan="2"><a id="afaf80d42ee926400476065a190891bc7"></a>
template&lt;typename Base &gt; </td></tr>
<tr class="memitem:afaf80d42ee926400476065a190891bc7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>base_decode_full</b> (Base &amp;&amp;base, uint8_t output[], const char input[], size_t input_length, bool ignore_ws)</td></tr>
<tr class="separator:afaf80d42ee926400476065a190891bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffb0eed609e7a4c573647072bf77e3e"><td class="memTemplParams" colspan="2"><a id="a5ffb0eed609e7a4c573647072bf77e3e"></a>
template&lt;typename Vector , typename Base &gt; </td></tr>
<tr class="memitem:a5ffb0eed609e7a4c573647072bf77e3e"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><b>base_decode_to_vec</b> (Base &amp;&amp;base, const char input[], size_t input_length, bool ignore_ws)</td></tr>
<tr class="separator:a5ffb0eed609e7a4c573647072bf77e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5a27e7efae7fee0144272c85a85cff"><td class="memItemLeft" align="right" valign="top"><a id="aae5a27e7efae7fee0144272c85a85cff"></a>
<a class="el" href="class_botan_1_1donna128.html">donna128</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;x, uint64_t y)</td></tr>
<tr class="separator:aae5a27e7efae7fee0144272c85a85cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a244929b2ae17b43206587dcfc536be"><td class="memItemLeft" align="right" valign="top"><a id="a3a244929b2ae17b43206587dcfc536be"></a>
<a class="el" href="class_botan_1_1donna128.html">donna128</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (uint64_t y, const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;x)</td></tr>
<tr class="separator:a3a244929b2ae17b43206587dcfc536be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d9042165591b302e15c61f7ad081e1"><td class="memItemLeft" align="right" valign="top"><a id="a04d9042165591b302e15c61f7ad081e1"></a>
<a class="el" href="class_botan_1_1donna128.html">donna128</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;x, const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;y)</td></tr>
<tr class="separator:a04d9042165591b302e15c61f7ad081e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7976bfaf3d3a65ba010b94237cc9b31"><td class="memItemLeft" align="right" valign="top"><a id="ae7976bfaf3d3a65ba010b94237cc9b31"></a>
<a class="el" href="class_botan_1_1donna128.html">donna128</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;x, uint64_t y)</td></tr>
<tr class="separator:ae7976bfaf3d3a65ba010b94237cc9b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb91149ce059bbaf2733e1590111d7"><td class="memItemLeft" align="right" valign="top"><a id="aa6bb91149ce059bbaf2733e1590111d7"></a>
<a class="el" href="class_botan_1_1donna128.html">donna128</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;x, const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;y)</td></tr>
<tr class="separator:aa6bb91149ce059bbaf2733e1590111d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f03d5ad2b788e9165b76192951cfaf"><td class="memItemLeft" align="right" valign="top"><a id="a78f03d5ad2b788e9165b76192951cfaf"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>carry_shift</b> (const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;a, size_t shift)</td></tr>
<tr class="separator:a78f03d5ad2b788e9165b76192951cfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a55717f300b4c1ba4c45f4eb5813c86"><td class="memItemLeft" align="right" valign="top"><a id="a8a55717f300b4c1ba4c45f4eb5813c86"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>combine_lower</b> (const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;a, size_t s1, const <a class="el" href="class_botan_1_1donna128.html">donna128</a> &amp;b, size_t s2)</td></tr>
<tr class="separator:a8a55717f300b4c1ba4c45f4eb5813c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6c58c9b9ef1e9aa417eb2e71371828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#acc6c58c9b9ef1e9aa417eb2e71371828">has_filesystem_impl</a> ()</td></tr>
<tr class="separator:acc6c58c9b9ef1e9aa417eb2e71371828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7857bf68bffe64c3810d4000fa920d"><td class="memItemLeft" align="right" valign="top"><a id="a2c7857bf68bffe64c3810d4000fa920d"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_files_recursive</b> (const std::string &amp;dir)</td></tr>
<tr class="separator:a2c7857bf68bffe64c3810d4000fa920d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10dc938a651323dddbfe3c1e985774b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad10dc938a651323dddbfe3c1e985774b"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ad10dc938a651323dddbfe3c1e985774b">get_byte</a> (size_t byte_num, T input)</td></tr>
<tr class="separator:ad10dc938a651323dddbfe3c1e985774b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1f23105ed52b51390e214db16b6900"><td class="memItemLeft" align="right" valign="top">constexpr uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#afa1f23105ed52b51390e214db16b6900">make_uint16</a> (uint8_t i0, uint8_t i1)</td></tr>
<tr class="separator:afa1f23105ed52b51390e214db16b6900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690f1a5eaa98c00b71ef8320322e722e"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a690f1a5eaa98c00b71ef8320322e722e">make_uint32</a> (uint8_t i0, uint8_t i1, uint8_t i2, uint8_t i3)</td></tr>
<tr class="separator:a690f1a5eaa98c00b71ef8320322e722e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267c278fd265a2fc255df8b8de93dde2"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a267c278fd265a2fc255df8b8de93dde2">make_uint64</a> (uint8_t i0, uint8_t i1, uint8_t i2, uint8_t i3, uint8_t i4, uint8_t i5, uint8_t i6, uint8_t i7)</td></tr>
<tr class="separator:a267c278fd265a2fc255df8b8de93dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640029f085cc0a904b32e20f42303dd2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a640029f085cc0a904b32e20f42303dd2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a640029f085cc0a904b32e20f42303dd2">load_be</a> (const uint8_t in[], size_t off)</td></tr>
<tr class="separator:a640029f085cc0a904b32e20f42303dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745efa1d08234fe3b785f17c19ec26b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a745efa1d08234fe3b785f17c19ec26b7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a745efa1d08234fe3b785f17c19ec26b7">load_le</a> (const uint8_t in[], size_t off)</td></tr>
<tr class="separator:a745efa1d08234fe3b785f17c19ec26b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bab280ff3476b4539a9c2946c690f1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab6bab280ff3476b4539a9c2946c690f1"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ab6bab280ff3476b4539a9c2946c690f1">load_be&lt; uint16_t &gt;</a> (const uint8_t in[], size_t off)</td></tr>
<tr class="separator:ab6bab280ff3476b4539a9c2946c690f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5c38bea458b6183ef69afd5ec0cc42"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aeb5c38bea458b6183ef69afd5ec0cc42"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aeb5c38bea458b6183ef69afd5ec0cc42">load_le&lt; uint16_t &gt;</a> (const uint8_t in[], size_t off)</td></tr>
<tr class="separator:aeb5c38bea458b6183ef69afd5ec0cc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859a883d8cb8ec54d5c8d62969260bd8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a859a883d8cb8ec54d5c8d62969260bd8"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a859a883d8cb8ec54d5c8d62969260bd8">load_be&lt; uint32_t &gt;</a> (const uint8_t in[], size_t off)</td></tr>
<tr class="separator:a859a883d8cb8ec54d5c8d62969260bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9442a9a8c4177d35388d0c82f7f2e0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2d9442a9a8c4177d35388d0c82f7f2e0"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a2d9442a9a8c4177d35388d0c82f7f2e0">load_le&lt; uint32_t &gt;</a> (const uint8_t in[], size_t off)</td></tr>
<tr class="separator:a2d9442a9a8c4177d35388d0c82f7f2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d5556307d65f0974740f8c3fc33639"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a96d5556307d65f0974740f8c3fc33639"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a96d5556307d65f0974740f8c3fc33639">load_be&lt; uint64_t &gt;</a> (const uint8_t in[], size_t off)</td></tr>
<tr class="separator:a96d5556307d65f0974740f8c3fc33639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e343d945901fa17325279d27a14e39"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af8e343d945901fa17325279d27a14e39"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#af8e343d945901fa17325279d27a14e39">load_le&lt; uint64_t &gt;</a> (const uint8_t in[], size_t off)</td></tr>
<tr class="separator:af8e343d945901fa17325279d27a14e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb60b6e5af3132bc5095cfcbaa90fc35"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb60b6e5af3132bc5095cfcbaa90fc35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#abb60b6e5af3132bc5095cfcbaa90fc35">load_le</a> (const uint8_t in[], T &amp;x0, T &amp;x1)</td></tr>
<tr class="separator:abb60b6e5af3132bc5095cfcbaa90fc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b8aebd623614ee2d8804bb82b96928"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03b8aebd623614ee2d8804bb82b96928"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a03b8aebd623614ee2d8804bb82b96928">load_le</a> (const uint8_t in[], T &amp;x0, T &amp;x1, T &amp;x2, T &amp;x3)</td></tr>
<tr class="separator:a03b8aebd623614ee2d8804bb82b96928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170a82161413e005b53c3db27d79678e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a170a82161413e005b53c3db27d79678e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a170a82161413e005b53c3db27d79678e">load_le</a> (const uint8_t in[], T &amp;x0, T &amp;x1, T &amp;x2, T &amp;x3, T &amp;x4, T &amp;x5, T &amp;x6, T &amp;x7)</td></tr>
<tr class="separator:a170a82161413e005b53c3db27d79678e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d83d9e349598b56af765a1acb441bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42d83d9e349598b56af765a1acb441bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a42d83d9e349598b56af765a1acb441bc">load_le</a> (T out[], const uint8_t in[], size_t count)</td></tr>
<tr class="separator:a42d83d9e349598b56af765a1acb441bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5773c133cf22abd1269664b59c16244a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5773c133cf22abd1269664b59c16244a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a5773c133cf22abd1269664b59c16244a">load_be</a> (const uint8_t in[], T &amp;x0, T &amp;x1)</td></tr>
<tr class="separator:a5773c133cf22abd1269664b59c16244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0c4a782d518167985566686e4d1a95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b0c4a782d518167985566686e4d1a95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a0b0c4a782d518167985566686e4d1a95">load_be</a> (const uint8_t in[], T &amp;x0, T &amp;x1, T &amp;x2, T &amp;x3)</td></tr>
<tr class="separator:a0b0c4a782d518167985566686e4d1a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996923074c3867c0f2ce1d1b96b8fd4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a996923074c3867c0f2ce1d1b96b8fd4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a996923074c3867c0f2ce1d1b96b8fd4b">load_be</a> (const uint8_t in[], T &amp;x0, T &amp;x1, T &amp;x2, T &amp;x3, T &amp;x4, T &amp;x5, T &amp;x6, T &amp;x7)</td></tr>
<tr class="separator:a996923074c3867c0f2ce1d1b96b8fd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b13c515a5a6599c5074fd9471192b69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b13c515a5a6599c5074fd9471192b69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a0b13c515a5a6599c5074fd9471192b69">load_be</a> (T out[], const uint8_t in[], size_t count)</td></tr>
<tr class="separator:a0b13c515a5a6599c5074fd9471192b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f4a43173adf5f333b598149c3eef1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a26f4a43173adf5f333b598149c3eef1e">store_be</a> (uint16_t in, uint8_t out[2])</td></tr>
<tr class="separator:a26f4a43173adf5f333b598149c3eef1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c49ee3a99775f2fba422752fdbc21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ac0c49ee3a99775f2fba422752fdbc21a">store_le</a> (uint16_t in, uint8_t out[2])</td></tr>
<tr class="separator:ac0c49ee3a99775f2fba422752fdbc21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237738c57bc371f45785750daad2cf7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a237738c57bc371f45785750daad2cf7f">store_be</a> (uint32_t in, uint8_t out[4])</td></tr>
<tr class="separator:a237738c57bc371f45785750daad2cf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced6f16a306b58cc117c3a03e04cf788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aced6f16a306b58cc117c3a03e04cf788">store_le</a> (uint32_t in, uint8_t out[4])</td></tr>
<tr class="separator:aced6f16a306b58cc117c3a03e04cf788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55277e5a97f10bb1f19a121bfcce030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#af55277e5a97f10bb1f19a121bfcce030">store_be</a> (uint64_t in, uint8_t out[8])</td></tr>
<tr class="separator:af55277e5a97f10bb1f19a121bfcce030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac123595229ef6588f851540b9b774800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ac123595229ef6588f851540b9b774800">store_le</a> (uint64_t in, uint8_t out[8])</td></tr>
<tr class="separator:ac123595229ef6588f851540b9b774800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf3a60376720003e37586a548175426"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bf3a60376720003e37586a548175426"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a0bf3a60376720003e37586a548175426">store_le</a> (uint8_t out[], T x0, T x1)</td></tr>
<tr class="separator:a0bf3a60376720003e37586a548175426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2d43d6f22f9440efca19d126179271"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf2d43d6f22f9440efca19d126179271"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#adf2d43d6f22f9440efca19d126179271">store_be</a> (uint8_t out[], T x0, T x1)</td></tr>
<tr class="separator:adf2d43d6f22f9440efca19d126179271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba9e7bbb06b5843eb883b1fdbe22848"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ba9e7bbb06b5843eb883b1fdbe22848"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a7ba9e7bbb06b5843eb883b1fdbe22848">store_le</a> (uint8_t out[], T x0, T x1, T x2, T x3)</td></tr>
<tr class="separator:a7ba9e7bbb06b5843eb883b1fdbe22848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8b865c60e5d60524c7c79d66b4b120"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c8b865c60e5d60524c7c79d66b4b120"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a2c8b865c60e5d60524c7c79d66b4b120">store_be</a> (uint8_t out[], T x0, T x1, T x2, T x3)</td></tr>
<tr class="separator:a2c8b865c60e5d60524c7c79d66b4b120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4ba47d9124f22d4f31e9a1e6522053"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b4ba47d9124f22d4f31e9a1e6522053"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a7b4ba47d9124f22d4f31e9a1e6522053">store_le</a> (uint8_t out[], T x0, T x1, T x2, T x3, T x4, T x5, T x6, T x7)</td></tr>
<tr class="separator:a7b4ba47d9124f22d4f31e9a1e6522053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7562c0698d83b375aef50abc64bcdd2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7562c0698d83b375aef50abc64bcdd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ac7562c0698d83b375aef50abc64bcdd2">store_be</a> (uint8_t out[], T x0, T x1, T x2, T x3, T x4, T x5, T x6, T x7)</td></tr>
<tr class="separator:ac7562c0698d83b375aef50abc64bcdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5951af5d67ee89f552e66abe8a19de7"><td class="memTemplParams" colspan="2"><a id="ae5951af5d67ee89f552e66abe8a19de7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5951af5d67ee89f552e66abe8a19de7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_out_be</b> (uint8_t out[], size_t out_bytes, const T in[])</td></tr>
<tr class="separator:ae5951af5d67ee89f552e66abe8a19de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10bb467867948b805d2ed47e520ee08"><td class="memTemplParams" colspan="2"><a id="af10bb467867948b805d2ed47e520ee08"></a>
template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:af10bb467867948b805d2ed47e520ee08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_out_vec_be</b> (uint8_t out[], size_t out_bytes, const std::vector&lt; T, Alloc &gt; &amp;in)</td></tr>
<tr class="separator:af10bb467867948b805d2ed47e520ee08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c13ee419fb7aec9be106be04a7d58b0"><td class="memTemplParams" colspan="2"><a id="a0c13ee419fb7aec9be106be04a7d58b0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c13ee419fb7aec9be106be04a7d58b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_out_le</b> (uint8_t out[], size_t out_bytes, const T in[])</td></tr>
<tr class="separator:a0c13ee419fb7aec9be106be04a7d58b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50163d1f1821b426712ed51ea5f55f89"><td class="memTemplParams" colspan="2"><a id="a50163d1f1821b426712ed51ea5f55f89"></a>
template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a50163d1f1821b426712ed51ea5f55f89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_out_vec_le</b> (uint8_t out[], size_t out_bytes, const std::vector&lt; T, Alloc &gt; &amp;in)</td></tr>
<tr class="separator:a50163d1f1821b426712ed51ea5f55f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9bf025334b7c74a6c14addbd481577"><td class="memItemLeft" align="right" valign="top"><a id="aac9bf025334b7c74a6c14addbd481577"></a>
BOTAN_MALLOC_FN void *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate_memory</b> (size_t elems, size_t elem_size)</td></tr>
<tr class="separator:aac9bf025334b7c74a6c14addbd481577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46524142ffdc0dfeb7c58611b9e0046d"><td class="memItemLeft" align="right" valign="top"><a id="a46524142ffdc0dfeb7c58611b9e0046d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_memory</b> (void *p, size_t elems, size_t elem_size)</td></tr>
<tr class="separator:a46524142ffdc0dfeb7c58611b9e0046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c191055a4f5a2dba6bfde0e8056eaab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a5c191055a4f5a2dba6bfde0e8056eaab">initialize_allocator</a> ()</td></tr>
<tr class="separator:a5c191055a4f5a2dba6bfde0e8056eaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8715d6667de5be024045dd6f4f53094e"><td class="memItemLeft" align="right" valign="top"><a id="a8715d6667de5be024045dd6f4f53094e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>constant_time_compare</b> (const uint8_t x[], const uint8_t y[], size_t len)</td></tr>
<tr class="separator:a8715d6667de5be024045dd6f4f53094e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce0c066e1e47c17c9ed2d4c5ae35b34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a7ce0c066e1e47c17c9ed2d4c5ae35b34">clear_bytes</a> (void *ptr, size_t bytes)</td></tr>
<tr class="separator:a7ce0c066e1e47c17c9ed2d4c5ae35b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6cf2051aa89f9d76cf4d55c126b314"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb6cf2051aa89f9d76cf4d55c126b314"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aeb6cf2051aa89f9d76cf4d55c126b314">clear_mem</a> (T *ptr, size_t n)</td></tr>
<tr class="separator:aeb6cf2051aa89f9d76cf4d55c126b314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dcdaaa3ce9b5c1025d32be2594b2de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81dcdaaa3ce9b5c1025d32be2594b2de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a81dcdaaa3ce9b5c1025d32be2594b2de">copy_mem</a> (T *out, const T *in, size_t n)</td></tr>
<tr class="separator:a81dcdaaa3ce9b5c1025d32be2594b2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace49e77ed072090e3a7df831742981a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace49e77ed072090e3a7df831742981a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ace49e77ed072090e3a7df831742981a6">set_mem</a> (T *ptr, size_t n, uint8_t val)</td></tr>
<tr class="separator:ace49e77ed072090e3a7df831742981a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deb698938556129dbf3e1d6ca7d1fb2"><td class="memItemLeft" align="right" valign="top"><a id="a1deb698938556129dbf3e1d6ca7d1fb2"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>cast_char_ptr_to_uint8</b> (const char *s)</td></tr>
<tr class="separator:a1deb698938556129dbf3e1d6ca7d1fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0494ff2de8a6d21cc45d6460c3ba6242"><td class="memItemLeft" align="right" valign="top"><a id="a0494ff2de8a6d21cc45d6460c3ba6242"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>cast_uint8_ptr_to_char</b> (const uint8_t *b)</td></tr>
<tr class="separator:a0494ff2de8a6d21cc45d6460c3ba6242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81ace2e0e08f4fe29255708450c82de"><td class="memItemLeft" align="right" valign="top"><a id="ae81ace2e0e08f4fe29255708450c82de"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>cast_char_ptr_to_uint8</b> (char *s)</td></tr>
<tr class="separator:ae81ace2e0e08f4fe29255708450c82de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db9e3bf2de4699653f4308ec0ad6f11"><td class="memItemLeft" align="right" valign="top"><a id="a1db9e3bf2de4699653f4308ec0ad6f11"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>cast_uint8_ptr_to_char</b> (uint8_t *b)</td></tr>
<tr class="separator:a1db9e3bf2de4699653f4308ec0ad6f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf9f9ec7cd1cb34fa0a9b98592fcb84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abaf9f9ec7cd1cb34fa0a9b98592fcb84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#abaf9f9ec7cd1cb34fa0a9b98592fcb84">same_mem</a> (const T *p1, const T *p2, size_t n)</td></tr>
<tr class="separator:abaf9f9ec7cd1cb34fa0a9b98592fcb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8197d5fc973d59ae216ca5f865be55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a9c8197d5fc973d59ae216ca5f865be55">xor_buf</a> (uint8_t out[], const uint8_t in[], size_t length)</td></tr>
<tr class="separator:a9c8197d5fc973d59ae216ca5f865be55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f27789ca2bd6074362a06f2ee5bea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a47f27789ca2bd6074362a06f2ee5bea4">xor_buf</a> (uint8_t out[], const uint8_t in[], const uint8_t in2[], size_t length)</td></tr>
<tr class="separator:a47f27789ca2bd6074362a06f2ee5bea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad250255def82fb51f03f1ffd85dcf494"><td class="memTemplParams" colspan="2"><a id="ad250255def82fb51f03f1ffd85dcf494"></a>
template&lt;typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:ad250255def82fb51f03f1ffd85dcf494"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xor_buf</b> (std::vector&lt; uint8_t, Alloc &gt; &amp;out, const std::vector&lt; uint8_t, Alloc2 &gt; &amp;in, size_t n)</td></tr>
<tr class="separator:ad250255def82fb51f03f1ffd85dcf494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18642b9fd664c941c69a454f3cfab55d"><td class="memTemplParams" colspan="2"><a id="a18642b9fd664c941c69a454f3cfab55d"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a18642b9fd664c941c69a454f3cfab55d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xor_buf</b> (std::vector&lt; uint8_t, Alloc &gt; &amp;out, const uint8_t *in, size_t n)</td></tr>
<tr class="separator:a18642b9fd664c941c69a454f3cfab55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd935f4fd84f069c075d98ca62c02df"><td class="memTemplParams" colspan="2"><a id="a4bd935f4fd84f069c075d98ca62c02df"></a>
template&lt;typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:a4bd935f4fd84f069c075d98ca62c02df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xor_buf</b> (std::vector&lt; uint8_t, Alloc &gt; &amp;out, const uint8_t *in, const std::vector&lt; uint8_t, Alloc2 &gt; &amp;in2, size_t n)</td></tr>
<tr class="separator:a4bd935f4fd84f069c075d98ca62c02df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe264cb81bc30a2cd69ee3db85bf8abc"><td class="memTemplParams" colspan="2"><a id="afe264cb81bc30a2cd69ee3db85bf8abc"></a>
template&lt;typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:afe264cb81bc30a2cd69ee3db85bf8abc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint8_t, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^=</b> (std::vector&lt; uint8_t, Alloc &gt; &amp;out, const std::vector&lt; uint8_t, Alloc2 &gt; &amp;in)</td></tr>
<tr class="separator:afe264cb81bc30a2cd69ee3db85bf8abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0da4682632518b5b7b11848dc3025e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ad0da4682632518b5b7b11848dc3025e3">mul64x64_128</a> (uint64_t a, uint64_t b, uint64_t *lo, uint64_t *hi)</td></tr>
<tr class="separator:ad0da4682632518b5b7b11848dc3025e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9d7a12e61c008ead17aa997a121020"><td class="memItemLeft" align="right" valign="top"><a id="a7a9d7a12e61c008ead17aa997a121020"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>secure_scrub_memory</b> (void *ptr, size_t n)</td></tr>
<tr class="separator:a7a9d7a12e61c008ead17aa997a121020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569c3390529abdde0f41162d3af6d8d5"><td class="memItemLeft" align="right" valign="top"><a id="a569c3390529abdde0f41162d3af6d8d5"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>to_uint16</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a569c3390529abdde0f41162d3af6d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34b62eb5711af655eaf6889be49f108"><td class="memItemLeft" align="right" valign="top"><a id="ad34b62eb5711af655eaf6889be49f108"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>to_u32bit</b> (const std::string &amp;str)</td></tr>
<tr class="separator:ad34b62eb5711af655eaf6889be49f108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797fe83136c7523933875d2e7e71c380"><td class="memItemLeft" align="right" valign="top"><a id="a797fe83136c7523933875d2e7e71c380"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>timespec_to_u32bit</b> (const std::string &amp;timespec)</td></tr>
<tr class="separator:a797fe83136c7523933875d2e7e71c380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cc9f5ed57c7080bf5a552272609b2d"><td class="memItemLeft" align="right" valign="top"><a id="a58cc9f5ed57c7080bf5a552272609b2d"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_algorithm_name</b> (const std::string &amp;namex)</td></tr>
<tr class="separator:a58cc9f5ed57c7080bf5a552272609b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990f90d949cb747ca2c37c32957ed723"><td class="memItemLeft" align="right" valign="top"><a id="a990f90d949cb747ca2c37c32957ed723"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split_on</b> (const std::string &amp;str, char delim)</td></tr>
<tr class="separator:a990f90d949cb747ca2c37c32957ed723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd72f77956785fe39bc89a515267cb4a"><td class="memItemLeft" align="right" valign="top"><a id="acd72f77956785fe39bc89a515267cb4a"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split_on_pred</b> (const std::string &amp;str, std::function&lt; bool(char)&gt; pred)</td></tr>
<tr class="separator:acd72f77956785fe39bc89a515267cb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffe6aa56dd7683af8e6408daf290312"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a8ffe6aa56dd7683af8e6408daf290312">string_join</a> (const std::vector&lt; std::string &gt; &amp;strs, char delim)</td></tr>
<tr class="separator:a8ffe6aa56dd7683af8e6408daf290312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba74175ae95ba1a96e0d99f52539c71"><td class="memItemLeft" align="right" valign="top"><a id="a4ba74175ae95ba1a96e0d99f52539c71"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parse_asn1_oid</b> (const std::string &amp;oid)</td></tr>
<tr class="separator:a4ba74175ae95ba1a96e0d99f52539c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8509bd05c79dd4ea42fda5448fda5b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ab8509bd05c79dd4ea42fda5448fda5b5">x500_name_cmp</a> (const std::string &amp;name1, const std::string &amp;name2)</td></tr>
<tr class="separator:ab8509bd05c79dd4ea42fda5448fda5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf1791d95dced481a307040ea39ddf5"><td class="memItemLeft" align="right" valign="top"><a id="a2cf1791d95dced481a307040ea39ddf5"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>string_to_ipv4</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a2cf1791d95dced481a307040ea39ddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0b80d2876f40365dcf5f8d6538aaeb"><td class="memItemLeft" align="right" valign="top"><a id="acf0b80d2876f40365dcf5f8d6538aaeb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>ipv4_to_string</b> (uint32_t ip)</td></tr>
<tr class="separator:acf0b80d2876f40365dcf5f8d6538aaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c25f0333e84e5540be288b4298b766"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a27c25f0333e84e5540be288b4298b766">erase_chars</a> (const std::string &amp;str, const std::set&lt; char &gt; &amp;chars)</td></tr>
<tr class="separator:a27c25f0333e84e5540be288b4298b766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64033c1b7127eae1491a8eadd11d1ecb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a64033c1b7127eae1491a8eadd11d1ecb">replace_chars</a> (const std::string &amp;str, const std::set&lt; char &gt; &amp;chars, char to_char)</td></tr>
<tr class="separator:a64033c1b7127eae1491a8eadd11d1ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292061a5124df501cb59c2f899f78235"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a292061a5124df501cb59c2f899f78235">replace_char</a> (const std::string &amp;str, char from_char, char to_char)</td></tr>
<tr class="separator:a292061a5124df501cb59c2f899f78235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91221a7e967f5c50667b8a2ba06971f"><td class="memItemLeft" align="right" valign="top"><a id="ae91221a7e967f5c50667b8a2ba06971f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>host_wildcard_match</b> (const std::string &amp;issued_, const std::string &amp;host_)</td></tr>
<tr class="separator:ae91221a7e967f5c50667b8a2ba06971f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e26a43fb6d797b11b9ef9f8e9721c01"><td class="memItemLeft" align="right" valign="top"><a id="a7e26a43fb6d797b11b9ef9f8e9721c01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>poly_double_n</b> (uint8_t out[], const uint8_t in[], size_t n)</td></tr>
<tr class="separator:a7e26a43fb6d797b11b9ef9f8e9721c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db9fae4308d34b2bc1060f839cbcab3"><td class="memItemLeft" align="right" valign="top"><a id="a3db9fae4308d34b2bc1060f839cbcab3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>poly_double_n_le</b> (uint8_t out[], const uint8_t in[], size_t n)</td></tr>
<tr class="separator:a3db9fae4308d34b2bc1060f839cbcab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10f56ac44d39dac92ae756ff4c26510"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ae10f56ac44d39dac92ae756ff4c26510">poly_double_supported_size</a> (size_t n)</td></tr>
<tr class="separator:ae10f56ac44d39dac92ae756ff4c26510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153cab9476e6f8df0c39e63260293c69"><td class="memItemLeft" align="right" valign="top"><a id="a153cab9476e6f8df0c39e63260293c69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>poly_double_n</b> (uint8_t buf[], size_t n)</td></tr>
<tr class="separator:a153cab9476e6f8df0c39e63260293c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98d079fc4312757f211acddb232e331"><td class="memTemplParams" colspan="2"><a id="ac98d079fc4312757f211acddb232e331"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac98d079fc4312757f211acddb232e331"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prefetch_readonly</b> (const T *addr, size_t length)</td></tr>
<tr class="separator:ac98d079fc4312757f211acddb232e331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9230581f5ab62707c5de29728b2812ad"><td class="memTemplParams" colspan="2"><a id="a9230581f5ab62707c5de29728b2812ad"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9230581f5ab62707c5de29728b2812ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prefetch_readwrite</b> (const T *addr, size_t length)</td></tr>
<tr class="separator:a9230581f5ab62707c5de29728b2812ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c9e78e8a758e7c4d3c9eec7bd1840e"><td class="memItemLeft" align="right" valign="top"><a id="a79c9e78e8a758e7c4d3c9eec7bd1840e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>clean_ws</b> (const std::string &amp;s)</td></tr>
<tr class="separator:a79c9e78e8a758e7c4d3c9eec7bd1840e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fae404a7cc8f1c2b871ec5164924717"><td class="memItemLeft" align="right" valign="top"><a id="a9fae404a7cc8f1c2b871ec5164924717"></a>
std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>read_cfg</b> (std::istream &amp;is)</td></tr>
<tr class="separator:a9fae404a7cc8f1c2b871ec5164924717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758ab665e39164e5554c7e051dde0a3e"><td class="memItemLeft" align="right" valign="top"><a id="a758ab665e39164e5554c7e051dde0a3e"></a>
std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>read_kv</b> (const std::string &amp;kv)</td></tr>
<tr class="separator:a758ab665e39164e5554c7e051dde0a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a31a219cbddcbfcb2f6fc770fcaed4"><td class="memTemplParams" colspan="2">template&lt;size_t ROT, typename T &gt; </td></tr>
<tr class="memitem:a08a31a219cbddcbfcb2f6fc770fcaed4"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a08a31a219cbddcbfcb2f6fc770fcaed4">rotl</a> (T input)</td></tr>
<tr class="separator:a08a31a219cbddcbfcb2f6fc770fcaed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada30f39e9838317878d9da1e095bdfe8"><td class="memTemplParams" colspan="2">template&lt;size_t ROT, typename T &gt; </td></tr>
<tr class="memitem:ada30f39e9838317878d9da1e095bdfe8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ada30f39e9838317878d9da1e095bdfe8">rotr</a> (T input)</td></tr>
<tr class="separator:ada30f39e9838317878d9da1e095bdfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3ac5eb5fe20890242666142e72a8f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e3ac5eb5fe20890242666142e72a8f6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a2e3ac5eb5fe20890242666142e72a8f6">rotl_var</a> (T input, size_t rot)</td></tr>
<tr class="separator:a2e3ac5eb5fe20890242666142e72a8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58d929c7e8f311bc908091212d969dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae58d929c7e8f311bc908091212d969dd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ae58d929c7e8f311bc908091212d969dd">rotr_var</a> (T input, size_t rot)</td></tr>
<tr class="separator:ae58d929c7e8f311bc908091212d969dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad6271f1241d151d1fe3a1af743779c"><td class="memTemplParams" colspan="2"><a id="a6ad6271f1241d151d1fe3a1af743779c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ad6271f1241d151d1fe3a1af743779c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rotate_left</b> (T input, size_t rot)</td></tr>
<tr class="separator:a6ad6271f1241d151d1fe3a1af743779c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ca235c27bdd517ad57cb4aceedc293"><td class="memTemplParams" colspan="2"><a id="a61ca235c27bdd517ad57cb4aceedc293"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61ca235c27bdd517ad57cb4aceedc293"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rotate_right</b> (T input, size_t rot)</td></tr>
<tr class="separator:a61ca235c27bdd517ad57cb4aceedc293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02949267c5d95ff4e34cb64c5404a4f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#af02949267c5d95ff4e34cb64c5404a4f">round_up</a> (size_t n, size_t align_to)</td></tr>
<tr class="separator:af02949267c5d95ff4e34cb64c5404a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4595be1d36c60aea04cc4fad870956a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4595be1d36c60aea04cc4fad870956a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a4595be1d36c60aea04cc4fad870956a3">round_down</a> (T n, T align_to)</td></tr>
<tr class="separator:a4595be1d36c60aea04cc4fad870956a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7c302096cd87d7a8a12d6038260206"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a9c7c302096cd87d7a8a12d6038260206">clamp</a> (size_t n, size_t lower_bound, size_t upper_bound)</td></tr>
<tr class="separator:a9c7c302096cd87d7a8a12d6038260206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75a40ef6a77466c684ada94014632e3"><td class="memItemLeft" align="right" valign="top"><a id="af75a40ef6a77466c684ada94014632e3"></a>
class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) Integer_Overflow_Detected final size_t&#160;</td><td class="memItemRight" valign="bottom"><b>checked_add</b> (size_t x, size_t y, const char *file, int line)</td></tr>
<tr class="separator:af75a40ef6a77466c684ada94014632e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3811c4287a0d079ec6e9b410972e9143"><td class="memTemplParams" colspan="2"><a id="a3811c4287a0d079ec6e9b410972e9143"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a3811c4287a0d079ec6e9b410972e9143"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_botan_1_1stl_compatibility_details_1_1___unique__if.html">stlCompatibilityDetails::_Unique_if</a>&lt; T &gt;::_Single_object&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a3811c4287a0d079ec6e9b410972e9143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c08c160dffb172a0d2d9bf337f1f199"><td class="memTemplParams" colspan="2"><a id="a4c08c160dffb172a0d2d9bf337f1f199"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4c08c160dffb172a0d2d9bf337f1f199"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_botan_1_1stl_compatibility_details_1_1___unique__if.html">stlCompatibilityDetails::_Unique_if</a>&lt; T &gt;::_Unknown_bound&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (size_t n)</td></tr>
<tr class="separator:a4c08c160dffb172a0d2d9bf337f1f199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180599704059ab6286b035d87dbbeb89"><td class="memTemplParams" colspan="2"><a id="a180599704059ab6286b035d87dbbeb89"></a>
template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:a180599704059ab6286b035d87dbbeb89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_botan_1_1stl_compatibility_details_1_1___unique__if.html">stlCompatibilityDetails::_Unique_if</a>&lt; T &gt;::_Known_bound&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (Args &amp;&amp;...)=delete</td></tr>
<tr class="separator:a180599704059ab6286b035d87dbbeb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3554f55aa9609c63cd1ee4a2cb6f64a"><td class="memItemLeft" align="right" valign="top"><a id="ae3554f55aa9609c63cd1ee4a2cb6f64a"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>to_byte_vector</b> (const std::string &amp;s)</td></tr>
<tr class="separator:ae3554f55aa9609c63cd1ee4a2cb6f64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac536c375ee44ac6b91f70599afe52890"><td class="memItemLeft" align="right" valign="top"><a id="ac536c375ee44ac6b91f70599afe52890"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const secure_vector&lt; uint8_t &gt; &amp;bytes)</td></tr>
<tr class="separator:ac536c375ee44ac6b91f70599afe52890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967fe441532a76e590a656bb8b9f177a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a967fe441532a76e590a656bb8b9f177a"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a967fe441532a76e590a656bb8b9f177a">map_keys_as_set</a> (const std::map&lt; K, V &gt; &amp;kv)</td></tr>
<tr class="separator:a967fe441532a76e590a656bb8b9f177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858054ae4327d92f5e308fd10e9d751b"><td class="memTemplParams" colspan="2"><a id="a858054ae4327d92f5e308fd10e9d751b"></a>
template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a858054ae4327d92f5e308fd10e9d751b"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><b>search_map</b> (const std::map&lt; K, V &gt; &amp;mapping, const K &amp;key, const V &amp;null_result=V())</td></tr>
<tr class="separator:a858054ae4327d92f5e308fd10e9d751b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659beb72cc59a86c87a51b0497e840fb"><td class="memTemplParams" colspan="2"><a id="a659beb72cc59a86c87a51b0497e840fb"></a>
template&lt;typename K , typename V , typename R &gt; </td></tr>
<tr class="memitem:a659beb72cc59a86c87a51b0497e840fb"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><b>search_map</b> (const std::map&lt; K, V &gt; &amp;mapping, const K &amp;key, const R &amp;null_result, const R &amp;found_result)</td></tr>
<tr class="separator:a659beb72cc59a86c87a51b0497e840fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0b92bc1b95cf67b1367760c054c45d"><td class="memTemplParams" colspan="2"><a id="aab0b92bc1b95cf67b1367760c054c45d"></a>
template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:aab0b92bc1b95cf67b1367760c054c45d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multimap_insert</b> (std::multimap&lt; K, V &gt; &amp;multimap, const K &amp;key, const V &amp;value)</td></tr>
<tr class="separator:aab0b92bc1b95cf67b1367760c054c45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62a85e0371b9210c98d9dcdb1632502"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae62a85e0371b9210c98d9dcdb1632502"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ae62a85e0371b9210c98d9dcdb1632502">value_exists</a> (const std::vector&lt; T &gt; &amp;vec, const T &amp;val)</td></tr>
<tr class="separator:ae62a85e0371b9210c98d9dcdb1632502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e90f6d45c94fd60b3b4ad3fcf457508"><td class="memTemplParams" colspan="2"><a id="a0e90f6d45c94fd60b3b4ad3fcf457508"></a>
template&lt;typename T , typename Pred &gt; </td></tr>
<tr class="memitem:a0e90f6d45c94fd60b3b4ad3fcf457508"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_remove_if</b> (Pred pred, T &amp;assoc)</td></tr>
<tr class="separator:a0e90f6d45c94fd60b3b4ad3fcf457508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0321566cb255f655d8d196cdc547c8"><td class="memItemLeft" align="right" valign="top"><a id="afd0321566cb255f655d8d196cdc547c8"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>short_version_cstr</b> ()</td></tr>
<tr class="separator:afd0321566cb255f655d8d196cdc547c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76f5efd521654961c45ff6d676a2608"><td class="memItemLeft" align="right" valign="top"><a id="af76f5efd521654961c45ff6d676a2608"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>version_cstr</b> ()</td></tr>
<tr class="separator:af76f5efd521654961c45ff6d676a2608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214423710ee97e9eaa5b2260356995b6"><td class="memItemLeft" align="right" valign="top"><a id="a214423710ee97e9eaa5b2260356995b6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>version_string</b> ()</td></tr>
<tr class="separator:a214423710ee97e9eaa5b2260356995b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c2cef7dc1d6a5d05dfc8b4e68efcc3"><td class="memItemLeft" align="right" valign="top"><a id="a86c2cef7dc1d6a5d05dfc8b4e68efcc3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>short_version_string</b> ()</td></tr>
<tr class="separator:a86c2cef7dc1d6a5d05dfc8b4e68efcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6667e739f26d272b330e17c8023e8913"><td class="memItemLeft" align="right" valign="top"><a id="a6667e739f26d272b330e17c8023e8913"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>version_datestamp</b> ()</td></tr>
<tr class="separator:a6667e739f26d272b330e17c8023e8913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2a4f21fc240907844e0f10643c496c"><td class="memItemLeft" align="right" valign="top"><a id="a4c2a4f21fc240907844e0f10643c496c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>version_major</b> ()</td></tr>
<tr class="separator:a4c2a4f21fc240907844e0f10643c496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157480114501d38de19e9266002806fc"><td class="memItemLeft" align="right" valign="top"><a id="a157480114501d38de19e9266002806fc"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>version_minor</b> ()</td></tr>
<tr class="separator:a157480114501d38de19e9266002806fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b0472a86fe8d3228073bac60050fbf"><td class="memItemLeft" align="right" valign="top"><a id="a82b0472a86fe8d3228073bac60050fbf"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>version_patch</b> ()</td></tr>
<tr class="separator:a82b0472a86fe8d3228073bac60050fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb7d85a37397c79756994a32b1bc1c7"><td class="memItemLeft" align="right" valign="top"><a id="abbb7d85a37397c79756994a32b1bc1c7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>runtime_version_check</b> (uint32_t major, uint32_t minor, uint32_t patch)</td></tr>
<tr class="separator:abbb7d85a37397c79756994a32b1bc1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ff2944d16eb3bbc4d99b15b6b78535"><td class="memItemLeft" align="right" valign="top"><a id="a06ff2944d16eb3bbc4d99b15b6b78535"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (<a class="el" href="namespace_botan.html#ae1e907dc90937bdda30f65216e68ff2b">Certificate_Status_Code</a> code)</td></tr>
<tr class="separator:a06ff2944d16eb3bbc4d99b15b6b78535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5301bd6dfea11cd549515c147ce4c5b8"><td class="memItemLeft" align="right" valign="top"><a id="a5301bd6dfea11cd549515c147ce4c5b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const CRL_Entry &amp;a1, const CRL_Entry &amp;a2)</td></tr>
<tr class="separator:a5301bd6dfea11cd549515c147ce4c5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99452f758ce96d50c8e1a3fd2db8bdc7"><td class="memItemLeft" align="right" valign="top"><a id="a99452f758ce96d50c8e1a3fd2db8bdc7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const CRL_Entry &amp;a1, const CRL_Entry &amp;a2)</td></tr>
<tr class="separator:a99452f758ce96d50c8e1a3fd2db8bdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6359ea952d0cd62ed00fff23910582e"><td class="memItemLeft" align="right" valign="top"><a id="ac6359ea952d0cd62ed00fff23910582e"></a>
X509_DN&#160;</td><td class="memItemRight" valign="bottom"><b>create_dn</b> (const <a class="el" href="class_botan_1_1_data___store.html">Data_Store</a> &amp;info)</td></tr>
<tr class="separator:ac6359ea952d0cd62ed00fff23910582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf02382223699812ff0016f84f9a891f"><td class="memItemLeft" align="right" valign="top"><a id="acf02382223699812ff0016f84f9a891f"></a>
AlternativeName&#160;</td><td class="memItemRight" valign="bottom"><b>create_alt_name</b> (const <a class="el" href="class_botan_1_1_data___store.html">Data_Store</a> &amp;info)</td></tr>
<tr class="separator:acf02382223699812ff0016f84f9a891f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71f0693cc57262f82c2f2a1813e313d"><td class="memItemLeft" align="right" valign="top"><a id="af71f0693cc57262f82c2f2a1813e313d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>key_constraints_to_string</b> (<a class="el" href="namespace_botan.html#aed0885e5c70627dd43827b966e727654">Key_Constraints</a> constraints)</td></tr>
<tr class="separator:af71f0693cc57262f82c2f2a1813e313d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef993c01e4888e4dd28dbb5f2bf2d21"><td class="memItemLeft" align="right" valign="top"><a id="adef993c01e4888e4dd28dbb5f2bf2d21"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>verify_cert_constraints_valid_for_key_type</b> (const Public_Key &amp;pub_key, <a class="el" href="namespace_botan.html#aed0885e5c70627dd43827b966e727654">Key_Constraints</a> constraints)</td></tr>
<tr class="separator:adef993c01e4888e4dd28dbb5f2bf2d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253008bbfcdaedb01ffa8cc88fd1b168"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a253008bbfcdaedb01ffa8cc88fd1b168">operator&lt;&lt;</a> (std::ostream &amp;os, const GeneralName &amp;gn)</td></tr>
<tr class="memdesc:a253008bbfcdaedb01ffa8cc88fd1b168"><td class="mdescLeft">&#160;</td><td class="mdescRight">X.509 GeneralName Type.  <a href="#a253008bbfcdaedb01ffa8cc88fd1b168">More...</a><br /></td></tr>
<tr class="separator:a253008bbfcdaedb01ffa8cc88fd1b168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4139683b6cc649ac5a8b6da64dcd60c8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a4139683b6cc649ac5a8b6da64dcd60c8">operator&lt;&lt;</a> (std::ostream &amp;os, const GeneralSubtree &amp;gs)</td></tr>
<tr class="memdesc:a4139683b6cc649ac5a8b6da64dcd60c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single Name Constraint.  <a href="#a4139683b6cc649ac5a8b6da64dcd60c8">More...</a><br /></td></tr>
<tr class="separator:a4139683b6cc649ac5a8b6da64dcd60c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d2bcad93c3e6cf32273640aa741f37"><td class="memItemLeft" align="right" valign="top"><a id="ac8d2bcad93c3e6cf32273640aa741f37"></a>
PK_Signer *&#160;</td><td class="memItemRight" valign="bottom"><b>choose_sig_format</b> (const Private_Key &amp;key, RandomNumberGenerator &amp;rng, const std::string &amp;hash_fn, AlgorithmIdentifier &amp;sig_algo)</td></tr>
<tr class="separator:ac8d2bcad93c3e6cf32273640aa741f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7eef69e50c79362b967f2c4f81a377"><td class="memItemLeft" align="right" valign="top">PK_Signer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a0e7eef69e50c79362b967f2c4f81a377">choose_sig_format</a> (const Private_Key &amp;key, const std::map&lt; std::string, std::string &gt; &amp;opts, RandomNumberGenerator &amp;rng, const std::string &amp;hash_fn, AlgorithmIdentifier &amp;sig_algo)</td></tr>
<tr class="separator:a0e7eef69e50c79362b967f2c4f81a377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad1f31689c39db82eb02a19f651276c"><td class="memItemLeft" align="right" valign="top"><a id="a9ad1f31689c39db82eb02a19f651276c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const X509_DN &amp;dn1, const X509_DN &amp;dn2)</td></tr>
<tr class="separator:a9ad1f31689c39db82eb02a19f651276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476b8723316dafb87967766b17a8b225"><td class="memItemLeft" align="right" valign="top"><a id="a476b8723316dafb87967766b17a8b225"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const X509_DN &amp;dn1, const X509_DN &amp;dn2)</td></tr>
<tr class="separator:a476b8723316dafb87967766b17a8b225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bb7e22006211397839397df0d6c89d"><td class="memItemLeft" align="right" valign="top"><a id="a48bb7e22006211397839397df0d6c89d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const X509_DN &amp;dn1, const X509_DN &amp;dn2)</td></tr>
<tr class="separator:a48bb7e22006211397839397df0d6c89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d050440a804945a0f924dcf7e1b2b98"><td class="memItemLeft" align="right" valign="top"><a id="a7d050440a804945a0f924dcf7e1b2b98"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const X509_DN &amp;dn)</td></tr>
<tr class="separator:a7d050440a804945a0f924dcf7e1b2b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3aca29ac12ded8d64510c3dfbf8c45"><td class="memItemLeft" align="right" valign="top"><a id="a1a3aca29ac12ded8d64510c3dfbf8c45"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;in, X509_DN &amp;dn)</td></tr>
<tr class="separator:a1a3aca29ac12ded8d64510c3dfbf8c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7151f34db6b33b3763e5554759e08dec"><td class="memItemLeft" align="right" valign="top"><a id="a7151f34db6b33b3763e5554759e08dec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const X509_Certificate &amp;cert1, const X509_Certificate &amp;cert2)</td></tr>
<tr class="separator:a7151f34db6b33b3763e5554759e08dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f20522071bd2b78c5125c3080f778a"><td class="memItemLeft" align="right" valign="top"><a id="a43f20522071bd2b78c5125c3080f778a"></a>
Path_Validation_Result&#160;</td><td class="memItemRight" valign="bottom"><b>x509_path_validate</b> (const std::vector&lt; X509_Certificate &gt; &amp;end_certs, const Path_Validation_Restrictions &amp;restrictions, const std::vector&lt; Certificate_Store *&gt; &amp;trusted_roots, const std::string &amp;hostname, Usage_Type usage, std::chrono::system_clock::time_point ref_time, std::chrono::milliseconds ocsp_timeout, const std::vector&lt; std::shared_ptr&lt; const OCSP::Response &gt;&gt; &amp;ocsp_resp)</td></tr>
<tr class="separator:a43f20522071bd2b78c5125c3080f778a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5cd06ae0154e1819f39a5a38a9af78"><td class="memItemLeft" align="right" valign="top"><a id="a1a5cd06ae0154e1819f39a5a38a9af78"></a>
Path_Validation_Result&#160;</td><td class="memItemRight" valign="bottom"><b>x509_path_validate</b> (const X509_Certificate &amp;end_cert, const Path_Validation_Restrictions &amp;restrictions, const std::vector&lt; Certificate_Store *&gt; &amp;trusted_roots, const std::string &amp;hostname, Usage_Type usage, std::chrono::system_clock::time_point when, std::chrono::milliseconds ocsp_timeout, const std::vector&lt; std::shared_ptr&lt; const OCSP::Response &gt;&gt; &amp;ocsp_resp)</td></tr>
<tr class="separator:a1a5cd06ae0154e1819f39a5a38a9af78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd1afc7ba4b8847eaf28b6da13fce5e"><td class="memItemLeft" align="right" valign="top"><a id="a1cd1afc7ba4b8847eaf28b6da13fce5e"></a>
Path_Validation_Result&#160;</td><td class="memItemRight" valign="bottom"><b>x509_path_validate</b> (const std::vector&lt; X509_Certificate &gt; &amp;end_certs, const Path_Validation_Restrictions &amp;restrictions, const Certificate_Store &amp;store, const std::string &amp;hostname, Usage_Type usage, std::chrono::system_clock::time_point when, std::chrono::milliseconds ocsp_timeout, const std::vector&lt; std::shared_ptr&lt; const OCSP::Response &gt;&gt; &amp;ocsp_resp)</td></tr>
<tr class="separator:a1cd1afc7ba4b8847eaf28b6da13fce5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047a8a97bebded357efb00ccbb917539"><td class="memItemLeft" align="right" valign="top"><a id="a047a8a97bebded357efb00ccbb917539"></a>
Path_Validation_Result&#160;</td><td class="memItemRight" valign="bottom"><b>x509_path_validate</b> (const X509_Certificate &amp;end_cert, const Path_Validation_Restrictions &amp;restrictions, const Certificate_Store &amp;store, const std::string &amp;hostname, Usage_Type usage, std::chrono::system_clock::time_point when, std::chrono::milliseconds ocsp_timeout, const std::vector&lt; std::shared_ptr&lt; const OCSP::Response &gt;&gt; &amp;ocsp_resp)</td></tr>
<tr class="separator:a047a8a97bebded357efb00ccbb917539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7ed1a645917b63520e98e9ab91aa021e"><td class="memItemLeft" align="right" valign="top"><a id="a7ed1a645917b63520e98e9ab91aa021e"></a>
bool const X509_Time &amp;bool const X509_Time &amp;typedef X509_Time&#160;</td><td class="memItemRight" valign="bottom"><b>ASN1_Time</b></td></tr>
<tr class="separator:a7ed1a645917b63520e98e9ab91aa021e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021ffc520728602cd2f027a40b68bc5f"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) Cipher_Mode_Filter final typedef Cipher_Mode_Filter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a021ffc520728602cd2f027a40b68bc5f">Transform_Filter</a></td></tr>
<tr class="separator:a021ffc520728602cd2f027a40b68bc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aedf36a60e3180255517925fa25efca"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) SHA_160 final typedef SHA_160&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a7aedf36a60e3180255517925fa25efca">SHA_1</a></td></tr>
<tr class="separator:a7aedf36a60e3180255517925fa25efca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9020384b0dc79f1bc8dcc59d5ee6fc"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) MessageAuthenticationCode typedef MessageAuthenticationCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#aad9020384b0dc79f1bc8dcc59d5ee6fc">MAC</a></td></tr>
<tr class="separator:aad9020384b0dc79f1bc8dcc59d5ee6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3375bcbe930557f2b1cd206c0f5cf43b"><td class="memItemLeft" align="right" valign="top"><a id="a3375bcbe930557f2b1cd206c0f5cf43b"></a>
class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) Curve25519_PublicKey class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) Curve25519_PrivateKey final typedef Curve25519_PublicKey&#160;</td><td class="memItemRight" valign="bottom"><b>X25519_PublicKey</b></td></tr>
<tr class="separator:a3375bcbe930557f2b1cd206c0f5cf43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137fc6f2c61b1ee506513b92b09618c6"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) Private_Key class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) PK_Key_Agreement_Key typedef PK_Key_Agreement_Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a137fc6f2c61b1ee506513b92b09618c6">PK_KA_Key</a></td></tr>
<tr class="separator:a137fc6f2c61b1ee506513b92b09618c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208fee569d7b08fa981f19dfea0cec43"><td class="memItemLeft" align="right" valign="top"><a id="a208fee569d7b08fa981f19dfea0cec43"></a>
class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) OID final OID uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>new_comp</b></td></tr>
<tr class="separator:a208fee569d7b08fa981f19dfea0cec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377230281adf76b940163a9b9336a5df"><td class="memItemLeft" align="right" valign="top"><a id="a377230281adf76b940163a9b9336a5df"></a>
bool const OID &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>b</b></td></tr>
<tr class="separator:a377230281adf76b940163a9b9336a5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae07b13b8c62b093ca774a163c7fd69"><td class="memItemLeft" align="right" valign="top"><a id="afae07b13b8c62b093ca774a163c7fd69"></a>
const OctetString &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>y</b></td></tr>
<tr class="separator:afae07b13b8c62b093ca774a163c7fd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bc7086bfb043dc03306af8c7860bba"><td class="memItemLeft" align="right" valign="top"><a id="a72bc7086bfb043dc03306af8c7860bba"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>CAST_SBOX1</b> [256]</td></tr>
<tr class="separator:a72bc7086bfb043dc03306af8c7860bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb279ea8bbf721383d7947680eabfcfb"><td class="memItemLeft" align="right" valign="top"><a id="abb279ea8bbf721383d7947680eabfcfb"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>CAST_SBOX2</b> [256]</td></tr>
<tr class="separator:abb279ea8bbf721383d7947680eabfcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef142127d5d4ade45ca1aea3a850db58"><td class="memItemLeft" align="right" valign="top"><a id="aef142127d5d4ade45ca1aea3a850db58"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>CAST_SBOX3</b> [256]</td></tr>
<tr class="separator:aef142127d5d4ade45ca1aea3a850db58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ba2699c0070b79b152f2074af6b515"><td class="memItemLeft" align="right" valign="top"><a id="a97ba2699c0070b79b152f2074af6b515"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>CAST_SBOX4</b> [256]</td></tr>
<tr class="separator:a97ba2699c0070b79b152f2074af6b515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f2122e900d9b65e6c949734915b67b"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) DES final class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) TripleDES final const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#ad1f2122e900d9b65e6c949734915b67b">DES_SPBOX1</a> [256]</td></tr>
<tr class="separator:ad1f2122e900d9b65e6c949734915b67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbad125410a71678b33cb844ab4dc5a"><td class="memItemLeft" align="right" valign="top"><a id="abbbad125410a71678b33cb844ab4dc5a"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_SPBOX2</b> [256]</td></tr>
<tr class="separator:abbbad125410a71678b33cb844ab4dc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8da1406c1c3f673bd2273ab1af44df1"><td class="memItemLeft" align="right" valign="top"><a id="ae8da1406c1c3f673bd2273ab1af44df1"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_SPBOX3</b> [256]</td></tr>
<tr class="separator:ae8da1406c1c3f673bd2273ab1af44df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb25d35297d8a2e79df6ee388a6fd506"><td class="memItemLeft" align="right" valign="top"><a id="acb25d35297d8a2e79df6ee388a6fd506"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_SPBOX4</b> [256]</td></tr>
<tr class="separator:acb25d35297d8a2e79df6ee388a6fd506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5af59af486d0e3e7c2e187724eca4b0"><td class="memItemLeft" align="right" valign="top"><a id="ad5af59af486d0e3e7c2e187724eca4b0"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_SPBOX5</b> [256]</td></tr>
<tr class="separator:ad5af59af486d0e3e7c2e187724eca4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f93626374f9bd282830da5827345b2"><td class="memItemLeft" align="right" valign="top"><a id="a94f93626374f9bd282830da5827345b2"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_SPBOX6</b> [256]</td></tr>
<tr class="separator:a94f93626374f9bd282830da5827345b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97d7a8c2f627a9379ab5b1f81ace0f0"><td class="memItemLeft" align="right" valign="top"><a id="ab97d7a8c2f627a9379ab5b1f81ace0f0"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_SPBOX7</b> [256]</td></tr>
<tr class="separator:ab97d7a8c2f627a9379ab5b1f81ace0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef346c6a30c037befc1699999530072a"><td class="memItemLeft" align="right" valign="top"><a id="aef346c6a30c037befc1699999530072a"></a>
const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_SPBOX8</b> [256]</td></tr>
<tr class="separator:aef346c6a30c037befc1699999530072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab279cbe8ec42f623426d4f223953cdc7"><td class="memItemLeft" align="right" valign="top"><a id="ab279cbe8ec42f623426d4f223953cdc7"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_IPTAB1</b> [256]</td></tr>
<tr class="separator:ab279cbe8ec42f623426d4f223953cdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6e9fb2eaeadeb6f85b334ebacea563"><td class="memItemLeft" align="right" valign="top"><a id="acd6e9fb2eaeadeb6f85b334ebacea563"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_IPTAB2</b> [256]</td></tr>
<tr class="separator:acd6e9fb2eaeadeb6f85b334ebacea563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d69cd78bec2e314f30fdfe36daad938"><td class="memItemLeft" align="right" valign="top"><a id="a2d69cd78bec2e314f30fdfe36daad938"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_FPTAB1</b> [256]</td></tr>
<tr class="separator:a2d69cd78bec2e314f30fdfe36daad938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4187c04ce9b6d87f0656aa678c228bef"><td class="memItemLeft" align="right" valign="top"><a id="a4187c04ce9b6d87f0656aa678c228bef"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>DES_FPTAB2</b> [256]</td></tr>
<tr class="separator:a4187c04ce9b6d87f0656aa678c228bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa12eb473d17851eaf0041b4fbf51f5"><td class="memItemLeft" align="right" valign="top"><a id="afaa12eb473d17851eaf0041b4fbf51f5"></a>
size_t const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> []</td></tr>
<tr class="separator:afaa12eb473d17851eaf0041b4fbf51f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257a507d4f39f711164d0034eb76e3fc"><td class="memItemLeft" align="right" valign="top"><a id="a257a507d4f39f711164d0034eb76e3fc"></a>
size_t const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>input_length</b></td></tr>
<tr class="separator:a257a507d4f39f711164d0034eb76e3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557affd0df05877203fcde9e879430e0"><td class="memItemLeft" align="right" valign="top"><a id="a557affd0df05877203fcde9e879430e0"></a>
size_t const uint8_t size_t size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>input_consumed</b></td></tr>
<tr class="separator:a557affd0df05877203fcde9e879430e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359a4639d84ac68c8ba18fa1205285fa"><td class="memItemLeft" align="right" valign="top"><a id="a359a4639d84ac68c8ba18fa1205285fa"></a>
size_t const uint8_t size_t size_t bool&#160;</td><td class="memItemRight" valign="bottom"><b>final_inputs</b></td></tr>
<tr class="separator:a359a4639d84ac68c8ba18fa1205285fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cc94b58e3ee6419d77259d708116df"><td class="memItemLeft" align="right" valign="top"><a id="a98cc94b58e3ee6419d77259d708116df"></a>
size_t const char size_t size_t bool bool&#160;</td><td class="memItemRight" valign="bottom"><b>ignore_ws</b> = true)</td></tr>
<tr class="separator:a98cc94b58e3ee6419d77259d708116df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a3f342c74ac8f571459d0ca7056806"><td class="memItemLeft" align="right" valign="top"><a id="a42a3f342c74ac8f571459d0ca7056806"></a>
void const uint8_t size_t bool&#160;</td><td class="memItemRight" valign="bottom"><b>uppercase</b> = true)</td></tr>
<tr class="separator:a42a3f342c74ac8f571459d0ca7056806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74718b9df0b68e9b2d04755c39d3b55d"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a74718b9df0b68e9b2d04755c39d3b55d">HEX_CODEC_BUFFER_SIZE</a> = 256</td></tr>
<tr class="separator:a74718b9df0b68e9b2d04755c39d3b55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfcbc6518be802679615ad5f56f0874"><td class="memItemLeft" align="right" valign="top"><a id="abcfcbc6518be802679615ad5f56f0874"></a>
int Pipe &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>pipe</b></td></tr>
<tr class="separator:abcfcbc6518be802679615ad5f56f0874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd045a3bc66c6a1ed43fcee59e982a8b"><td class="memItemLeft" align="right" valign="top"><a id="acd045a3bc66c6a1ed43fcee59e982a8b"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>STREEBOG_Ax</b> [8][256]</td></tr>
<tr class="separator:acd045a3bc66c6a1ed43fcee59e982a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482cd2fbd9380730cd034d1843d11197"><td class="memItemLeft" align="right" valign="top"><a id="a482cd2fbd9380730cd034d1843d11197"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>STREEBOG_C</b> [12][8]</td></tr>
<tr class="separator:a482cd2fbd9380730cd034d1843d11197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d9afd937ccb083af5cc0b8b375bdf"><td class="memItemLeft" align="right" valign="top"><a id="a273d9afd937ccb083af5cc0b8b375bdf"></a>
BigInt const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>d</b></td></tr>
<tr class="separator:a273d9afd937ccb083af5cc0b8b375bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af405c5775a4542d37f7f3f532735d18f"><td class="memItemLeft" align="right" valign="top"><a id="af405c5775a4542d37f7f3f532735d18f"></a>
BigInt const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m</b></td></tr>
<tr class="separator:af405c5775a4542d37f7f3f532735d18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f704df25b8e57c03bc8125c1f82f971"><td class="memItemLeft" align="right" valign="top"><a id="a9f704df25b8e57c03bc8125c1f82f971"></a>
BigInt size_t&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="separator:a9f704df25b8e57c03bc8125c1f82f971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe4f8a154009de5159500f03f51432c"><td class="memItemLeft" align="right" valign="top"><a id="affe4f8a154009de5159500f03f51432c"></a>
void const BigInt BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>q</b></td></tr>
<tr class="separator:affe4f8a154009de5159500f03f51432c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebbd9f812be8a3bc0115320e7f7d70d"><td class="memItemLeft" align="right" valign="top"><a id="a5ebbd9f812be8a3bc0115320e7f7d70d"></a>
void const BigInt BigInt BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>r</b></td></tr>
<tr class="separator:a5ebbd9f812be8a3bc0115320e7f7d70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c38d27275dc77ce3ac9b0280398f8a5"><td class="memItemLeft" align="right" valign="top"><a id="a0c38d27275dc77ce3ac9b0280398f8a5"></a>
const word&#160;</td><td class="memItemRight" valign="bottom"><b>MP_WORD_MASK</b> = ~static_cast&lt;word&gt;(0)</td></tr>
<tr class="separator:a0c38d27275dc77ce3ac9b0280398f8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6a2a30f03aae788e45dd0807fb8904"><td class="memItemLeft" align="right" valign="top"><a id="a5f6a2a30f03aae788e45dd0807fb8904"></a>
const word&#160;</td><td class="memItemRight" valign="bottom"><b>MP_WORD_TOP_BIT</b> = static_cast&lt;word&gt;(1) &lt;&lt; (8*sizeof(word) - 1)</td></tr>
<tr class="separator:a5f6a2a30f03aae788e45dd0807fb8904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166ad6dc95d5e2034d9c769b39395626"><td class="memItemLeft" align="right" valign="top"><a id="a166ad6dc95d5e2034d9c769b39395626"></a>
const word&#160;</td><td class="memItemRight" valign="bottom"><b>MP_WORD_MAX</b> = MP_WORD_MASK</td></tr>
<tr class="separator:a166ad6dc95d5e2034d9c769b39395626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9402ed99fea4c227e79749b10505dc4e"><td class="memItemLeft" align="right" valign="top"><a id="a9402ed99fea4c227e79749b10505dc4e"></a>
secure_vector&lt; word &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ws</b></td></tr>
<tr class="separator:a9402ed99fea4c227e79749b10505dc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e64c91f05991b0a02079e0ba3225ff8"><td class="memItemLeft" align="right" valign="top"><a id="a1e64c91f05991b0a02079e0ba3225ff8"></a>
BigInt const BigInt const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>c</b></td></tr>
<tr class="separator:a1e64c91f05991b0a02079e0ba3225ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d69890b04eee09076549d41931e11de"><td class="memItemLeft" align="right" valign="top"><a id="a8d69890b04eee09076549d41931e11de"></a>
BigInt const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>modulus</b></td></tr>
<tr class="separator:a8d69890b04eee09076549d41931e11de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6330856f1c9ef8c750e0c95105b1c79d"><td class="memItemLeft" align="right" valign="top"><a id="a6330856f1c9ef8c750e0c95105b1c79d"></a>
BigInt const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>mod</b></td></tr>
<tr class="separator:a6330856f1c9ef8c750e0c95105b1c79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1e899cf8ed8ddd0da7fbeb49db22fc"><td class="memItemLeft" align="right" valign="top"><a id="a1c1e899cf8ed8ddd0da7fbeb49db22fc"></a>
size_t const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>a</b></td></tr>
<tr class="separator:a1c1e899cf8ed8ddd0da7fbeb49db22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467a48982b88815c38f6fbcc34bfbed0"><td class="memItemLeft" align="right" valign="top"><a id="a467a48982b88815c38f6fbcc34bfbed0"></a>
BigInt const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>x</b></td></tr>
<tr class="separator:a467a48982b88815c38f6fbcc34bfbed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028be10ed8f4f6bd7b8d60b44d8f2a0e"><td class="memItemLeft" align="right" valign="top"><a id="a028be10ed8f4f6bd7b8d60b44d8f2a0e"></a>
BigInt const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>p</b></td></tr>
<tr class="separator:a028be10ed8f4f6bd7b8d60b44d8f2a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f125dc1e7d8d6f9cabe9545402550b"><td class="memItemLeft" align="right" valign="top"><a id="ab4f125dc1e7d8d6f9cabe9545402550b"></a>
bool RandomNumberGenerator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>rng</b></td></tr>
<tr class="separator:ab4f125dc1e7d8d6f9cabe9545402550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827683801983260944f1888096e6c079"><td class="memItemLeft" align="right" valign="top"><a id="a827683801983260944f1888096e6c079"></a>
bool RandomNumberGenerator size_t&#160;</td><td class="memItemRight" valign="bottom"><b>prob</b> = 64</td></tr>
<tr class="separator:a827683801983260944f1888096e6c079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922dfa74ff691f459b48b62c48a72857"><td class="memItemLeft" align="right" valign="top"><a id="a922dfa74ff691f459b48b62c48a72857"></a>
bool RandomNumberGenerator size_t bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_random</b> = false)</td></tr>
<tr class="separator:a922dfa74ff691f459b48b62c48a72857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf847dcf710005795c5bd18dd0c7f3e"><td class="memItemLeft" align="right" valign="top"><a id="acbf847dcf710005795c5bd18dd0c7f3e"></a>
BigInt size_t&#160;</td><td class="memItemRight" valign="bottom"><b>bits</b></td></tr>
<tr class="separator:acbf847dcf710005795c5bd18dd0c7f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cffeb851548753b89d8acdbe2e94ce"><td class="memItemLeft" align="right" valign="top"><a id="a24cffeb851548753b89d8acdbe2e94ce"></a>
BigInt size_t const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>coprime</b> = 0</td></tr>
<tr class="separator:a24cffeb851548753b89d8acdbe2e94ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d098906ac2dd3d1b710dda88847fb7"><td class="memItemLeft" align="right" valign="top"><a id="a52d098906ac2dd3d1b710dda88847fb7"></a>
BigInt size_t const BigInt size_t&#160;</td><td class="memItemRight" valign="bottom"><b>equiv</b> = 1</td></tr>
<tr class="separator:a52d098906ac2dd3d1b710dda88847fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9db11f09f6c81a2a5036c7abf7b1c7"><td class="memItemLeft" align="right" valign="top"><a id="a6e9db11f09f6c81a2a5036c7abf7b1c7"></a>
BigInt size_t const BigInt size_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>equiv_mod</b> = 2</td></tr>
<tr class="separator:a6e9db11f09f6c81a2a5036c7abf7b1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750e5deb1352837f132e0e4cee75db5b"><td class="memItemLeft" align="right" valign="top"><a id="a750e5deb1352837f132e0e4cee75db5b"></a>
BigInt RandomNumberGenerator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>prime_test_rng</b></td></tr>
<tr class="separator:a750e5deb1352837f132e0e4cee75db5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98504c631d16037948bac63e5cdfe09"><td class="memItemLeft" align="right" valign="top"><a id="ab98504c631d16037948bac63e5cdfe09"></a>
std::vector&lt; uint8_t &gt; BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>p_out</b></td></tr>
<tr class="separator:ab98504c631d16037948bac63e5cdfe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8778d0ff7f1f50c83144de7a872895"><td class="memItemLeft" align="right" valign="top"><a id="acf8778d0ff7f1f50c83144de7a872895"></a>
std::vector&lt; uint8_t &gt; BigInt BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>q_out</b></td></tr>
<tr class="separator:acf8778d0ff7f1f50c83144de7a872895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b7dded45bbf408f71819bdaa0c092a"><td class="memItemLeft" align="right" valign="top"><a id="a75b7dded45bbf408f71819bdaa0c092a"></a>
std::vector&lt; uint8_t &gt; BigInt BigInt size_t&#160;</td><td class="memItemRight" valign="bottom"><b>pbits</b></td></tr>
<tr class="separator:a75b7dded45bbf408f71819bdaa0c092a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a0ad7c77e33d4803b40b472f2f247b"><td class="memItemLeft" align="right" valign="top"><a id="a04a0ad7c77e33d4803b40b472f2f247b"></a>
std::vector&lt; uint8_t &gt; BigInt BigInt size_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>qbits</b></td></tr>
<tr class="separator:a04a0ad7c77e33d4803b40b472f2f247b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa938ba4faf7be07fadef6e3e4c8e1cf"><td class="memItemLeft" align="right" valign="top"><a id="aaa938ba4faf7be07fadef6e3e4c8e1cf"></a>
bool BigInt BigInt size_t size_t const std::vector&lt; uint8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>seed</b></td></tr>
<tr class="separator:aaa938ba4faf7be07fadef6e3e4c8e1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f78391f7196dabe4675829b8add034"><td class="memItemLeft" align="right" valign="top"><a id="aa2f78391f7196dabe4675829b8add034"></a>
bool BigInt BigInt size_t size_t const std::vector&lt; uint8_t &gt; size_t&#160;</td><td class="memItemRight" valign="bottom"><b>offset</b> = 0)</td></tr>
<tr class="separator:aa2f78391f7196dabe4675829b8add034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501e4632aed1ca4799b03efff7dc59d7"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_botan.html#a501e4632aed1ca4799b03efff7dc59d7">PRIME_TABLE_SIZE</a> = 6541</td></tr>
<tr class="separator:a501e4632aed1ca4799b03efff7dc59d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f664cf9c46f7e67991e672eaf024d4"><td class="memItemLeft" align="right" valign="top"><a id="af3f664cf9c46f7e67991e672eaf024d4"></a>
const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>PRIMES</b> [<a class="el" href="namespace_botan.html#a501e4632aed1ca4799b03efff7dc59d7">PRIME_TABLE_SIZE</a>+1]</td></tr>
<tr class="separator:af3f664cf9c46f7e67991e672eaf024d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e75bc4b2f4531cdaca8bbc4ca9e591"><td class="memItemLeft" align="right" valign="top"><a id="af7e75bc4b2f4531cdaca8bbc4ca9e591"></a>
void BlockCipher *&#160;</td><td class="memItemRight" valign="bottom"><b>cipher</b></td></tr>
<tr class="separator:af7e75bc4b2f4531cdaca8bbc4ca9e591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab622a8c04526cb5bbdb2b033d7394fe2"><td class="memItemLeft" align="right" valign="top"><a id="ab622a8c04526cb5bbdb2b033d7394fe2"></a>
void BlockCipher const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>input_len</b></td></tr>
<tr class="separator:ab622a8c04526cb5bbdb2b033d7394fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd72d8ad645373d35fd0c7c615a16bc5"><td class="memItemLeft" align="right" valign="top"><a id="abd72d8ad645373d35fd0c7c615a16bc5"></a>
void BlockCipher const uint8_t size_t uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>output</b> []</td></tr>
<tr class="separator:abd72d8ad645373d35fd0c7c615a16bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cd2a6f3e8e5bfbb61a6a5b9ae76cec"><td class="memItemLeft" align="right" valign="top"><a id="aa3cd2a6f3e8e5bfbb61a6a5b9ae76cec"></a>
std::vector&lt; uint8_t &gt; size_t const BlockCipher &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bc</b></td></tr>
<tr class="separator:aa3cd2a6f3e8e5bfbb61a6a5b9ae76cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d20a4d824012228b47dcd42c14268a"><td class="memItemLeft" align="right" valign="top"><a id="ae7d20a4d824012228b47dcd42c14268a"></a>
secure_vector&lt; uint8_t &gt; const <a class="el" href="namespace_botan.html#a89cf6c3513428f524454d01830221a88">SymmetricKey</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>kek</b></td></tr>
<tr class="separator:ae7d20a4d824012228b47dcd42c14268a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c23440dccec1583013c44d5bf44ce2"><td class="memItemLeft" align="right" valign="top"><a id="a97c23440dccec1583013c44d5bf44ce2"></a>
std::pair&lt; BigInt, <a class="el" href="namespace_botan.html#a89cf6c3513428f524454d01830221a88">SymmetricKey</a> &gt; <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) srp6_client_agree(const std BigInt <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) generate_srp6_verifier(const std std::string const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>g</b></td></tr>
<tr class="separator:a97c23440dccec1583013c44d5bf44ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ff953b00eac02c1d655e92c3267188"><td class="memItemLeft" align="right" valign="top"><a id="a37ff953b00eac02c1d655e92c3267188"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>out</b> []</td></tr>
<tr class="separator:a37ff953b00eac02c1d655e92c3267188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa003f90d1d1a056c2fc7781bf3c6d209"><td class="memItemLeft" align="right" valign="top"><a id="aa003f90d1d1a056c2fc7781bf3c6d209"></a>
uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>out_len</b></td></tr>
<tr class="separator:aa003f90d1d1a056c2fc7781bf3c6d209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c121487c68f40770b8467f86eb4126"><td class="memItemLeft" align="right" valign="top"><a id="ae5c121487c68f40770b8467f86eb4126"></a>
uint8_t size_t const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>passphrase</b></td></tr>
<tr class="separator:ae5c121487c68f40770b8467f86eb4126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699a5fee3ed89a41ec618dadf683c9a9"><td class="memItemLeft" align="right" valign="top"><a id="a699a5fee3ed89a41ec618dadf683c9a9"></a>
uint8_t size_t const std::string const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>salt</b> []</td></tr>
<tr class="separator:a699a5fee3ed89a41ec618dadf683c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0794c61071abe0f9c09ee9052a0c174d"><td class="memItemLeft" align="right" valign="top"><a id="a0794c61071abe0f9c09ee9052a0c174d"></a>
uint8_t size_t const std::string const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>salt_len</b></td></tr>
<tr class="separator:a0794c61071abe0f9c09ee9052a0c174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c35a491fe7750827fc3e09cef2dcec"><td class="memItemLeft" align="right" valign="top"><a id="ac3c35a491fe7750827fc3e09cef2dcec"></a>
uint8_t size_t const std::string const uint8_t size_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>iterations</b></td></tr>
<tr class="separator:ac3c35a491fe7750827fc3e09cef2dcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513102b456aed549a6953d44e7e814ad"><td class="memItemLeft" align="right" valign="top"><a id="a513102b456aed549a6953d44e7e814ad"></a>
uint8_t size_t const std::string const uint8_t size_t size_t std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><b>msec</b></td></tr>
<tr class="separator:a513102b456aed549a6953d44e7e814ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1496c41c0690b2f80cbc40ec932f1dfd"><td class="memItemLeft" align="right" valign="top"><a id="a1496c41c0690b2f80cbc40ec932f1dfd"></a>
class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 8) Scrypt final class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 8) Scrypt_Family final void size_t&#160;</td><td class="memItemRight" valign="bottom"><b>output_len</b></td></tr>
<tr class="separator:a1496c41c0690b2f80cbc40ec932f1dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48d48a7011391b581409ad87778645b"><td class="memItemLeft" align="right" valign="top"><a id="ad48d48a7011391b581409ad87778645b"></a>
class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 8) Scrypt final class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 8) Scrypt_Family final void size_t const char *&#160;</td><td class="memItemRight" valign="bottom"><b>password</b></td></tr>
<tr class="separator:ad48d48a7011391b581409ad87778645b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4068737a9a762f88081e29a17c4de95c"><td class="memItemLeft" align="right" valign="top"><a id="a4068737a9a762f88081e29a17c4de95c"></a>
class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 8) Scrypt final class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 8) Scrypt_Family final void size_t const char size_t&#160;</td><td class="memItemRight" valign="bottom"><b>password_len</b></td></tr>
<tr class="separator:a4068737a9a762f88081e29a17c4de95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53668c1d1ed988ada4e718cf08a19b78"><td class="memItemLeft" align="right" valign="top"><a id="a53668c1d1ed988ada4e718cf08a19b78"></a>
class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 8) Scrypt final class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 8) Scrypt_Family final void size_t const char size_t const uint8_t size_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>N</b></td></tr>
<tr class="separator:a53668c1d1ed988ada4e718cf08a19b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853ca03fdf712ccf5b18c2063853c9be"><td class="memItemLeft" align="right" valign="top"><a id="a853ca03fdf712ccf5b18c2063853c9be"></a>
void const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>in</b> []</td></tr>
<tr class="separator:a853ca03fdf712ccf5b18c2063853c9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439e1214de59cd31af33a125a39e0646"><td class="memItemLeft" align="right" valign="top"><a id="a439e1214de59cd31af33a125a39e0646"></a>
void const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>in_len</b></td></tr>
<tr class="separator:a439e1214de59cd31af33a125a39e0646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb6ea5fa1423573816f3aeb42fb5062"><td class="memItemLeft" align="right" valign="top">const std::map&lt; const std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>allowed_signature_paddings</b></td></tr>
<tr class="separator:afbb6ea5fa1423573816f3aeb42fb5062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec869250a45251b833e32a86445d5af"><td class="memItemLeft" align="right" valign="top"><a id="a4ec869250a45251b833e32a86445d5af"></a>
void <a class="el" href="class_botan_1_1_c_e_c_p_q1__key.html">CECPQ1_key</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>offer_key_output</b></td></tr>
<tr class="separator:a4ec869250a45251b833e32a86445d5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151b2f3408addca5a024b0cd417bd0f5"><td class="memItemLeft" align="right" valign="top"><a id="a151b2f3408addca5a024b0cd417bd0f5"></a>
void uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>accept_message</b></td></tr>
<tr class="separator:a151b2f3408addca5a024b0cd417bd0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3483a2527a136be8127ee4350b593bf4"><td class="memItemLeft" align="right" valign="top"><a id="a3483a2527a136be8127ee4350b593bf4"></a>
void uint8_t const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>offer_message</b></td></tr>
<tr class="separator:a3483a2527a136be8127ee4350b593bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c700ef92957751a720588ae8897ecc1"><td class="memItemLeft" align="right" valign="top"><a id="a7c700ef92957751a720588ae8897ecc1"></a>
void const <a class="el" href="class_botan_1_1_c_e_c_p_q1__key.html">CECPQ1_key</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>offer_key</b></td></tr>
<tr class="separator:a7c700ef92957751a720588ae8897ecc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a34371c8a6b1fd28279ee9d0170ada2"><td class="memItemLeft" align="right" valign="top"><a id="a5a34371c8a6b1fd28279ee9d0170ada2"></a>
void const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>secret</b> [32]</td></tr>
<tr class="separator:a5a34371c8a6b1fd28279ee9d0170ada2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeeebbc3ab0606e584c4c80e830e2531"><td class="memItemLeft" align="right" valign="top"><a id="aaeeebbc3ab0606e584c4c80e830e2531"></a>
void const uint8_t const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>basepoint</b> [32]</td></tr>
<tr class="separator:aaeeebbc3ab0606e584c4c80e830e2531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9e4c30b78370440427cb9802c96cbc"><td class="memItemLeft" align="right" valign="top"><a id="a3b9e4c30b78370440427cb9802c96cbc"></a>
const PointGFp &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>point</b></td></tr>
<tr class="separator:a3b9e4c30b78370440427cb9802c96cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7f719f1e808cf4551ec2ff4d0364be"><td class="memItemLeft" align="right" valign="top"><a id="a4e7f719f1e808cf4551ec2ff4d0364be"></a>
const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>z1</b></td></tr>
<tr class="separator:a4e7f719f1e808cf4551ec2ff4d0364be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab702147f5064439198b8ec561b6ad023"><td class="memItemLeft" align="right" valign="top"><a id="ab702147f5064439198b8ec561b6ad023"></a>
const BigInt const PointGFp &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>p2</b></td></tr>
<tr class="separator:ab702147f5064439198b8ec561b6ad023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70a94be478803d91ba2b30cdb61af50"><td class="memItemLeft" align="right" valign="top"><a id="ac70a94be478803d91ba2b30cdb61af50"></a>
const BigInt const PointGFp const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>z2</b></td></tr>
<tr class="separator:ac70a94be478803d91ba2b30cdb61af50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84160e8d4f120a4f232bf20ecb80be0e"><td class="memItemLeft" align="right" valign="top">secure_vector&lt; uint8_t &gt; uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>format</b></td></tr>
<tr class="separator:a84160e8d4f120a4f232bf20ecb80be0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164c7ea110b841c1c3e1c800ec831017"><td class="memItemLeft" align="right" valign="top"><a id="a164c7ea110b841c1c3e1c800ec831017"></a>
PointGFp size_t&#160;</td><td class="memItemRight" valign="bottom"><b>data_len</b></td></tr>
<tr class="separator:a164c7ea110b841c1c3e1c800ec831017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96385f036be453bd61fa4311fc47c87"><td class="memItemLeft" align="right" valign="top"><a id="aa96385f036be453bd61fa4311fc47c87"></a>
PointGFp size_t const <a class="el" href="class_botan_1_1_curve_g_fp.html">CurveGFp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>curve</b></td></tr>
<tr class="separator:aa96385f036be453bd61fa4311fc47c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4531842d0db6b426dcf54e400936077"><td class="memItemLeft" align="right" valign="top"><a id="aa4531842d0db6b426dcf54e400936077"></a>
class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) McEliece_PublicKey class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a>(2, 0) McEliece_PrivateKey final size_t&#160;</td><td class="memItemRight" valign="bottom"><b>t</b></td></tr>
<tr class="separator:aa4531842d0db6b426dcf54e400936077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40670bb3ebcc56c095d864d93cc7a256"><td class="memItemLeft" align="right" valign="top"><a id="a40670bb3ebcc56c095d864d93cc7a256"></a>
secure_vector&lt; uint8_t &gt; const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>pt</b> []</td></tr>
<tr class="separator:a40670bb3ebcc56c095d864d93cc7a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7818000c1be4c2d881272301a60dad50"><td class="memItemLeft" align="right" valign="top"><a id="a7818000c1be4c2d881272301a60dad50"></a>
secure_vector&lt; uint8_t &gt; const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>pt_len</b></td></tr>
<tr class="separator:a7818000c1be4c2d881272301a60dad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3908e7a9a541a30b8f12f411195bb0d"><td class="memItemLeft" align="right" valign="top"><a id="af3908e7a9a541a30b8f12f411195bb0d"></a>
secure_vector&lt; uint8_t &gt; const uint8_t size_t const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>ad</b> []</td></tr>
<tr class="separator:af3908e7a9a541a30b8f12f411195bb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05280f78468cb5278c6981f587d1413"><td class="memItemLeft" align="right" valign="top"><a id="af05280f78468cb5278c6981f587d1413"></a>
secure_vector&lt; uint8_t &gt; const uint8_t size_t const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ad_len</b></td></tr>
<tr class="separator:af05280f78468cb5278c6981f587d1413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31fe27d62003da6615ede6eefecf9e2"><td class="memItemLeft" align="right" valign="top"><a id="ac31fe27d62003da6615ede6eefecf9e2"></a>
secure_vector&lt; uint8_t &gt; const uint8_t size_t const uint8_t size_t RandomNumberGenerator const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>aead</b> = &quot;AES-256/OCB&quot;)</td></tr>
<tr class="separator:ac31fe27d62003da6615ede6eefecf9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b25d2187260c0f4994b47ac51f1193d"><td class="memItemLeft" align="right" valign="top"><a id="a7b25d2187260c0f4994b47ac51f1193d"></a>
secure_vector&lt; uint8_t &gt; const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>ct</b> []</td></tr>
<tr class="separator:a7b25d2187260c0f4994b47ac51f1193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82688ab21aa95be4d8195067242b1c11"><td class="memItemLeft" align="right" valign="top"><a id="a82688ab21aa95be4d8195067242b1c11"></a>
secure_vector&lt; uint8_t &gt; const uint8_t size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ct_len</b></td></tr>
<tr class="separator:a82688ab21aa95be4d8195067242b1c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096197074416af0f41dd9b5777dae7b2"><td class="memItemLeft" align="right" valign="top"><a id="a096197074416af0f41dd9b5777dae7b2"></a>
void <a class="el" href="class_botan_1_1newhope__poly.html">newhope_poly</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sk</b></td></tr>
<tr class="separator:a096197074416af0f41dd9b5777dae7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0392b66238af293103acadaa30ad8c3"><td class="memItemLeft" align="right" valign="top"><a id="ae0392b66238af293103acadaa30ad8c3"></a>
void <a class="el" href="class_botan_1_1newhope__poly.html">newhope_poly</a> RandomNumberGenerator&#160;</td><td class="memItemRight" valign="bottom"><b>Newhope_Mode</b> = Newhope_Mode::SHA3)</td></tr>
<tr class="separator:ae0392b66238af293103acadaa30ad8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac40319b7635443904dad2c1c2e57a38"><td class="memItemLeft" align="right" valign="top"><a id="aac40319b7635443904dad2c1c2e57a38"></a>
void uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>send</b> []</td></tr>
<tr class="separator:aac40319b7635443904dad2c1c2e57a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5584f0f17d61e6271665a464d77fdb3"><td class="memItemLeft" align="right" valign="top"><a id="ae5584f0f17d61e6271665a464d77fdb3"></a>
void uint8_t const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>received</b></td></tr>
<tr class="separator:ae5584f0f17d61e6271665a464d77fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82acec4ee142a4756ebe9a6dd6a64d41"><td class="memItemLeft" align="right" valign="top"><a id="a82acec4ee142a4756ebe9a6dd6a64d41"></a>
void uint8_t const uint8_t RandomNumberGenerator <a class="el" href="namespace_botan.html#a42a70d7cfb95e4f7773d3b52dc98ad61">Newhope_Mode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mode</b> = Newhope_Mode::SHA3)</td></tr>
<tr class="separator:a82acec4ee142a4756ebe9a6dd6a64d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed03ef32cb37696f691920d798ba5bf"><td class="memItemLeft" align="right" valign="top"><a id="a5ed03ef32cb37696f691920d798ba5bf"></a>
void const <a class="el" href="class_botan_1_1newhope__poly.html">newhope_poly</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ska</b></td></tr>
<tr class="separator:a5ed03ef32cb37696f691920d798ba5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2157b34c32e9bf021cec5d2c9d157360"><td class="memItemLeft" align="right" valign="top"><a id="a2157b34c32e9bf021cec5d2c9d157360"></a>
std::pair&lt; AlgorithmIdentifier, std::vector&lt; uint8_t &gt; &gt; const std::string std::chrono::milliseconds const std::string const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>digest</b></td></tr>
<tr class="separator:a2157b34c32e9bf021cec5d2c9d157360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb7dc4ad28c1cfa265193e4e893e156"><td class="memItemLeft" align="right" valign="top"><a id="affb7dc4ad28c1cfa265193e4e893e156"></a>
std::pair&lt; AlgorithmIdentifier, std::vector&lt; uint8_t &gt; &gt; const std::string std::chrono::milliseconds size_t *&#160;</td><td class="memItemRight" valign="bottom"><b>out_iterations_if_nonnull</b></td></tr>
<tr class="separator:affb7dc4ad28c1cfa265193e4e893e156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c1a035f1a32291007db26085877f97"><td class="memItemLeft" align="right" valign="top"><a id="ad2c1a035f1a32291007db26085877f97"></a>
secure_vector&lt; uint8_t &gt; const std::string const std::vector&lt; uint8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>params</b></td></tr>
<tr class="separator:ad2c1a035f1a32291007db26085877f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b8d90d37c7918007e184de813111c0"><td class="memItemLeft" align="right" valign="top"><a id="a60b8d90d37c7918007e184de813111c0"></a>
std::string size_t&#160;</td><td class="memItemRight" valign="bottom"><b>len</b></td></tr>
<tr class="separator:a60b8d90d37c7918007e184de813111c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f00cf06873669222ace771b96c877a"><td class="memItemLeft" align="right" valign="top"><a id="a46f00cf06873669222ace771b96c877a"></a>
std::string size_t const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>hash_name</b></td></tr>
<tr class="separator:a46f00cf06873669222ace771b96c877a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e123345edc35de68c76c9b16a3d7a12"><td class="memItemLeft" align="right" valign="top"><a id="a1e123345edc35de68c76c9b16a3d7a12"></a>
BigInt const BigInt const BigInt &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>h</b></td></tr>
<tr class="separator:a1e123345edc35de68c76c9b16a3d7a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973b2202e0dd6c52c22181e5129cc89e"><td class="memItemLeft" align="right" valign="top"><a id="a973b2202e0dd6c52c22181e5129cc89e"></a>
BigInt const BigInt const BigInt const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b></td></tr>
<tr class="separator:a973b2202e0dd6c52c22181e5129cc89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ba6ed9adbd3daad55a7771f7f1c916"><td class="memItemLeft" align="right" valign="top"><a id="ad2ba6ed9adbd3daad55a7771f7f1c916"></a>
std::vector&lt; uint8_t &gt; const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>user_id</b></td></tr>
<tr class="separator:ad2ba6ed9adbd3daad55a7771f7f1c916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc2a26cd893245cca609c658abf95dd"><td class="memItemLeft" align="right" valign="top"><a id="a4dc2a26cd893245cca609c658abf95dd"></a>
std::vector&lt; uint8_t &gt; const std::string const EC_Group &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>domain</b></td></tr>
<tr class="separator:a4dc2a26cd893245cca609c658abf95dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6b17ab6587a6e31b6e899c04acb987"><td class="memItemLeft" align="right" valign="top"><a id="a1e6b17ab6587a6e31b6e899c04acb987"></a>
std::vector&lt; uint8_t &gt; const std::string const EC_Group const PointGFp &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>pubkey</b></td></tr>
<tr class="separator:a1e6b17ab6587a6e31b6e899c04acb987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dd8106a4e2a1e8b14f10a62bc5d011"><td class="memItemLeft" align="right" valign="top"><a id="a02dd8106a4e2a1e8b14f10a62bc5d011"></a>
BOTAN_NORETURN void const char *&#160;</td><td class="memItemRight" valign="bottom"><b>assertion_made</b></td></tr>
<tr class="separator:a02dd8106a4e2a1e8b14f10a62bc5d011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0a49f2f4af42548f0b748f3452c56a"><td class="memItemLeft" align="right" valign="top"><a id="adc0a49f2f4af42548f0b748f3452c56a"></a>
BOTAN_NORETURN void const char const char *&#160;</td><td class="memItemRight" valign="bottom"><b>func</b></td></tr>
<tr class="separator:adc0a49f2f4af42548f0b748f3452c56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cb3409368a714bfa1817110e1b9045"><td class="memItemLeft" align="right" valign="top"><a id="ad5cb3409368a714bfa1817110e1b9045"></a>
BOTAN_NORETURN void const char const char const char *&#160;</td><td class="memItemRight" valign="bottom"><b>file</b></td></tr>
<tr class="separator:ad5cb3409368a714bfa1817110e1b9045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbfe51a6f9e53decf26de4e87617414"><td class="memItemLeft" align="right" valign="top"><a id="a8fbfe51a6f9e53decf26de4e87617414"></a>
BOTAN_NORETURN void const char const char const char int&#160;</td><td class="memItemRight" valign="bottom"><b>line</b></td></tr>
<tr class="separator:a8fbfe51a6f9e53decf26de4e87617414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27e36b1de262f5dd9a65eb0c0e77a45"><td class="memItemLeft" align="right" valign="top"><a id="aa27e36b1de262f5dd9a65eb0c0e77a45"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>elem_size</b></td></tr>
<tr class="separator:aa27e36b1de262f5dd9a65eb0c0e77a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552b48f7f536d58127ea40040deaf8d9"><td class="memItemLeft" align="right" valign="top"><a id="a552b48f7f536d58127ea40040deaf8d9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>elems</b></td></tr>
<tr class="separator:a552b48f7f536d58127ea40040deaf8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2fa9a06064a501337026f42577860e"><td class="memItemLeft" align="right" valign="top"><a id="a4a2fa9a06064a501337026f42577860e"></a>
<a class="el" href="namespace_botan.html#aed0885e5c70627dd43827b966e727654">Key_Constraints</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constraints</b></td></tr>
<tr class="separator:a4a2fa9a06064a501337026f42577860e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ff3a76d5b1d104c0df37360f18cb83"><td class="memItemLeft" align="right" valign="top"><a id="ac6ff3a76d5b1d104c0df37360f18cb83"></a>
RandomNumberGenerator const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>hash_fn</b></td></tr>
<tr class="separator:ac6ff3a76d5b1d104c0df37360f18cb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad140168efb52a67d1d1808860e679357"><td class="memItemLeft" align="right" valign="top"><a id="ad140168efb52a67d1d1808860e679357"></a>
RandomNumberGenerator const std::string AlgorithmIdentifier &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>alg_id</b></td></tr>
<tr class="separator:ad140168efb52a67d1d1808860e679357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b96fedb23b4218373cfd0a749036d7"><td class="memItemLeft" align="right" valign="top"><a id="a87b96fedb23b4218373cfd0a749036d7"></a>
Path_Validation_Result const Path_Validation_Restrictions &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>restrictions</b></td></tr>
<tr class="separator:a87b96fedb23b4218373cfd0a749036d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6d085f658cc3ceaf8ef66561b44be3"><td class="memItemLeft" align="right" valign="top"><a id="a7b6d085f658cc3ceaf8ef66561b44be3"></a>
Path_Validation_Result const Path_Validation_Restrictions const std::vector&lt; Certificate_Store * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>trusted_roots</b></td></tr>
<tr class="separator:a7b6d085f658cc3ceaf8ef66561b44be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de2cbfe29cb7de1b122c86642ee788e"><td class="memItemLeft" align="right" valign="top"><a id="a4de2cbfe29cb7de1b122c86642ee788e"></a>
Path_Validation_Result const Path_Validation_Restrictions const std::vector&lt; Certificate_Store * &gt; const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>hostname</b> = &quot;&quot;</td></tr>
<tr class="separator:a4de2cbfe29cb7de1b122c86642ee788e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f0b90cebd01df11f3739504f9c14a7"><td class="memItemLeft" align="right" valign="top"><a id="a65f0b90cebd01df11f3739504f9c14a7"></a>
Path_Validation_Result const Path_Validation_Restrictions const std::vector&lt; Certificate_Store * &gt; const std::string Usage_Type&#160;</td><td class="memItemRight" valign="bottom"><b>usage</b> = Usage_Type::UNSPECIFIED</td></tr>
<tr class="separator:a65f0b90cebd01df11f3739504f9c14a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a1fc779e3d2fec06960301c8c54e2f"><td class="memItemLeft" align="right" valign="top"><a id="aa3a1fc779e3d2fec06960301c8c54e2f"></a>
Path_Validation_Result const Path_Validation_Restrictions const std::vector&lt; Certificate_Store * &gt; const std::string Usage_Type std::chrono::system_clock::time_point&#160;</td><td class="memItemRight" valign="bottom"><b>validation_time</b> = std::chrono::system_clock::now()</td></tr>
<tr class="separator:aa3a1fc779e3d2fec06960301c8c54e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930de75bf8dfd0bed638010fbe439fdc"><td class="memItemLeft" align="right" valign="top"><a id="a930de75bf8dfd0bed638010fbe439fdc"></a>
Path_Validation_Result const Path_Validation_Restrictions const std::vector&lt; Certificate_Store * &gt; const std::string Usage_Type std::chrono::system_clock::time_point std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><b>ocsp_timeout</b> = std::chrono::milliseconds(0)</td></tr>
<tr class="separator:a930de75bf8dfd0bed638010fbe439fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab696068d6099063b8ce1fe7a638f60ed"><td class="memItemLeft" align="right" valign="top"><a id="ab696068d6099063b8ce1fe7a638f60ed"></a>
Path_Validation_Result const Path_Validation_Restrictions const std::vector&lt; Certificate_Store * &gt; const std::string Usage_Type std::chrono::system_clock::time_point std::chrono::milliseconds const std::vector&lt; std::shared_ptr&lt; const OCSP::Response &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ocsp_resp</b> = {})</td></tr>
<tr class="separator:ab696068d6099063b8ce1fe7a638f60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f45b0b77fb49e557911a77e2b6845bf"><td class="memItemLeft" align="right" valign="top"><a id="a3f45b0b77fb49e557911a77e2b6845bf"></a>
Path_Validation_Result const Path_Validation_Restrictions const Certificate_Store &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>store</b></td></tr>
<tr class="separator:a3f45b0b77fb49e557911a77e2b6845bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>(C) 2018 Jack Lloyd (C) 2018 Ribose Inc</p>
<p><a class="el" href="namespace_botan.html">Botan</a> is released under the Simplified BSD License (see license.txt)</p>
<p>Ordinary applications should never need to include or use this header. It is exposed only for specialized applications which want to implement new versions of public key crypto without merging them as changes to the library. One actual example of such usage is an application which creates RSA signatures using a custom TPM library. Unless you're doing something like that, you don't need anything here. Instead use <a class="el" href="pubkey_8h_source.html">pubkey.h</a> which wraps these types safely and provides a stable application-oriented API.</p>
<p>XMSS WOTS Addressed Private Key (C) 2016 Matthias Gierlings</p>
<p><a class="el" href="namespace_botan.html">Botan</a> is released under the Simplified BSD License (see license.txt)</p>
<p>XMSS WOTS Addressed Public Key (C) 2016,2017 Matthias Gierlings</p>
<p><a class="el" href="namespace_botan.html">Botan</a> is released under the Simplified BSD License (see license.txt) </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a013252aabcb201e0d27b60b1e690886b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013252aabcb201e0d27b60b1e690886b">&#9670;&nbsp;</a></span>CertificatePathStatusCodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;std::set&lt;<a class="el" href="namespace_botan.html#ae1e907dc90937bdda30f65216e68ff2b">Certificate_Status_Code</a>&gt; &gt; <a class="el" href="namespace_botan.html#a013252aabcb201e0d27b60b1e690886b">Botan::CertificatePathStatusCodes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type represents the validation status of an entire certificate path. There is one set of status codes for each certificate in the path. </p>

<p class="definition">Definition at line <a class="el" href="x509path_8h_source.html#l00029">29</a> of file <a class="el" href="x509path_8h_source.html">x509path.h</a>.</p>

</div>
</div>
<a id="a2fbf5195ffe701adcabb1f8c41bfc557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbf5195ffe701adcabb1f8c41bfc557">&#9670;&nbsp;</a></span>InitializationVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_botan.html#a2fbf5195ffe701adcabb1f8c41bfc557">Botan::InitializationVector</a> = typedef OctetString</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alternate name for octet string showing intent to use as an IV </p>

<p class="definition">Definition at line <a class="el" href="symkey_8h_source.html#l00141">141</a> of file <a class="el" href="symkey_8h_source.html">symkey.h</a>.</p>

</div>
</div>
<a id="a45fbc8259840830135e2cf779839ddfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fbc8259840830135e2cf779839ddfa">&#9670;&nbsp;</a></span>RNG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RandomNumberGenerator <a class="el" href="namespace_botan.html#a45fbc8259840830135e2cf779839ddfa">Botan::RNG</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience typedef </p>

<p class="definition">Definition at line <a class="el" href="rng_8h_source.html#l00177">177</a> of file <a class="el" href="rng_8h_source.html">rng.h</a>.</p>

</div>
</div>
<a id="a89cf6c3513428f524454d01830221a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cf6c3513428f524454d01830221a88">&#9670;&nbsp;</a></span>SymmetricKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_botan.html#a89cf6c3513428f524454d01830221a88">Botan::SymmetricKey</a> = typedef OctetString</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alternate name for octet string showing intent to use as a key </p>

<p class="definition">Definition at line <a class="el" href="symkey_8h_source.html#l00136">136</a> of file <a class="el" href="symkey_8h_source.html">symkey.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acc1ab433420bdddbcfe52dbbd94e8576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1ab433420bdddbcfe52dbbd94e8576">&#9670;&nbsp;</a></span>ASN1_Tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#acc1ab433420bdddbcfe52dbbd94e8576">Botan::ASN1_Tag</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ASN.1 Type and Class Tags </p>

<p class="definition">Definition at line <a class="el" href="asn1__obj_8h_source.html#l00022">22</a> of file <a class="el" href="asn1__obj_8h_source.html">asn1_obj.h</a>.</p>

</div>
</div>
<a id="ae1e907dc90937bdda30f65216e68ff2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e907dc90937bdda30f65216e68ff2b">&#9670;&nbsp;</a></span>Certificate_Status_Code</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#ae1e907dc90937bdda30f65216e68ff2b">Botan::Certificate_Status_Code</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Certificate validation status code Warning: reflect any changes to this in botan_cert_status_code in <a class="el" href="ffi_8h_source.html">ffi.h</a> </p>

<p class="definition">Definition at line <a class="el" href="cert__status_8h_source.html#l00019">19</a> of file <a class="el" href="cert__status_8h_source.html">cert_status.h</a>.</p>

</div>
</div>
<a id="a416eb1af7496d74b885a20ff833e9b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416eb1af7496d74b885a20ff833e9b33">&#9670;&nbsp;</a></span>Character_Set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#a416eb1af7496d74b885a20ff833e9b33">Botan::Character_Set</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The different charsets (nominally) supported by <a class="el" href="namespace_botan.html">Botan</a>. </p>

<p class="definition">Definition at line <a class="el" href="charset_8h_source.html#l00041">41</a> of file <a class="el" href="charset_8h_source.html">charset.h</a>.</p>

</div>
</div>
<a id="a8d9547a8fb3e868810b169b20ac389ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9547a8fb3e868810b169b20ac389ee">&#9670;&nbsp;</a></span>Cipher_Dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Botan::Cipher_Dir</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The two possible directions for cipher filters, determining whether they actually perform encryption or decryption. </p>

<p class="definition">Definition at line <a class="el" href="cipher__mode_8h_source.html#l00023">23</a> of file <a class="el" href="cipher__mode_8h_source.html">cipher_mode.h</a>.</p>

</div>
</div>
<a id="a557e654e0c387a4ef2521e3ece516ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557e654e0c387a4ef2521e3ece516ca7">&#9670;&nbsp;</a></span>CRL_Code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#a557e654e0c387a4ef2521e3ece516ca7">Botan::CRL_Code</a> : uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>X.509v2 CRL Reason Code. </p>

<p class="definition">Definition at line <a class="el" href="crl__ent_8h_source.html#l00022">22</a> of file <a class="el" href="crl__ent_8h_source.html">crl_ent.h</a>.</p>

</div>
</div>
<a id="acd5baf937a9984c39f8b44104dde76ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5baf937a9984c39f8b44104dde76ae">&#9670;&nbsp;</a></span>Decoder_Checking</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#acd5baf937a9984c39f8b44104dde76ae">Botan::Decoder_Checking</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the abstract Fanout_Filter base class. The type of checking to be performed by decoders: NONE - no checks, IGNORE_WS - perform checks, but ignore whitespaces, FULL_CHECK - perform checks, also complain about white spaces. </p>

<p class="definition">Definition at line <a class="el" href="filter_8h_source.html#l00171">171</a> of file <a class="el" href="filter_8h_source.html">filter.h</a>.</p>

</div>
</div>
<a id="ad0ee6307c8f311388a2bc00426a7f858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ee6307c8f311388a2bc00426a7f858">&#9670;&nbsp;</a></span>EC_Group_Encoding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#ad0ee6307c8f311388a2bc00426a7f858">Botan::EC_Group_Encoding</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This class represents elliptic curce domain parameters </p>

<p class="definition">Definition at line <a class="el" href="ec__group_8h_source.html#l00023">23</a> of file <a class="el" href="ec__group_8h_source.html">ec_group.h</a>.</p>

</div>
</div>
<a id="a9633493dccb5f879eeafafe99c71f6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9633493dccb5f879eeafafe99c71f6e8">&#9670;&nbsp;</a></span>ECIES_Flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#a9633493dccb5f879eeafafe99c71f6e8">Botan::ECIES_Flags</a> : uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9633493dccb5f879eeafafe99c71f6e8a8f077adf8e11b076e88eee680527f81e"></a>SINGLE_HASH_MODE&#160;</td><td class="fielddoc"><p>if set: prefix the input of the (ecdh) key agreement with the encoded (ephemeral) public key </p>
</td></tr>
<tr><td class="fieldname"><a id="a9633493dccb5f879eeafafe99c71f6e8a421ba92bce979a3ec3aafaa74a7103d7"></a>COFACTOR_MODE&#160;</td><td class="fielddoc"><p>(decryption only) if set: use cofactor multiplication during (ecdh) key agreement </p>
</td></tr>
<tr><td class="fieldname"><a id="a9633493dccb5f879eeafafe99c71f6e8a2165f0ab80715b5218d379471e4f59cb"></a>OLD_COFACTOR_MODE&#160;</td><td class="fielddoc"><p>if set: use ecdhc instead of ecdh </p>
</td></tr>
<tr><td class="fieldname"><a id="a9633493dccb5f879eeafafe99c71f6e8a2376233bf1de21598ca22c5143aea223"></a>CHECK_MODE&#160;</td><td class="fielddoc"><p>(decryption only) if set: test if the (ephemeral) public key is on the curve </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ecies_8h_source.html#l00027">27</a> of file <a class="el" href="ecies_8h_source.html">ecies.h</a>.</p>

</div>
</div>
<a id="aed0885e5c70627dd43827b966e727654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0885e5c70627dd43827b966e727654">&#9670;&nbsp;</a></span>Key_Constraints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#aed0885e5c70627dd43827b966e727654">Botan::Key_Constraints</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>X.509v3 Key Constraints. If updating update copy in <a class="el" href="ffi_8h_source.html">ffi.h</a> </p>

<p class="definition">Definition at line <a class="el" href="key__constraint_8h_source.html#l00021">21</a> of file <a class="el" href="key__constraint_8h_source.html">key_constraint.h</a>.</p>

</div>
</div>
<a id="a42a70d7cfb95e4f7773d3b52dc98ad61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a70d7cfb95e4f7773d3b52dc98ad61">&#9670;&nbsp;</a></span>Newhope_Mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#a42a70d7cfb95e4f7773d3b52dc98ad61">Botan::Newhope_Mode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This chooses the XOF + hash for NewHope The official NewHope specification and reference implementation use SHA-3 and SHAKE-128. BoringSSL instead uses SHA-256 and AES-128 in CTR mode. CECPQ1 (x25519+NewHope) always uses BoringSSL's mode </p>

<p class="definition">Definition at line <a class="el" href="newhope_8h_source.html#l00058">58</a> of file <a class="el" href="newhope_8h_source.html">newhope.h</a>.</p>

</div>
</div>
<a id="ad8a9578625edf847cbcba3ae15648cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a9578625edf847cbcba3ae15648cda">&#9670;&nbsp;</a></span>Signature_Format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#ad8a9578625edf847cbcba3ae15648cda">Botan::Signature_Format</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The two types of signature format supported by <a class="el" href="namespace_botan.html">Botan</a>. </p>

<p class="definition">Definition at line <a class="el" href="pubkey_8h_source.html#l00027">27</a> of file <a class="el" href="pubkey_8h_source.html">pubkey.h</a>.</p>

</div>
</div>
<a id="a53759b4ed1fb93549f307fcf68729d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53759b4ed1fb93549f307fcf68729d2f">&#9670;&nbsp;</a></span>X509_Encoding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_botan.html#a53759b4ed1fb93549f307fcf68729d2f">Botan::X509_Encoding</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The two types of <a class="el" href="namespace_botan_1_1_x509.html">X509</a> encoding supported by <a class="el" href="namespace_botan.html">Botan</a>. This enum is not used anymore, and will be removed in a future major release. </p>

<p class="definition">Definition at line <a class="el" href="x509__key_8h_source.html#l00025">25</a> of file <a class="el" href="x509__key_8h_source.html">x509_key.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a481ae8e7fe0268600101ab74663f3f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481ae8e7fe0268600101ab74663f3f16">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BigInt Botan::abs </td>
          <td>(</td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the absolute value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute value of n </dd></dl>

<p class="definition">Definition at line <a class="el" href="numthry_8h_source.html#l00055">55</a> of file <a class="el" href="numthry_8h_source.html">numthry.h</a>.</p>

</div>
</div>
<a id="a72149230362af50f830a4ee04d7a9786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72149230362af50f830a4ee04d7a9786">&#9670;&nbsp;</a></span>base32_encode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Botan::base32_encode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform base32 encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base32 representation of input </dd></dl>

<p class="definition">Definition at line <a class="el" href="botan_2src_2lib_2codec_2base32_2base32_8h_source.html#l00050">50</a> of file <a class="el" href="botan_2src_2lib_2codec_2base32_2base32_8h_source.html">base32.h</a>.</p>

</div>
</div>
<a id="ae612d0f1287d36555adbe7ed4d8f171f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae612d0f1287d36555adbe7ed4d8f171f">&#9670;&nbsp;</a></span>base64_encode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Botan::base64_encode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform base64 encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64adecimal representation of input </dd></dl>

<p class="definition">Definition at line <a class="el" href="botan_2src_2lib_2codec_2base64_2base64_8h_source.html#l00050">50</a> of file <a class="el" href="botan_2src_2lib_2codec_2base64_2base64_8h_source.html">base64.h</a>.</p>

</div>
</div>
<a id="ab1d8df562b6507ed384c0f214f9b6a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d8df562b6507ed384c0f214f9b6a07">&#9670;&nbsp;</a></span>base_decode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::base_decode </td>
          <td>(</td>
          <td class="paramtype">Base &amp;&amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>input_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>input_consumed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>final_inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_ws</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform decoding using the base provided </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>object giving access to the encodings specifications </td></tr>
    <tr><td class="paramname">output</td><td>an array of at least Base::decode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>some base input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">input_consumed</td><td>is an output parameter which says how many bytes of input were actually consumed. If less than input_length, then the range input[consumed:length] should be passed in later along with more input. </td></tr>
    <tr><td class="paramname">final_inputs</td><td>true iff this is the last input, in which case padding is allowed </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output </dd></dl>

<p class="definition">Definition at line <a class="el" href="codec__base_8h_source.html#l00124">124</a> of file <a class="el" href="codec__base_8h_source.html">codec_base.h</a>.</p>

</div>
</div>
<a id="a8a4a5ffdca168ee94c08a5b20de0065a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4a5ffdca168ee94c08a5b20de0065a">&#9670;&nbsp;</a></span>base_encode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Base &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::base_encode </td>
          <td>(</td>
          <td class="paramtype">Base &amp;&amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>input_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>input_consumed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>final_inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform encoding using the base provided </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>object giving access to the encodings specifications </td></tr>
    <tr><td class="paramname">output</td><td>an array of at least base.encode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>is some binary data </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">input_consumed</td><td>is an output parameter which says how many bytes of input were actually consumed. If less than input_length, then the range input[consumed:length] should be passed in later along with more input. </td></tr>
    <tr><td class="paramname">final_inputs</td><td>true iff this is the last input, in which case padding chars will be applied if needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output </dd></dl>

<p class="definition">Definition at line <a class="el" href="codec__base_8h_source.html#l00034">34</a> of file <a class="el" href="codec__base_8h_source.html">codec_base.h</a>.</p>

</div>
</div>
<a id="a909ae118a4227e2c3b1d6dac8cde629c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909ae118a4227e2c3b1d6dac8cde629c">&#9670;&nbsp;</a></span>bigint_add2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::bigint_add2 </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two operand addition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first operand (and output) </td></tr>
    <tr><td class="paramname">x_size</td><td>size of x </td></tr>
    <tr><td class="paramname">y</td><td>the second operand </td></tr>
    <tr><td class="paramname">y_size</td><td>size of y (must be &gt;= x_size) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00186">186</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="ab8f4a27c1c5bf03f1a8dab57f2a41a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f4a27c1c5bf03f1a8dab57f2a41a13">&#9670;&nbsp;</a></span>bigint_add2_nc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word Botan::bigint_add2_nc </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two operand addition with carry out </p>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00138">138</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="a2b90c82b13db8553eaa2701a8dd5975f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b90c82b13db8553eaa2701a8dd5975f">&#9670;&nbsp;</a></span>bigint_add3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::bigint_add3 </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>z</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Three operand addition </p>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00194">194</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="ac6b0c61acfab2f864b2cf3999ca76c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b0c61acfab2f864b2cf3999ca76c01">&#9670;&nbsp;</a></span>bigint_add3_nc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word Botan::bigint_add3_nc </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>z</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Three operand addition with carry out </p>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00161">161</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="ada2360db2beff295a13a8e3a96136a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2360db2beff295a13a8e3a96136a61">&#9670;&nbsp;</a></span>bigint_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Botan::bigint_cmp </td>
          <td>(</td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare x and y returning early </p>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00478">478</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="a02cea0cc0c767a608413ba0cac4e74c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cea0cc0c767a608413ba0cac4e74c4">&#9670;&nbsp;</a></span>bigint_divop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word Botan::bigint_divop </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute ((n1&lt;&lt;bits) + n0) / d </p>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00504">504</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="acffd94b3a9b524da12c07a88fdda1eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffd94b3a9b524da12c07a88fdda1eb7">&#9670;&nbsp;</a></span>bigint_modop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word Botan::bigint_modop </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute ((n1&lt;&lt;bits) + n0) % d </p>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00537">537</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="aafff2116e1ca1980d42a3efdf85c9287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafff2116e1ca1980d42a3efdf85c9287">&#9670;&nbsp;</a></span>bigint_monty_redc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::bigint_monty_redc </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>z</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>p</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>p_dash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>workspace</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ws_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Montgomery Reduction </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>integer to reduce, of size exactly 2*(p_size+1). Output is in the first p_size+1 words, higher words are set to zero. </td></tr>
    <tr><td class="paramname">p</td><td>modulus </td></tr>
    <tr><td class="paramname">p_size</td><td>size of p </td></tr>
    <tr><td class="paramname">p_dash</td><td>Montgomery value </td></tr>
    <tr><td class="paramname">workspace</td><td>array of at least 2*(p_size+1) words </td></tr>
    <tr><td class="paramname">ws_size</td><td>size of workspace in words </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp__monty_8cpp_source.html#l00111">111</a> of file <a class="el" href="mp__monty_8cpp_source.html">mp_monty.cpp</a>.</p>

</div>
</div>
<a id="a1d2b962eb5d832116befc5957a6c975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2b962eb5d832116befc5957a6c975e">&#9670;&nbsp;</a></span>bigint_sub2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word Botan::bigint_sub2 </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two operand subtraction </p>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00204">204</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="a108c3a5b46712583de64a39d5fa6841b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108c3a5b46712583de64a39d5fa6841b">&#9670;&nbsp;</a></span>bigint_sub2_rev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::bigint_sub2_rev </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two operand subtraction, x = y - x; assumes y &gt;= x </p>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00227">227</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="aecdda04dbd8f4ec5aab85af9983e9c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdda04dbd8f4ec5aab85af9983e9c7a">&#9670;&nbsp;</a></span>bigint_sub3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word Botan::bigint_sub3 </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>z</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Three operand subtraction </p>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00276">276</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="a8ea10868dfcff0fcf7e44adc40192908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea10868dfcff0fcf7e44adc40192908">&#9670;&nbsp;</a></span>bigint_sub_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">word Botan::bigint_sub_abs </td>
          <td>(</td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>z</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const word&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">word&#160;</td>
          <td class="paramname"><em>ws</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return abs(x-y), ie if x &gt;= y, then compute z = x - y Otherwise compute z = y - x No borrow is possible since the result is always &gt;= 0</p>
<p>Returns 1 if x &gt;= y or 0 if x &lt; y </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>output array of at least N words </td></tr>
    <tr><td class="paramname">x</td><td>input array of N words </td></tr>
    <tr><td class="paramname">y</td><td>input array of N words </td></tr>
    <tr><td class="paramname">N</td><td>length of x and y </td></tr>
    <tr><td class="paramname">ws</td><td>array of at least 2*N words </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mp__core_8cpp_source.html#l00242">242</a> of file <a class="el" href="mp__core_8cpp_source.html">mp_core.cpp</a>.</p>

</div>
</div>
<a id="ace7349411411e52a65630e3e607ed504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7349411411e52a65630e3e607ed504">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">8&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>RFC 4880 encodes the iteration count to a single-byte value</p>
<p>Decode the iteration count from RFC 4880 encoding</p>
<p>Base class for password based key derivation functions.</p>
<p>Converts a password into a key using a salt and iterated hashing to make brute force attacks harder.</p>
<p>Scrypt key derivation function (RFC 7914) Scrypt key derivation function (RFC 7914)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the output will be placed here </td></tr>
    <tr><td class="paramname">output_len</td><td>length of output </td></tr>
    <tr><td class="paramname">password</td><td>the user password </td></tr>
    <tr><td class="paramname">salt</td><td>the salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt </td></tr>
    <tr><td class="paramname">N</td><td>the CPU/Memory cost parameter, must be power of 2 </td></tr>
    <tr><td class="paramname">r</td><td>the block size parameter </td></tr>
    <tr><td class="paramname">p</td><td>the parallelization parameter</td></tr>
  </table>
  </dd>
</dl>
<p>Suitable parameters for most uses would be N = 32768, r = 8, p = 1</p>
<p>Scrypt uses approximately (p + N + 1) * 128 * r bytes of memory </p>
<p>Most password hashes have some notion of iterations.</p>
<p>Some password hashing algorithms have a parameter which controls how much memory is used. If not supported by some algorithm, returns 0.</p>
<p>Some password hashing algorithms have a parallelism parameter. If the algorithm does not support this notion, then the function returns zero. This allows distinguishing between a password hash which just does not support parallel operation, vs one that does support parallel operation but which has been configured to use a single lane.</p>
<p>Returns an estimate of the total memory usage required to perform this key derivation.</p>
<p>If this algorithm uses a small and constant amount of memory, with no effort made towards being memory hard, this function returns 0.</p>
<p>Derive a key from a password</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer to store the derived key, must be of out_len bytes </td></tr>
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">password</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">password_len</td><td>the length of password in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>This function is const, but is not thread safe. Different threads should either use unique objects, or serialize all access.</p>
<p>Create an instance based on a name If provider is empty then best available is chosen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name </td></tr>
    <tr><td class="paramname">provider</td><td>provider implementation to choose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a null pointer if the algo/provider combination cannot be found</dd></dl>
<p>Create an instance based on a name, or throw if the algo/provider combination cannot be found. If provider is empty then best available is chosen.</p>
<dl class="section return"><dt>Returns</dt><dd>list of available providers for this algorithm, empty if not available</dd>
<dd>
name of this PasswordHash</dd></dl>
<p>Return a new parameter set tuned for this machine </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_length</td><td>how long the output length will be </td></tr>
    <tr><td class="paramname">msec</td><td>the desired execution time in milliseconds</td></tr>
    <tr><td class="paramname">max_memory_usage_mb</td><td>some password hash functions can use a tunable amount of memory, in this case max_memory_usage limits the amount of RAM the returned parameters will require, in mebibytes (2**20 bytes). It may require some small amount above the request. Set to zero to place no limit at all.</td></tr>
  </table>
  </dd>
</dl>
<p>Return some default parameter set for this PBKDF that should be good enough for most users. The value returned may change over time as processing power and attacks improve.</p>
<p>Return a parameter chosen based on a rough approximation with the specified iteration count. The exact value this returns for a particular algorithm may change from over time. Think of it as an alternative to tune, where time is expressed in terms of PBKDF2 iterations rather than milliseconds.</p>
<p>Create a password hash using some scheme specific format. Eg PBKDF2 and PGP-S2K set iterations in i1 Scrypt uses N,r,p in i{1-3} Bcrypt-PBKDF just has iterations Argon2{i,d,id} would use iterations, memory, parallelism for i{1-3}, and Argon2 type is part of the family.</p>
<p>Values not needed should be set to 0</p>
<p>Most password hashes have some notion of iterations.</p>
<p>Some password hashing algorithms have a parameter which controls how much memory is used. If not supported by some algorithm, returns 0.</p>
<p>Some password hashing algorithms have a parallelism parameter. If the algorithm does not support this notion, then the function returns zero. This allows distinguishing between a password hash which just does not support parallel operation, vs one that does support parallel operation but which has been configured to use a single lane.</p>
<p>Returns an estimate of the total memory usage required to perform this key derivation.</p>
<p>If this algorithm uses a small and constant amount of memory, with no effort made towards being memory hard, this function returns 0.</p>
<p>Derive a key from a password</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer to store the derived key, must be of out_len bytes </td></tr>
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">password</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">password_len</td><td>the length of password in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>This function is const, but is not thread safe. Different threads should either use unique objects, or serialize all access.</p>
<p>Create an instance based on a name If provider is empty then best available is chosen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name </td></tr>
    <tr><td class="paramname">provider</td><td>provider implementation to choose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a null pointer if the algo/provider combination cannot be found</dd></dl>
<p>Create an instance based on a name, or throw if the algo/provider combination cannot be found. If provider is empty then best available is chosen.</p>
<dl class="section return"><dt>Returns</dt><dd>list of available providers for this algorithm, empty if not available</dd>
<dd>
name of this PasswordHash</dd></dl>
<p>Return a new parameter set tuned for this machine </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_length</td><td>how long the output length will be </td></tr>
    <tr><td class="paramname">msec</td><td>the desired execution time in milliseconds</td></tr>
    <tr><td class="paramname">max_memory_usage_mb</td><td>some password hash functions can use a tunable amount of memory, in this case max_memory_usage limits the amount of RAM the returned parameters will require, in mebibytes (2**20 bytes). It may require some small amount above the request. Set to zero to place no limit at all.</td></tr>
  </table>
  </dd>
</dl>
<p>Return some default parameter set for this PBKDF that should be good enough for most users. The value returned may change over time as processing power and attacks improve.</p>
<p>Return a parameter chosen based on a rough approximation with the specified iteration count. The exact value this returns for a particular algorithm may change from over time. Think of it as an alternative to tune, where time is expressed in terms of PBKDF2 iterations rather than milliseconds.</p>
<p>Create a password hash using some scheme specific format. Eg PBKDF2 and PGP-S2K set iterations in i1 Scrypt uses N,r,p in i{1-3} Bcrypt-PBKDF just has iterations Argon2{i,d,id} would use iterations, memory, parallelism for i{1-3}, and Argon2 type is part of the family.</p>
<p>Values not needed should be set to 0</p>

<p class="definition">Definition at line <a class="el" href="pwdhash_8h_source.html#l00024">24</a> of file <a class="el" href="pwdhash_8h_source.html">pwdhash.h</a>.</p>

</div>
</div>
<a id="ad87a88225cfb55247f4a91b0b50da678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87a88225cfb55247f4a91b0b50da678">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">secure_vector&lt; uint8_t &gt; Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">7&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform base32 encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least base32_encode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>is some binary data </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">input_consumed</td><td>is an output parameter which says how many bytes of input were actually consumed. If less than input_length, then the range input[consumed:length] should be passed in later along with more input. </td></tr>
    <tr><td class="paramname">final_inputs</td><td>true iff this is the last input, in which case padding chars will be applied if needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform base32 encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base32 representation of input</dd></dl>
<p>Perform base32 decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least base32_decode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>some base32 input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">input_consumed</td><td>is an output parameter which says how many bytes of input were actually consumed. If less than input_length, then the range input[consumed:length] should be passed in later along with more input. </td></tr>
    <tr><td class="paramname">final_inputs</td><td>true iff this is the last input, in which case padding is allowed </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform base32 decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least base32_decode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>some base32 input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform base32 decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least base32_decode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>some base32 input </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform base32 decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some base32 input </td></tr>
    <tr><td class="paramname">input_length</td><td>the length of input in bytes </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded base32 output </dd></dl>

</div>
</div>
<a id="a8936d9d14b59d25507d664d4e631b605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8936d9d14b59d25507d664d4e631b605">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; AlgorithmIdentifier, std::vector&lt; uint8_t &gt; &gt; Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encrypt with PBES2 from PKCS #5 v2.0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_bits</td><td>the input </td></tr>
    <tr><td class="paramname">passphrase</td><td>the passphrase to use for encryption </td></tr>
    <tr><td class="paramname">msec</td><td>how many milliseconds to run PBKDF2 </td></tr>
    <tr><td class="paramname">out_iterations_if_nonnull</td><td>if not null, set to the number of PBKDF iterations used </td></tr>
    <tr><td class="paramname">cipher</td><td>specifies the block cipher to use to encrypt </td></tr>
    <tr><td class="paramname">digest</td><td>specifies the PRF to use with PBKDF2 (eg "HMAC(SHA-1)") </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator</td></tr>
  </table>
  </dd>
</dl>
<p>Encrypt with PBES2 from PKCS #5 v2.0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_bits</td><td>the input </td></tr>
    <tr><td class="paramname">passphrase</td><td>the passphrase to use for encryption </td></tr>
    <tr><td class="paramname">iterations</td><td>how many iterations to run PBKDF2 </td></tr>
    <tr><td class="paramname">cipher</td><td>specifies the block cipher to use to encrypt </td></tr>
    <tr><td class="paramname">digest</td><td>specifies the PRF to use with PBKDF2 (eg "HMAC(SHA-1)") </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ae2ea6a22f08742864267f1a2a7a91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae2ea6a22f08742864267f1a2a7a91c">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">3&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a password hash using PBKDF2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">password</td><td>the password </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">work_factor</td><td>how much work to do to slow down guessing attacks </td></tr>
    <tr><td class="paramname">alg_id</td><td>specifies which PRF to use with PBKDF2 0 is HMAC(SHA-1) 1 is HMAC(SHA-256) 2 is CMAC(Blowfish) 3 is HMAC(SHA-384) 4 is HMAC(SHA-512) all other values are currently undefined Check a previously created password hash </td></tr>
    <tr><td class="paramname">password</td><td>the password to check against </td></tr>
    <tr><td class="paramname">hash</td><td>the stored hash to check against Check if the PRF used with PBKDF2 is supported </td></tr>
    <tr><td class="paramname">alg_id</td><td>alg_id used in generate_passhash9()</td></tr>
  </table>
  </dd>
</dl>
<p>Allocate a memory buffer by some method. This should only be used for primitive types (uint8_t, uint32_t, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elems</td><td>the number of elements </td></tr>
    <tr><td class="paramname">elem_size</td><td>the size of each element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated and zeroed memory, or throw std::bad_alloc on failure</dd></dl>
<p>Free a pointer returned by allocate_memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the pointer returned by allocate_memory </td></tr>
    <tr><td class="paramname">elems</td><td>the number of elements, as passed to allocate_memory </td></tr>
    <tr><td class="paramname">elem_size</td><td>the size of each element, as passed to allocate_memory</td></tr>
  </table>
  </dd>
</dl>
<p>Memory comparison, input insensitive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a pointer to an array </td></tr>
    <tr><td class="paramname">y</td><td>a pointer to another array </td></tr>
    <tr><td class="paramname">len</td><td>the number of Ts in x and y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff x[i] == y[i] forall i in [0...n)</dd></dl>
<p>Polynomial doubling in GF(2^n) </p>

</div>
</div>
<a id="af945fa6198fa0d818e398c3e50303ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af945fa6198fa0d818e398c3e50303ddf">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>HOTP one time passwords (RFC 4226)</p>
<p>TOTP (time based) one time passwords (RFC 6238) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the secret key shared between client and server </td></tr>
    <tr><td class="paramname">hash_algo</td><td>the hash algorithm to use, should be SHA-1 or SHA-256 </td></tr>
    <tr><td class="paramname">digits</td><td>the number of digits in the OTP (must be 6, 7, or 8)</td></tr>
    <tr><td class="paramname">key</td><td>the secret key shared between client and server </td></tr>
    <tr><td class="paramname">key_len</td><td>length of key param </td></tr>
    <tr><td class="paramname">hash_algo</td><td>the hash algorithm to use, should be SHA-1 or SHA-256 </td></tr>
    <tr><td class="paramname">digits</td><td>the number of digits in the OTP (must be 6, 7, or 8)</td></tr>
  </table>
  </dd>
</dl>
<p>Generate the HOTP for a particular counter value </p><dl class="section warning"><dt>Warning</dt><dd>if the counter value is repeated the OTP ceases to be one-time</dd></dl>
<p>Check an OTP value using a starting counter and a resync range </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otp</td><td>the client provided OTP </td></tr>
    <tr><td class="paramname">starting_counter</td><td>the server's guess as to the current counter state </td></tr>
    <tr><td class="paramname">resync_range</td><td>if 0 then only HOTP(starting_counter) is accepted If larger than 0, up to resync_range values after HOTP are also checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(valid,next_counter). If the OTP does not validate, always returns (false,starting_counter). Otherwise returns (true,next_counter) where next_counter is at most starting_counter + resync_range + 1</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the secret key shared between client and server </td></tr>
    <tr><td class="paramname">hash_algo</td><td>the hash algorithm to use, should be SHA-1, SHA-256 or SHA-512 </td></tr>
    <tr><td class="paramname">digits</td><td>the number of digits in the OTP (must be 6, 7, or 8) </td></tr>
    <tr><td class="paramname">time_step</td><td>granularity of OTP in seconds</td></tr>
    <tr><td class="paramname">key</td><td>the secret key shared between client and server </td></tr>
    <tr><td class="paramname">key_len</td><td>length of key </td></tr>
    <tr><td class="paramname">hash_algo</td><td>the hash algorithm to use, should be SHA-1, SHA-256 or SHA-512 </td></tr>
    <tr><td class="paramname">digits</td><td>the number of digits in the OTP (must be 6, 7, or 8) </td></tr>
    <tr><td class="paramname">time_step</td><td>granularity of OTP in seconds</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the provided time_point to a Unix timestamp and call generate_totp</p>
<p>Generate the OTP corresponding the the provided "Unix timestamp" (ie number of seconds since midnight Jan 1, 1970)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the secret key shared between client and server </td></tr>
    <tr><td class="paramname">hash_algo</td><td>the hash algorithm to use, should be SHA-1, SHA-256 or SHA-512 </td></tr>
    <tr><td class="paramname">digits</td><td>the number of digits in the OTP (must be 6, 7, or 8) </td></tr>
    <tr><td class="paramname">time_step</td><td>granularity of OTP in seconds</td></tr>
    <tr><td class="paramname">key</td><td>the secret key shared between client and server </td></tr>
    <tr><td class="paramname">key_len</td><td>length of key </td></tr>
    <tr><td class="paramname">hash_algo</td><td>the hash algorithm to use, should be SHA-1, SHA-256 or SHA-512 </td></tr>
    <tr><td class="paramname">digits</td><td>the number of digits in the OTP (must be 6, 7, or 8) </td></tr>
    <tr><td class="paramname">time_step</td><td>granularity of OTP in seconds</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the provided time_point to a Unix timestamp and call generate_totp</p>
<p>Generate the OTP corresponding the the provided "Unix timestamp" (ie number of seconds since midnight Jan 1, 1970)</p>

<p class="definition">Definition at line <a class="el" href="hotp_8h_source.html#l00018">18</a> of file <a class="el" href="hotp_8h_source.html">hotp.h</a>.</p>

</div>
</div>
<a id="a6b9388030d872e586a4655b776ac9501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9388030d872e586a4655b776ac9501">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">new</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=(<span class="keyword">const</span> AlgorithmIdentifier&amp;,</div><div class="line">                                      <span class="keyword">const</span> AlgorithmIdentifier&amp;)</div></div><!-- fragment -->
<p>Name Constraints. </p>
<p>Algorithm Identifier</p>
<p>Basic ASN.1 Object Interface</p>
<p>BER Encoded Object</p>
<p>Compare two OIDs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first OID </td></tr>
    <tr><td class="paramname">b</td><td>the second OID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a is not equal to b</dd></dl>
<p>X.509 Time</p>
<p>BER Decoding Object</p>
<p>General DER Encoding Object</p>
<p>This class represents any kind of computation which uses an internal state, such as hash functions or MACs</p>
<p>Represents the length requirements on an algorithm key</p>
<p>A class encapsulating a SCAN name (similar to JCE conventions) <a href="http://www.users.zetnet.co.uk/hopwood/crypto/scan/">http://www.users.zetnet.co.uk/hopwood/crypto/scan/</a></p>
<p>This class represents a symmetric algorithm object.</p>
<p>Octet String</p>
<p>Compare two strings </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an octet string </td></tr>
    <tr><td class="paramname">y</td><td>an octet string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if x is equal to y</dd></dl>
<p>Compare two strings </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an octet string </td></tr>
    <tr><td class="paramname">y</td><td>an octet string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if x is not equal to y</dd></dl>
<p>The GOST 28147-89 block cipher uses a set of 4 bit Sboxes, however the standard does not actually define these Sboxes; they are considered a local configuration issue. Several different sets are used.</p>
<p>Perform base64 encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least base64_encode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>is some binary data </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">input_consumed</td><td>is an output parameter which says how many bytes of input were actually consumed. If less than input_length, then the range input[consumed:length] should be passed in later along with more input. </td></tr>
    <tr><td class="paramname">final_inputs</td><td>true iff this is the last input, in which case padding chars will be applied if needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform base64 encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64adecimal representation of input</dd></dl>
<p>Perform base64 decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least base64_decode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>some base64 input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">input_consumed</td><td>is an output parameter which says how many bytes of input were actually consumed. If less than input_length, then the range input[consumed:length] should be passed in later along with more input. </td></tr>
    <tr><td class="paramname">final_inputs</td><td>true iff this is the last input, in which case padding is allowed </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform base64 decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least base64_decode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>some base64 input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform base64 decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least base64_decode_max_output bytes </td></tr>
    <tr><td class="paramname">input</td><td>some base64 input </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform base64 decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some base64 input </td></tr>
    <tr><td class="paramname">input_length</td><td>the length of input in bytes </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded base64 output</dd></dl>
<p>Perform hex encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least input_length*2 bytes </td></tr>
    <tr><td class="paramname">input</td><td>is some binary data </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">uppercase</td><td>should output be upper or lower case?</td></tr>
  </table>
  </dd>
</dl>
<p>Perform hex encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">uppercase</td><td>should output be upper or lower case? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hexadecimal representation of input</dd></dl>
<p>Perform hex decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least input_length/2 bytes </td></tr>
    <tr><td class="paramname">input</td><td>some hex input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">input_consumed</td><td>is an output parameter which says how many bytes of input were actually consumed. If less than input_length, then the range input[consumed:length] should be passed in later along with more input. </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform hex decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least input_length/2 bytes </td></tr>
    <tr><td class="paramname">input</td><td>some hex input </td></tr>
    <tr><td class="paramname">input_length</td><td>length of input in bytes </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform hex decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>an array of at least input_length/2 bytes </td></tr>
    <tr><td class="paramname">input</td><td>some hex input </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to output</dd></dl>
<p>Perform hex decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some hex input </td></tr>
    <tr><td class="paramname">input_length</td><td>the length of input in bytes </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded hex output</dd></dl>
<p>Perform hex decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some hex input </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded hex output Perform hex decoding </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some hex input </td></tr>
    <tr><td class="paramname">input_length</td><td>the length of input in bytes </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded hex output</dd></dl>
<p>Abstract interface to a source of entropy</p>
<p>Filter mixin that breaks input into blocks, useful for cipher modes</p>
<p><a class="el" href="struct_stream.html">Stream</a> output operator; dumps the results from pipe's default message to the output stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>file descriptor for an open output stream </td></tr>
    <tr><td class="paramname">pipe</td><td>the pipe</td></tr>
  </table>
  </dd>
</dl>
<p>File descriptor input operator; dumps the remaining bytes of input to the (assumed open) pipe message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>file descriptor for an open input stream </td></tr>
    <tr><td class="paramname">pipe</td><td>the pipe</td></tr>
  </table>
  </dd>
</dl>
<p>This class represents general abstract filter objects.</p>
<p>Key Derivation Function</p>
<p>Arbitrary precision integer</p>
<p>A const array of all primes less than 65535</p>
<p>Modular Exponentiator Interface</p>
<p>Modular Exponentiator Proxy</p>
<p>Modular Reducer (using Barrett's technique)</p>
<p>Rivest's Package Tranform (Inversion) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cipher</td><td>the block cipher to use (aont_package takes ownership) </td></tr>
    <tr><td class="paramname">input</td><td>the input data buffer </td></tr>
    <tr><td class="paramname">input_len</td><td>the length of the input data in bytes </td></tr>
    <tr><td class="paramname">output</td><td>the output data buffer (must be at least input_len - cipher-&gt;BLOCK_SIZE bytes long)</td></tr>
  </table>
  </dd>
</dl>
<p>Represents a SRP-6a server session</p>
<p>A split secret, using the format from draft-mcgrew-tss-03</p>
<p><a class="el" href="struct_block.html">Block</a> Cipher Mode Padding Method This class is pretty limited, it cannot deal well with randomized padding methods, or any padding method that wants to add more than one block. For instance, it should be possible to define cipher text stealing mode as simply a padding mode for CBC, which happens to consume the last two block (and requires use of the block cipher).</p>
<p>Base class for PBKDF (password based key derivation function) implementations. Converts a password into a key using a salt and iterated hashing to make brute force attacks harder.</p>
<p>Starting in 2.8 this functionality is also offered by PasswordHash. The PBKDF interface may be removed in a future release.</p>
<p>Encoding Method for Encryption</p>
<p>EMSA, from IEEE 1363s Encoding Method for Signatures, Appendix</p>
<p>Any way of encoding/padding signatures</p>
<p>Creates a connection to the TPM. All other TPM types take and hold a TPM_Context reference, so all other objects must be deallocated before ~TPM_Context runs.</p>
<p>Use nullptr for the srk_password to indicate the well known secret (ie, an unencrypted SRK). This is usually what you want.</p>
<p>TODO: handling owner password?</p>
<p>Blinding Function Object.</p>
<p>Exponentiate by the x25519 base point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mypublic</td><td>output value </td></tr>
    <tr><td class="paramname">secret</td><td>random scalar</td></tr>
  </table>
  </dd>
</dl>
<p>This class represents discrete logarithm groups. It holds a prime modulus p, a generator g, and (optionally) a prime q which is a factor of (p-1). In most cases g generates the order-q subgroup.</p>
<p>Class representing an elliptic curve</p>
<p>The internal representation is stored in a shared_ptr, so copying an EC_Group is inexpensive.</p>
<p>Exception thrown if you try to convert a zero point to an affine coordinate Exception thrown if some form of illegal point is decoded This class represents one point on a curve of GF(p)</p>
<p>Perform point decoding Use EC_Group::OS2ECP instead</p>
<p>Deprecated API for point multiplication Use EC_Group::blinded_base_point_multiply or EC_Group::blinded_var_point_multiply</p>
<p><a class="el" href="struct_parameters.html">Parameters</a> for ECIES secret derivation</p>
<p>ECIES secret derivation according to ISO 18033-2</p>
<p>GF(2^m) field for m = [2...16]</p>
<p>Estimate work factor for McEliece </p><dl class="section return"><dt>Returns</dt><dd>estimated security level for these key parameters</dd></dl>
<p>Public Key Base Class.</p>
<p>Public Key Encryptor This is the primary interface for public key encryption</p>
<p>Public Key Decryptor</p>
<p>Public Key Signer. Use the sign_message() functions for small messages. Use multiple calls update() to process large messages and generate the signature by finally calling signature().</p>
<p>Public Key Verifier. Use the verify_message() functions for small messages. Use multiple calls update() to process large messages and verify the signature by finally calling check_signature().</p>
<p>Object used for key agreement</p>
<p>Encryption using a standard message recovery algorithm like RSA or ElGamal, paired with an encoding scheme like OAEP. Decryption with an MR algorithm and an EME. Public Key Key Encapsulation Mechanism Encryption.</p>
<p>Public Key Key Encapsulation Mechanism Decryption.</p>
<p>Estimate work factor for discrete logarithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prime_group_size</td><td>size of the group in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>estimated security level for this group</dd></dl>
<p>Return the appropriate exponent size to use for a particular prime group. This is twice the size of the estimated cost of breaking the key using an index calculus attack; the assumption is that if an arbitrary discrete log on a group of size bits would take about 2^n effort, and thus using an exponent of size 2^(2*n) implies that all available attacks are about as easy (as e.g Pollard's kangaroo algorithm can compute the DL in sqrt(x) operations) while minimizing the exponent size for performance reasons.</p>
<p>Estimate work factor for integer factorization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_bits</td><td>size of modulus in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>estimated security level for this modulus</dd></dl>
<p>Estimate work factor for EC discrete logarithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prime_group_size</td><td>size of the group in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>estimated security level for this group</dd></dl>
<p>A pair of XMSS public and private key.</p>
<p>Descibes a signature method for XMSS, as defined in: [1] XMSS: Extended Hash-Based Signatures, draft-itrf-cfrg-xmss-hash-based-signatures-06 Release: July 2016. <a href="https://datatracker.ietf.org/doc/">https://datatracker.ietf.org/doc/</a> draft-irtf-cfrg-xmss-hash-based-signatures/?include_text=1</p>
<p>An interface to a cryptographic random number generator</p>
<p>Interface for a credentials manager.</p>
<p>A type is a fairly static value that represents the general nature of the transaction occurring. Currently used values are "tls-client" and "tls-server". <a class="el" href="struct_context.html">Context</a> represents a hostname, email address, username, or other identifier.</p>
<p>Called when an assertion fails Throws an Exception object</p>
<p>Struct representing a particular date and time</p>
<p>This class represents an abstract data source object.</p>
<p>Represents a DLL or shared object</p>
<p>Scrub memory contents in a way that a compiler should not elide, using some system specific technique. Note that this function might not zero the memory (for example, in some hypothetical implementation it might combine the memory contents with the output of a system PRNG), but if you can detect any difference in behavior at runtime then the clearing is side-effecting and you can just use <code>clear_mem</code>.</p>
<p>Use this function to scrub memory just before deallocating it, or on a stack buffer before returning from the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to memory to scrub </td></tr>
    <tr><td class="paramname">n</td><td>the number of bytes pointed to by ptr</td></tr>
  </table>
  </dd>
</dl>
<p>Get a human-readable string identifying the version of <a class="el" href="namespace_botan.html">Botan</a>. No particular format should be assumed. </p><dl class="section return"><dt>Returns</dt><dd>version string Same as version_string() except returning a pointer to a statically allocated string. </dd>
<dd>
version string</dd></dl>
<p>Return the date this version of botan was released, in an integer of the form YYYYMMDD. For instance a version released on May 21, 2013 would return the integer 20130521. If the currently running version is not an official release, this function will return 0 instead.</p>
<dl class="section return"><dt>Returns</dt><dd>release date, or zero if unreleased</dd></dl>
<p>Get the major version number. </p><dl class="section return"><dt>Returns</dt><dd>major version number</dd></dl>
<p>Get the minor version number. </p><dl class="section return"><dt>Returns</dt><dd>minor version number</dd></dl>
<p>Get the patch number. </p><dl class="section return"><dt>Returns</dt><dd>patch number</dd></dl>
<p>Convert a status code to a human readable diagnostic message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>the certifcate status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string literal constant, or nullptr if code unknown</dd></dl>
<p>Certificate Store Interface</p>
<p>This class represents CRL entries <a class="el" href="class_test.html">Test</a> two CRL entries for equality in all fields.</p>
<p><a class="el" href="class_test.html">Test</a> two CRL entries for inequality in at least one field.</p>
<p>Wraps the Name Constraints associated with a certificate.</p>
<p>This class represents X.509 Certificate Authorities (CAs).</p>
<p>Distinguished Name</p>
<p>X.509 Certificate Extension</p>
<p>This class represents an X.509 Certificate Check two certificates for inequality </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert1</td><td>The first certificate </td></tr>
    <tr><td class="paramname">cert2</td><td>The second certificate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the arguments represent different certificates, false if they are binary identical</dd></dl>
<p>Specifies restrictions on the <a class="el" href="namespace_botan_1_1_p_k_i_x.html">PKIX</a> path validation</p>
<p>Represents the result of a <a class="el" href="namespace_botan_1_1_p_k_i_x.html">PKIX</a> path validation</p>
<p><a class="el" href="namespace_botan_1_1_p_k_i_x.html">PKIX</a> Path Validation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end_certs</td><td>certificate chain to validate (with end entity certificate in end_certs[0]) </td></tr>
    <tr><td class="paramname">restrictions</td><td>path validation restrictions </td></tr>
    <tr><td class="paramname">trusted_roots</td><td>list of certificate stores that contain trusted certificates </td></tr>
    <tr><td class="paramname">hostname</td><td>if not empty, compared against the DNS name in end_certs[0] </td></tr>
    <tr><td class="paramname">usage</td><td>if not set to UNSPECIFIED, compared against the key usage in end_certs[0] </td></tr>
    <tr><td class="paramname">validation_time</td><td>what reference time to use for validation </td></tr>
    <tr><td class="paramname">ocsp_timeout</td><td>timeout for OCSP operations, 0 disables OCSP check </td></tr>
    <tr><td class="paramname">ocsp_resp</td><td>additional OCSP responses to consider (eg from peer) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the path validation note: when enabled, OCSP check is softfail by default: if the OCSP server is not reachable, Path_Validation_Result::successful_validation() will return true. Hardfail OCSP check can be achieve by also calling Path_Validation_Result::no_warnings().</dd></dl>
<p><a class="el" href="namespace_botan_1_1_p_k_i_x.html">PKIX</a> Path Validation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end_certs</td><td>certificate chain to validate </td></tr>
    <tr><td class="paramname">restrictions</td><td>path validation restrictions </td></tr>
    <tr><td class="paramname">store</td><td>store that contains trusted certificates </td></tr>
    <tr><td class="paramname">hostname</td><td>if not empty, compared against the DNS name in end_certs[0] </td></tr>
    <tr><td class="paramname">usage</td><td>if not set to UNSPECIFIED, compared against the key usage in end_certs[0] </td></tr>
    <tr><td class="paramname">validation_time</td><td>what reference time to use for validation </td></tr>
    <tr><td class="paramname">ocsp_timeout</td><td>timeout for OCSP operations, 0 disables OCSP check </td></tr>
    <tr><td class="paramname">ocsp_resp</td><td>additional OCSP responses to consider (eg from peer) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the path validation</dd></dl>
<p>Options for X.509 certificates. </p>
<p>Encode whatever this object is into to </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>the DER_Encoder that will be written to</td></tr>
  </table>
  </dd>
</dl>
<p>Decode whatever this object is from from </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the BER_Decoder that will be read from</td></tr>
  </table>
  </dd>
</dl>
<p>Return the encoding of this object. This is a convenience method when just one object needs to be serialized. Use DER_Encoder for complicated encodings.</p>
<p>Set up to BER decode the data in buf of length len</p>
<p>Set up to BER decode the data in vec</p>
<p>Set up to BER decode the data in vec</p>
<p>Set up to BER decode the data in src</p>
<p>Set up to BER decode the data in obj</p>
<p>Set up to BER decode the data in obj</p>
<p>Get the next object in the data stream. If EOF, returns an object with type NO_OBJECT.</p>
<p>Push an object back onto the stream. Throws if another object was previously pushed and has not been subsequently read out.</p>
<p>Push an object back onto the stream. Throws if another object was previously pushed and has not been subsequently read out.</p>
<p>Return true if there is at least one more item remaining</p>
<p>Verify the stream is concluded, throws otherwise. Returns (*this)</p>
<p>Verify the stream is concluded, throws otherwise. Returns (*this)</p>
<p>Discard any data that remains unread Returns (*this)</p>
<p>Start decoding a constructed data (sequence or set)</p>
<p>Finish decoding a constructed data, throws if any data remains. Returns the parent of *this (ie the object on which start_cons was called).</p>
<p>Get next object and copy value to POD type Asserts value length is equal to POD type sizeof. Asserts Type tag and optional Class tag according to parameters. Copy value to POD type (struct, union, C-style array, std::array, etc.). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>POD type reference where to copy object value </td></tr>
    <tr><td class="paramname">type_tag</td><td>ASN1_Tag enum to assert type on object read </td></tr>
    <tr><td class="paramname">class_tag</td><td>ASN1_Tag enum to assert class on object read (default: CONTEXT_SPECIFIC) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this reference <br />
<br />
<br />
</dd></dl>
<p>Decode a BER encoded BOOLEAN</p>
<p>Decode an integer value which is typed as an octet string</p>
<p>DER encode, writing to an internal buffer Use get_contents or get_contents_unlocked to read the results after all encoding is completed.</p>
<p>DER encode, writing to</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>If this constructor is used, get_contents* may not be called.</td></tr>
  </table>
  </dd>
</dl>
<p>DER encode, writing to</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>If this constructor is used, get_contents* may not be called.</td></tr>
  </table>
  </dd>
</dl>
<p>DER encode, calling append to write output If this constructor is used, get_contents* may not be called.</p>
<p>Insert raw bytes directly into the output stream</p>
<dl class="section return"><dt>Returns</dt><dd>length of the output of this function in bytes</dd></dl>
<p>Add new input to process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>of param in in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Add new input to process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a secure_vector</td></tr>
  </table>
  </dd>
</dl>
<p>Add new input to process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a std::vector</td></tr>
  </table>
  </dd>
</dl>
<p>Add an integer in big-endian order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the value</td></tr>
  </table>
  </dd>
</dl>
<p>Add new input to process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the input to process as a std::string. Will be interpreted as a byte array based on the strings encoding.</td></tr>
  </table>
  </dd>
</dl>
<p>Process a single byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the byte to process</td></tr>
  </table>
  </dd>
</dl>
<p>Complete the computation and retrieve the final result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The byte array to be filled with the result. Must be of length output_length()</td></tr>
  </table>
  </dd>
</dl>
<p>Complete the computation and retrieve the final result. </p><dl class="section return"><dt>Returns</dt><dd>secure_vector holding the result</dd></dl>
<p>Update and finalize computation. Does the same as calling update() and final() consecutively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the call to final()</dd></dl>
<p>Update and finalize computation. Does the same as calling update() and final() consecutively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the call to final()</dd></dl>
<p>Update and finalize computation. Does the same as calling update() and final() consecutively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the call to final()</dd></dl>
<p>Update and finalize computation. Does the same as calling update() and final() consecutively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the call to final()</dd></dl>
<p>Add more data to the computation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>is an input buffer </td></tr>
    <tr><td class="paramname">length</td><td>is the length of input in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Write the final output to out </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>is an output buffer of output_length()</td></tr>
  </table>
  </dd>
</dl>
<p>Constructor for fixed length keys </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keylen</td><td>the supported key length</td></tr>
  </table>
  </dd>
</dl>
<p>Constructor for variable length keys </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_k</td><td>the smallest supported key length </td></tr>
    <tr><td class="paramname">max_k</td><td>the largest supported key length </td></tr>
    <tr><td class="paramname">k_mod</td><td>the number of bytes the key must be a multiple of</td></tr>
    <tr><td class="paramname">length</td><td>is a key length in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff this length is a valid length for this algo</dd>
<dd>
minimum key length in bytes</dd>
<dd>
maximum key length in bytes</dd>
<dd>
key length multiple in bytes</dd></dl>
<p>Create a SCAN_Name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>A SCAN-format name</td></tr>
  </table>
  </dd>
</dl>
<p>Create a SCAN_Name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>A SCAN-format name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>original input string</dd>
<dd>
algorithm name</dd>
<dd>
number of arguments</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower</td><td>is the lower bound </td></tr>
    <tr><td class="paramname">upper</td><td>is the upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the number of arguments is between lower and upper</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>which argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ith argument</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>which argument </td></tr>
    <tr><td class="paramname">def_value</td><td>the default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ith argument or the default value</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>which argument </td></tr>
    <tr><td class="paramname">def_value</td><td>the default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ith argument as an integer, or the default value</dd>
<dd>
cipher mode (if any)</dd>
<dd>
cipher mode padding (if any)</dd></dl>
<p>Reset the state.</p>
<dl class="section return"><dt>Returns</dt><dd>object describing limits on key size</dd>
<dd>
minimum allowed key length</dd>
<dd>
maximum allowed key length</dd></dl>
<p>Check whether a given key length is valid for this algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the key length to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key length is valid.</dd></dl>
<p>Set the symmetric key of this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the SymmetricKey to be set.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the symmetric key of this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the to be set as a byte array. </td></tr>
    <tr><td class="paramname">length</td><td>in bytes of key param</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the algorithm name</dd></dl>
<p>Run the key schedule </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key </td></tr>
    <tr><td class="paramname">length</td><td>of key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of this octet string in bytes</dd>
<dd>
this object as a secure_vector&lt;uint8_t&gt;</dd>
<dd>
start of this string</dd>
<dd>
end of this string</dd>
<dd>
this encoded as hex</dd></dl>
<p>XOR the contents of another octet string into this one </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>octet string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this</dd></dl>
<p>Force to have odd parity</p>
<p>Create a new OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>is a hex encoded string</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new random OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>is a random number generator </td></tr>
    <tr><td class="paramname">len</td><td>is the desired length in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is an array </td></tr>
    <tr><td class="paramname">len</td><td>is the length of in in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a bytestring</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a bytestring</td></tr>
    <tr><td class="paramname">row</td><td>the row </td></tr>
    <tr><td class="paramname">col</td><td>the column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sbox entry at this row/column</dd>
<dd>
name of this parameter set</dd></dl>
<p>Return a representation used for building larger tables For internal use</p>
<p>Default GOST parameters are the ones given in GOST R 34.11 for testing purposes; these sboxes are also used by Crypto++, and, at least according to Wikipedia, the Central Bank of Russian Federation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>of the parameter set</td></tr>
  </table>
  </dd>
</dl>
<p>Create an instance based on a name, or return null if the algo combination cannot be found.</p>
<p>Create an instance based on a name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name Throws Lookup_Error if not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Begin compressing. Most compression algorithms offer a tunable time/compression tradeoff parameter generally represented by an integer in the range of 1 to 9.</p>
<p>If 0 or a value out of range is provided, a compression algorithm specific default is used.</p>
<p>Process some data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out parameter which will possibly be resized or swapped </td></tr>
    <tr><td class="paramname">offset</td><td>an offset into blocks to begin processing </td></tr>
    <tr><td class="paramname">flush</td><td>if true the compressor will be told to flush state</td></tr>
  </table>
  </dd>
</dl>
<p>Finish compressing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_block</td><td>in/out parameter </td></tr>
    <tr><td class="paramname">offset</td><td>an offset into final_block to begin processing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the compression algorithm</dd></dl>
<p>Reset the state and abort the current message; start can be called again to process a new message.</p>
<p>Create an instance based on a name, or return null if the algo combination cannot be found.</p>
<p>Create an instance based on a name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name Throws Lookup_Error if not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Begin decompressing. Decompression does not support levels, as compression does.</p>
<p>Process some data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out parameter which will possibly be resized or swapped </td></tr>
    <tr><td class="paramname">offset</td><td>an offset into blocks to begin processing</td></tr>
  </table>
  </dd>
</dl>
<p>Finish decompressing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_block</td><td>in/out parameter </td></tr>
    <tr><td class="paramname">offset</td><td>an offset into final_block to begin processing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the decompression algorithm</dd></dl>
<p>Reset the state and abort the current message; start can be called again to process a new message.</p>
<p>Return a new entropy source of a particular type, or null Each entropy source may require substantial resources (eg, a file handle or socket instance), so try to share them among multiple RNGs, or just use the preconfigured global list accessed by Entropy_Sources::global_sources()</p>
<dl class="section return"><dt>Returns</dt><dd>name identifying this entropy source</dd></dl>
<p>Perform an entropy gathering poll </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>will be provided with entropy via calls to add_entropy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>conservative estimate of actual entropy added to rng during poll</dd></dl>
<p>Poll just a single named source. Ordinally only used for testing</p>
<p>Write bytes into the buffered filter, which will them emit them in calls to buffered_block in the subclass </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input bytes </td></tr>
    <tr><td class="paramname">length</td><td>of in in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Finish a message, emitting to buffered_block and buffered_final Will throw an exception if less than final_minimum bytes were written into the filter.</p>
<p>Initialize a Buffered_Filter </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>the function buffered_block will be called with inputs which are a multiple of this size </td></tr>
    <tr><td class="paramname">final_minimum</td><td>the function buffered_final will be called with at least this many bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>The block processor, implemented by subclasses </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input bytes </td></tr>
    <tr><td class="paramname">length</td><td>the size of input, guaranteed to be a multiple of block_size</td></tr>
  </table>
  </dd>
</dl>
<p>The final block, implemented by subclasses </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input bytes </td></tr>
    <tr><td class="paramname">length</td><td>the size of input, guaranteed to be at least final_minimum bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>block size of inputs</dd>
<dd>
current position in the buffer</dd></dl>
<p>Reset the buffer position</p>
<dl class="section return"><dt>Returns</dt><dd>descriptive name for this filter</dd></dl>
<p>Write a portion of a message to this filter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array input</td></tr>
  </table>
  </dd>
</dl>
<p>Start a new message. Must be closed by end_msg() before another message can be started.</p>
<p>Notify that the current message is finished; flush buffers and do end-of-message processing (if any).</p>
<p>Check whether this filter is an attachable filter. </p><dl class="section return"><dt>Returns</dt><dd>true if this filter is attachable, false otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>some input for the filter </td></tr>
    <tr><td class="paramname">length</td><td>the length of in</td></tr>
    <tr><td class="paramname">in</td><td>some input for the filter</td></tr>
    <tr><td class="paramname">in</td><td>some input for the filter</td></tr>
    <tr><td class="paramname">in</td><td>some input for the filter </td></tr>
    <tr><td class="paramname">length</td><td>the number of bytes of in to send</td></tr>
  </table>
  </dd>
</dl>
<p>Start a new message in *this and all following filters. Only for internal use, not intended for use in client applications.</p>
<p>End a new message in *this and all following filters. Only for internal use, not intended for use in client applications.</p>
<p>Set the active port </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_port</td><td>the new value</td></tr>
  </table>
  </dd>
</dl>
<p>Attach another filter to this one </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>filter to attach</td></tr>
    <tr><td class="paramname">filters</td><td>the filters to set </td></tr>
    <tr><td class="paramname">count</td><td>number of items in filters</td></tr>
  </table>
  </dd>
</dl>
<p>Create an instance based on a name If provider is empty then best available is chosen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name </td></tr>
    <tr><td class="paramname">provider</td><td>provider implementation to choose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a null pointer if the algo/provider combination cannot be found</dd></dl>
<p>Create an instance based on a name, or throw if the algo/provider combination cannot be found. If provider is empty then best available is chosen.</p>
<dl class="section return"><dt>Returns</dt><dd>list of available providers for this algorithm, empty if not available</dd>
<dd>
KDF name</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>buffer holding the derived key, must be of length key_len </td></tr>
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">secret_len</td><td>size of secret in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of salt in bytes </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
    <tr><td class="paramname">label_len</td><td>size of label in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">secret_len</td><td>size of secret in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of salt in bytes </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
    <tr><td class="paramname">label_len</td><td>size of label in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of salt in bytes </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">secret_len</td><td>size of secret in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd>
<dd>
new object representing the same algorithm as *this</dd></dl>
<p>Base enumerator for encoding and decoding</p>
<p>Sign symbol definitions for positive and negative numbers</p>
<p>DivideByZero Exception</p>
<p>Create empty BigInt</p>
<p>Create BigInt from 64 bit integer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>initial value of this BigInt</td></tr>
  </table>
  </dd>
</dl>
<p>Copy Constructor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the BigInt to copy</td></tr>
  </table>
  </dd>
</dl>
<p>Create BigInt from a string. If the string starts with 0x the rest of the string will be interpreted as hexadecimal digits. Otherwise, it will be interpreted as a decimal number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to parse for an integer value</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the byte array holding the value </td></tr>
    <tr><td class="paramname">length</td><td>size of buf</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the byte vector holding the value</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the byte array holding the value </td></tr>
    <tr><td class="paramname">length</td><td>size of buf </td></tr>
    <tr><td class="paramname">base</td><td>is the number base of the integer in buf</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the byte array holding the value </td></tr>
    <tr><td class="paramname">length</td><td>size of buf </td></tr>
    <tr><td class="paramname">max_bits</td><td>if the resulting integer is more than max_bits, it will be shifted so it is at most max_bits in length.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an array of words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>the words </td></tr>
    <tr><td class="paramname">length</td><td>number of words</td></tr>
  </table>
  </dd>
</dl>
<p>Create a random BigInt of the specified size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>random number generator </td></tr>
    <tr><td class="paramname">bits</td><td>size in bits </td></tr>
    <tr><td class="paramname">set_high_bit</td><td>if true, the highest bit is always set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>randomize</dd></dl>
<p>Create BigInt of specified size, all zeros </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sign</td><td>the sign </td></tr>
    <tr><td class="paramname">n</td><td>size of the internal register in words</td></tr>
  </table>
  </dd>
</dl>
<p>Move constructor</p>
<p>Move assignment</p>
<p>Copy assignment</p>
<p>Swap this value with another </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>BigInt to swap values with</td></tr>
  </table>
  </dd>
</dl>
<p>+= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to add to this</td></tr>
  </table>
  </dd>
</dl>
<p>+= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the word to add to this</td></tr>
  </table>
  </dd>
</dl>
<p>-= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to subtract from this</td></tr>
  </table>
  </dd>
</dl>
<p>-= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the word to subtract from this</td></tr>
  </table>
  </dd>
</dl>
<p>*= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to multiply with this</td></tr>
  </table>
  </dd>
</dl>
<p>*= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the word to multiply with this</td></tr>
  </table>
  </dd>
</dl>
<p>/= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to divide this by</td></tr>
  </table>
  </dd>
</dl>
<p>Modulo operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the modulus to reduce this by</td></tr>
  </table>
  </dd>
</dl>
<p>Modulo operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the modulus (word) to reduce this by</td></tr>
  </table>
  </dd>
</dl>
<p>Left shift operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>the number of bits to shift this left by</td></tr>
  </table>
  </dd>
</dl>
<p>Right shift operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>the number of bits to shift this right by</td></tr>
  </table>
  </dd>
</dl>
<p>Increment operator</p>
<p>Decrement operator</p>
<p>Postfix increment operator</p>
<p>Postfix decrement operator</p>
<p>Unary negation operator </p><dl class="section return"><dt>Returns</dt><dd>negative this</dd></dl>
<p>! operator </p><dl class="section return"><dt>Returns</dt><dd>true iff this is zero, otherwise false</dd></dl>
<p>Multiply this with y </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to multiply with this </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Square value of *this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Set *this to y - *this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to subtract from as a sequence of words </td></tr>
    <tr><td class="paramname">y_size</td><td>length of y in words </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Set *this to (*this + y) % mod This function assumes *this is &gt;= 0 &amp;&amp; &lt; mod </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to add - assumed y &gt;= 0 and y &lt; mod </td></tr>
    <tr><td class="paramname">mod</td><td>the positive modulus </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Set *this to (*this - y) % mod This function assumes *this is &gt;= 0 &amp;&amp; &lt; mod </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to subtract - assumed y &gt;= 0 and y &lt; mod </td></tr>
    <tr><td class="paramname">mod</td><td>the positive modulus </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Return *this below mod</p>
<p>Assumes that *this is (if anything) only slightly larger than mod and performs repeated subtractions. It should not be used if *this is much larger than mod, instead of modulo operator.</p>
<p>Zeroize the BigInt. The size of the underlying register is not modified.</p>
<p>Compare this to another BigInt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt value to compare with </td></tr>
    <tr><td class="paramname">check_signs</td><td>include sign in comparison? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if (this&lt;n) return -1, if (this&gt;n) return 1, if both values are identical return 0 [like Perl's &lt;=&gt; operator]</dd></dl>
<p>Compare this to an integer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if (this&lt;n) return -1, if (this&gt;n) return 1, if both values are identical return 0 [like Perl's &lt;=&gt; operator]</dd></dl>
<p><a class="el" href="class_test.html">Test</a> if the integer has an even value </p><dl class="section return"><dt>Returns</dt><dd>true if the integer is even, false otherwise</dd></dl>
<p><a class="el" href="class_test.html">Test</a> if the integer has an odd value </p><dl class="section return"><dt>Returns</dt><dd>true if the integer is odd, false otherwise</dd></dl>
<p><a class="el" href="class_test.html">Test</a> if the integer is not zero </p><dl class="section return"><dt>Returns</dt><dd>true if the integer is non-zero, false otherwise</dd></dl>
<p><a class="el" href="class_test.html">Test</a> if the integer is zero </p><dl class="section return"><dt>Returns</dt><dd>true if the integer is zero, false otherwise</dd></dl>
<p>Set bit at specified position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>bit position to set</td></tr>
  </table>
  </dd>
</dl>
<p>Clear bit at specified position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>bit position to clear</td></tr>
  </table>
  </dd>
</dl>
<p>Clear all but the lowest n bits </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>amount of bits to keep</td></tr>
  </table>
  </dd>
</dl>
<p>Return bit value at specified position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the bit offset to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the bit at position n is set, false otherwise</dd></dl>
<p>Return (a maximum of) 32 bits of the complete value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset to start extracting </td></tr>
    <tr><td class="paramname">length</td><td>amount of bits to extract (starting at offset) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer extracted from the register starting at offset with specified length</dd></dl>
<p>Convert this value into a uint32_t, if it is in the range [0 ... 2**32-1], or otherwise throw an exception. </p><dl class="section return"><dt>Returns</dt><dd>the value as a uint32_t if conversion is possible</dd></dl>
<p>Convert this value to a decimal string. Warning: decimal conversions are relatively slow</p>
<p>Convert this value to a hexadecimal string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the offset to get a byte from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte at offset n</dd></dl>
<p>Return the word at a specified position of the internal register </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>position in the register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value at position n</dd></dl>
<p>Tests if the sign of the integer is negative </p><dl class="section return"><dt>Returns</dt><dd>true, iff the integer has a negative sign</dd></dl>
<p>Tests if the sign of the integer is positive </p><dl class="section return"><dt>Returns</dt><dd>true, iff the integer has a positive sign</dd></dl>
<p>Return the sign of the integer </p><dl class="section return"><dt>Returns</dt><dd>the sign of the integer</dd>
<dd>
the opposite sign of the represented integer value</dd></dl>
<p>Flip the sign of this BigInt</p>
<p>Set sign of the integer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sign</td><td>new Sign to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute (positive) value of this</dd></dl>
<p>Give size of internal register </p><dl class="section return"><dt>Returns</dt><dd>size of internal register in words</dd></dl>
<p>Return how many words we need to hold this value </p><dl class="section return"><dt>Returns</dt><dd>significant words of the represented integer value</dd></dl>
<p>Give byte length of the integer </p><dl class="section return"><dt>Returns</dt><dd>byte length of the represented integer value</dd></dl>
<p>Get the bit length of the integer </p><dl class="section return"><dt>Returns</dt><dd>bit length of the represented integer value</dd></dl>
<p>Return a mutable pointer to the register </p><dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the internal register</dd></dl>
<p>Return a const pointer to the register </p><dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the internal register</dd></dl>
<p>Increase internal register buffer to at least n words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>new size of register</td></tr>
  </table>
  </dd>
</dl>
<p>Resize the vector to the minimum word size to hold the integer, or min_size words, whichever is larger</p>
<p>Fill BigInt with a random number with size of bitsize</p>
<p>If <code>set_high_bit</code> is true, the highest bit will be set, which causes the entropy to be <em>bits-1</em>. Otherwise the highest bit is randomly chosen by the rng, causing the entropy to be <em>bits</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">bitsize</td><td>number of bits the created random value should have </td></tr>
    <tr><td class="paramname">set_high_bit</td><td>if true, the highest bit is always set</td></tr>
  </table>
  </dd>
</dl>
<p>Store BigInt-value in a given byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>destination byte array for the integer value</td></tr>
  </table>
  </dd>
</dl>
<p>Read integer value from a byte array with given size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>byte array buffer containing the integer </td></tr>
    <tr><td class="paramname">length</td><td>size of buf</td></tr>
  </table>
  </dd>
</dl>
<p>Read integer value from a byte array (secure_vector&lt;uint8_t&gt;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the array to load from</td></tr>
    <tr><td class="paramname">base</td><td>the base to measure the size for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of this integer in base base</dd></dl>
<p>Place the value into out, zero-padding up to size words Throw if *this cannot be represented in size words</p>
<p>If predicate is true assign other to *this Uses a masked operation to avoid side channels</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">min</td><td>the minimum value (must be non-negative) </td></tr>
    <tr><td class="paramname">max</td><td>the maximum value (must be non-negative and &gt; min) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random integer in [min,max)</dd></dl>
<p>Create a power of two </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the power of two to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bigint representing 2^n</dd></dl>
<p>Encode the integer value from a BigInt to a std::vector of bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>secure_vector of bytes containing the bytes of the integer</dd></dl>
<p>Encode the integer value from a BigInt to a secure_vector of bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>secure_vector of bytes containing the bytes of the integer</dd></dl>
<p>Encode the integer value from a BigInt to a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>destination byte array for the encoded integer </td></tr>
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
    <tr><td class="paramname">length</td><td>size of buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Encode the integer value from a BigInt to a std::vector of bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
    <tr><td class="paramname">base</td><td>number-base of resulting byte array representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>secure_vector of bytes containing the integer with given base</dd></dl>
<p>Encode the integer value from a BigInt to a secure_vector of bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
    <tr><td class="paramname">base</td><td>number-base of resulting byte array representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>secure_vector of bytes containing the integer with given base</dd></dl>
<p>Encode the integer value from a BigInt to a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>destination byte array for the encoded integer value with given base </td></tr>
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
    <tr><td class="paramname">base</td><td>number-base of resulting byte array representation</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
    <tr><td class="paramname">length</td><td>size of buf </td></tr>
    <tr><td class="paramname">base</td><td>number-base of the integer in buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
    <tr><td class="paramname">base</td><td>number-base of the integer in buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
    <tr><td class="paramname">base</td><td>number-base of the integer in buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Encode a BigInt to a byte array according to IEEE 1363 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to encode </td></tr>
    <tr><td class="paramname">bytes</td><td>the length of the resulting secure_vector&lt;uint8_t&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a secure_vector&lt;uint8_t&gt; containing the encoded BigInt</dd></dl>
<p>Encode two BigInt to a byte array according to IEEE 1363 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>the first BigInt to encode </td></tr>
    <tr><td class="paramname">n2</td><td>the second BigInt to encode </td></tr>
    <tr><td class="paramname">bytes</td><td>the length of the encoding of each single BigInt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a secure_vector&lt;uint8_t&gt; containing the concatenation of the two encoded BigInt</dd></dl>
<p>Set output = vec[idx].m_reg in constant time All words of vec must have the same size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modulus</td><td>the modulus </td></tr>
    <tr><td class="paramname">hints</td><td>Passed to set_modulus if modulus &gt; 0 </td></tr>
    <tr><td class="paramname">disable_montgomery_arith</td><td>Disables use of Montgomery representation. Likely only useful for testing.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the base</p>
<p>Set the exponent</p>
<p>All three of the above functions must have already been called. </p><dl class="section return"><dt>Returns</dt><dd>result of g^xp</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modulus</td><td>Optionally call set_modulus </td></tr>
    <tr><td class="paramname">hints</td><td>Passed to set_modulus if modulus &gt; 0 </td></tr>
    <tr><td class="paramname">disable_montgomery_arith</td><td>Disables use of Montgomery representation. Likely only useful for testing.</td></tr>
  </table>
  </dd>
</dl>
<p>Multiply mod p </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first operand </td></tr>
    <tr><td class="paramname">y</td><td>the second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x * y) % p</dd></dl>
<p>Square mod p </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to square </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x * x) % p</dd></dl>
<p>Cube mod p </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to cube </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x * x * x) % p</dd></dl>
<p>Server side step 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the verification value saved from client registration </td></tr>
    <tr><td class="paramname">group_id</td><td>the SRP group id </td></tr>
    <tr><td class="paramname">hash_id</td><td>the SRP hash in use </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SRP-6 B value</dd></dl>
<p>Server side step 2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the client's value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared symmetric key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the number of shares needed to reconstruct </td></tr>
    <tr><td class="paramname">N</td><td>the number of shares generated </td></tr>
    <tr><td class="paramname">secret</td><td>the secret to split </td></tr>
    <tr><td class="paramname">secret_len</td><td>the length of the secret </td></tr>
    <tr><td class="paramname">identifier</td><td>the 16 byte share identifier </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator to use</td></tr>
    <tr><td class="paramname">shares</td><td>the list of shares</td></tr>
    <tr><td class="paramname">hex_input</td><td>the share encoded in hexadecimal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hex representation</dd>
<dd>
share identifier</dd>
<dd>
size of this share in bytes</dd>
<dd>
if this TSS share was initialized or not</dd></dl>
<p>Add padding bytes to buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>data to pad </td></tr>
    <tr><td class="paramname">final_block_bytes</td><td>size of the final block in bytes </td></tr>
    <tr><td class="paramname">block_size</td><td>size of each block in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Remove padding bytes from block </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>the last block </td></tr>
    <tr><td class="paramname">len</td><td>the size of the block in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of data bytes, or if the padding is invalid returns len</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>of the cipher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>valid block size for this padding mode</dd>
<dd>
name of the mode</dd></dl>
<p>virtual destructor</p>
<p>Create an instance based on a name If provider is empty then best available is chosen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name </td></tr>
    <tr><td class="paramname">provider</td><td>provider implementation to choose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a null pointer if the algo/provider combination cannot be found</dd></dl>
<p>Create an instance based on a name, or throw if the algo/provider combination cannot be found. If provider is empty then best available is chosen.</p>
<dl class="section return"><dt>Returns</dt><dd>list of available providers for this algorithm, empty if not available</dd>
<dd>
new instance of this same algorithm</dd>
<dd>
name of this PBKDF</dd></dl>
<p>Derive a key from a passphrase for a number of iterations specified by either iterations or if iterations == 0 then running until msec time has elapsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer to store the derived key, must be of out_len bytes </td></tr>
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more) </td></tr>
    <tr><td class="paramname">msec</td><td>if iterations is zero, then instead the PBKDF is run until msec milliseconds has passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations performed</dd></dl>
<p>Derive a key from a passphrase for a number of iterations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer to store the derived key, must be of out_len bytes </td></tr>
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more)</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase, running until msec time has elapsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer to store the derived key, must be of out_len bytes </td></tr>
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">msec</td><td>if iterations is zero, then instead the PBKDF is run until msec milliseconds has passed. </td></tr>
    <tr><td class="paramname">iterations</td><td>set to the number iterations executed</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase for a number of iterations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key from a passphrase, running until msec time has elapsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">msec</td><td>if iterations is zero, then instead the PBKDF is run until msec milliseconds has passed. </td></tr>
    <tr><td class="paramname">iterations</td><td>set to the number iterations executed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key from a passphrase </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more)</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more)</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">msec</td><td>is how long to run the PBKDF </td></tr>
    <tr><td class="paramname">iterations</td><td>is set to the number of iterations used</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase using a certain amount of time </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">msec</td><td>is how long to run the PBKDF </td></tr>
    <tr><td class="paramname">iterations</td><td>is set to the number of iterations used</td></tr>
  </table>
  </dd>
</dl>
<p>Return the maximum input size in bytes we can support </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keybits</td><td>the size of the key in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upper bound of input in bytes</dd></dl>
<p>Encode an input </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the plaintext </td></tr>
    <tr><td class="paramname">in_length</td><td>length of plaintext in bytes </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bits </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded plaintext</dd></dl>
<p>Encode an input </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the plaintext </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bits </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded plaintext</dd></dl>
<p>Decode an input </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valid_mask</td><td>written to specifies if output is valid </td></tr>
    <tr><td class="paramname">in</td><td>the encoded plaintext </td></tr>
    <tr><td class="paramname">in_len</td><td>length of encoded plaintext in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bytes of out[] written to along with validity mask (0xFF if valid, else 0x00)</dd></dl>
<p>Encode an input </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the plaintext </td></tr>
    <tr><td class="paramname">in_length</td><td>length of plaintext in bytes </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bits </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded plaintext</dd></dl>
<p>Add more data to the signature computation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some data </td></tr>
    <tr><td class="paramname">length</td><td>length of input in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>raw hash</dd></dl>
<p>Return the encoding of a message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the result of raw_data() </td></tr>
    <tr><td class="paramname">output_bits</td><td>the desired output bit size </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded signature</dd></dl>
<p>Verify the encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coded</td><td>the received (coded) message representative </td></tr>
    <tr><td class="paramname">raw</td><td>the computed (local, uncoded) message representative </td></tr>
    <tr><td class="paramname">key_bits</td><td>the size of the key in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if coded is a valid encoding of raw, otherwise false</dd></dl>
<p>Prepare sig_algo for use in choose_sig_format for x509 certs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>used for checking compatibility with the encoding scheme </td></tr>
    <tr><td class="paramname">cert_hash_name</td><td>is checked to equal the hash for the encoding </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>algorithm identifier to signatures created using this key, padding method and hash.</dd>
<dd>
a new object representing the same encoding method as *this</dd>
<dd>
the SCAN name of the encoding/padding scheme</dd></dl>
<p>User callback for getting the PIN. Will be passed the best available description of what we are attempting to load.</p>
<p>Blind a value. The blinding nonce k is freshly generated after BOTAN_BLINDING_REINIT_INTERVAL calls to blind(). BOTAN_BLINDING_REINIT_INTERVAL = 0 means a fresh nonce is only generated once. On every other call, an updated nonce is used for blinding: k' = k*k mod n. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to blind </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>blinded value</dd></dl>
<p>Unblind a value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to unblind </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unblinded value</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modulus</td><td>the modulus </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use for generating the nonce </td></tr>
    <tr><td class="paramname">fwd_func</td><td>a function that calculates the modular exponentiation of the public exponent and the given value (the nonce) </td></tr>
    <tr><td class="paramname">inv_func</td><td>a function that calculates the modular inverse of the given value (the nonce)</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the prime creation for DL groups.</p>
<p>The DL group encoding format variants.</p>
<p>Construct a DL group with uninitialized internal value. Use this constructor is you wish to set the groups values from a DER or PEM encoded group.</p>
<p>Construct a DL group that is registered in the configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name that is configured in the global configuration for the desired group. If no configuration file is specified, the default values from the file policy.cpp will be used. For instance, use "modp/ietf/3072".</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new group randomly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">type</td><td>specifies how the creation of primes p and q shall be performed. If type=Strong, then p will be determined as a safe prime, and q will be chosen as (p-1)/2. If type=Prime_Subgroup and qbits = 0, then the size of q will be determined according to the estimated difficulty of the DL problem. If type=DSA_Kosherizer, DSA primes will be created. </td></tr>
    <tr><td class="paramname">pbits</td><td>the number of bits of p </td></tr>
    <tr><td class="paramname">qbits</td><td>the number of bits of q. Leave it as 0 to have the value determined according to pbits.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a DSA group with a given seed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">seed</td><td>the seed to use to create the random primes </td></tr>
    <tr><td class="paramname">pbits</td><td>the desired bit size of the prime p </td></tr>
    <tr><td class="paramname">qbits</td><td>the desired bit size of the prime q.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a DL group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the prime p </td></tr>
    <tr><td class="paramname">g</td><td>the base g</td></tr>
  </table>
  </dd>
</dl>
<p>Create a DL group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the prime p </td></tr>
    <tr><td class="paramname">q</td><td>the prime q </td></tr>
    <tr><td class="paramname">g</td><td>the base g</td></tr>
  </table>
  </dd>
</dl>
<p>Decode a BER-encoded DL group param</p>
<p>Decode a BER-encoded DL group param</p>
<p>Get the prime p. </p><dl class="section return"><dt>Returns</dt><dd>prime p</dd></dl>
<p>Get the prime q, returns zero if q is not used </p><dl class="section return"><dt>Returns</dt><dd>prime q</dd></dl>
<p>Get the base g. </p><dl class="section return"><dt>Returns</dt><dd>base g</dd></dl>
<p>Perform validity checks on the group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
    <tr><td class="paramname">strong</td><td>whether to perform stronger by lengthier tests </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object is consistent, false otherwise</dd></dl>
<p>Verify a public element, ie check if y = g^x for some x.</p>
<p>This is not a perfect test. It verifies that 1 &lt; y &lt; p and (if q is set) that y is in the subgroup of size q.</p>
<p>Verify a pair of elements y = g^x</p>
<p>This verifies that 1 &lt; x,y &lt; p and that y=g^x mod p</p>
<p>Encode this group into a string using PEM encoding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the encoding format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string holding the PEM encoded group</dd></dl>
<p>Encode this group into a string using DER encoding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the encoding format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string holding the DER encoded group</dd></dl>
<p>Reduce an integer modulo p </p><dl class="section return"><dt>Returns</dt><dd>x % p</dd></dl>
<p>Multiply and reduce an integer modulo p </p><dl class="section return"><dt>Returns</dt><dd>(x*y) % p</dd></dl>
<p>Return the inverse of x mod p</p>
<p>Reduce an integer modulo q Throws if q is unset on this DL_Group </p><dl class="section return"><dt>Returns</dt><dd>x % q</dd></dl>
<p>Multiply and reduce an integer modulo q Throws if q is unset on this DL_Group </p><dl class="section return"><dt>Returns</dt><dd>(x*y) % q</dd></dl>
<p>Multiply and reduce an integer modulo q Throws if q is unset on this DL_Group </p><dl class="section return"><dt>Returns</dt><dd>(x*y*z) % q</dd></dl>
<p>Square and reduce an integer modulo q Throws if q is unset on this DL_Group </p><dl class="section return"><dt>Returns</dt><dd>(x*x) % q</dd></dl>
<p>Return the inverse of x mod q Throws if q is unset on this DL_Group</p>
<p>Modular exponentiation</p>
<dl class="section warning"><dt>Warning</dt><dd>this function leaks the size of x via the number of loop iterations. Use the version taking the maximum size to avoid this.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>(g^x) % p</dd></dl>
<p>Modular exponentiation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the exponent </td></tr>
    <tr><td class="paramname">max_x_bits</td><td>x is assumed to be at most this many bits long.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(g^x) % p</dd></dl>
<p>Multi-exponentiate Return (g^x * y^z) % p</p>
<p>Return parameters for Montgomery reduction/exponentiation mod p</p>
<p>Return the size of p in bits Same as get_p().bits()</p>
<p>Return the size of p in bytes Same as get_p().bytes()</p>
<p>Return the size of q in bits Same as get_q().bits() Throws if q is unset</p>
<p>Return the size of q in bytes Same as get_q().bytes() Throws if q is unset</p>
<p>Return size in bits of a secret exponent</p>
<p>This attempts to balance between the attack costs of NFS (which depends on the size of the modulus) and Pollard's rho (which depends on the size of the exponent).</p>
<p>It may vary over time for a particular group, if the attack costs change.</p>
<p>Return an estimate of the strength of this group against discrete logarithm attacks (eg NFS). Warning: since this only takes into account known attacks it is by necessity an overestimate of the actual strength.</p>
<p>Decode a DER/BER encoded group into this instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ber</td><td>a vector containing the DER/BER encoded group </td></tr>
    <tr><td class="paramname">format</td><td>the format of the encoded group</td></tr>
  </table>
  </dd>
</dl>
<p>Decode a PEM encoded group into this instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pem</td><td>the PEM encoding of the group</td></tr>
  </table>
  </dd>
</dl>
<p>Return PEM representation of named DL group</p>
<p>Construct Domain paramers from specified parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>elliptic curve </td></tr>
    <tr><td class="paramname">base_point</td><td>a base point </td></tr>
    <tr><td class="paramname">order</td><td>the order of the base point </td></tr>
    <tr><td class="paramname">cofactor</td><td>the cofactor</td></tr>
  </table>
  </dd>
</dl>
<p>Construct Domain paramers from specified parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the elliptic curve p </td></tr>
    <tr><td class="paramname">a</td><td>the elliptic curve a param </td></tr>
    <tr><td class="paramname">b</td><td>the elliptic curve b param </td></tr>
    <tr><td class="paramname">base_x</td><td>the x coordinate of the base point </td></tr>
    <tr><td class="paramname">base_y</td><td>the y coordinate of the base point </td></tr>
    <tr><td class="paramname">order</td><td>the order of the base point </td></tr>
    <tr><td class="paramname">cofactor</td><td>the cofactor </td></tr>
    <tr><td class="paramname">oid</td><td>an optional OID used to identify this curve</td></tr>
  </table>
  </dd>
</dl>
<p>Decode a BER encoded ECC domain parameter set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ber_encoding</td><td>the bytes of the BER encoding</td></tr>
  </table>
  </dd>
</dl>
<p>Create an EC domain by OID (or throw if unknown) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>the OID of the EC domain to create</td></tr>
  </table>
  </dd>
</dl>
<p>Create an EC domain from PEM encoding (as from PEM_encode), or from an OID name (eg "secp256r1", or "1.2.840.10045.3.1.7") </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pem_or_oid</td><td>PEM-encoded data, or an OID</td></tr>
  </table>
  </dd>
</dl>
<p>Create an uninitialized EC_Group</p>
<p>Create the DER encoding of this domain </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form</td><td>of encoding to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bytes encododed as DER</dd></dl>
<p>Return the PEM encoding (always in explicit form) </p><dl class="section return"><dt>Returns</dt><dd>string containing PEM data</dd></dl>
<p>Return domain parameter curve </p><dl class="section return"><dt>Returns</dt><dd>domain parameter curve</dd></dl>
<p>Return if a == -3 mod p</p>
<p>Return if a == 0 mod p</p>
<p>Return the size of p in bits (same as get_p().bits())</p>
<p>Return the size of p in bits (same as get_p().bytes())</p>
<p>Return the size of group order in bits (same as get_order().bits())</p>
<p>Return the size of p in bytes (same as get_order().bytes())</p>
<p>Return the prime modulus of the field</p>
<p>Return the a parameter of the elliptic curve equation</p>
<p>Return the b parameter of the elliptic curve equation</p>
<p>Return group base point </p><dl class="section return"><dt>Returns</dt><dd>base point</dd></dl>
<p>Return the x coordinate of the base point</p>
<p>Return the y coordinate of the base point</p>
<p>Return the order of the base point </p><dl class="section return"><dt>Returns</dt><dd>order of the base point</dd></dl>
<p>Return the cofactor </p><dl class="section return"><dt>Returns</dt><dd>the cofactor</dd></dl>
<p>Check if y is a plausible point on the curve</p>
<p>In particular, checks that it is a point on the curve, not infinity, and that it has order matching the group.</p>
<p>Return the OID of these domain parameters </p><dl class="section return"><dt>Returns</dt><dd>the OID as a string</dd></dl>
<p>Return the OID of these domain parameters </p><dl class="section return"><dt>Returns</dt><dd>the OID</dd></dl>
<p>Return a point on this curve with the affine values x, y</p>
<p>Multi exponentiate. Not constant time. </p><dl class="section return"><dt>Returns</dt><dd>base_point*x + pt*y</dd></dl>
<p>Blinded point multiplication, attempts resistance to side channels </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the scalar </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base_point*k</dd></dl>
<p>Blinded point multiplication, attempts resistance to side channels Returns just the x coordinate of the point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the scalar </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x coordinate of base_point*k</dd></dl>
<p>Blinded point multiplication, attempts resistance to side channels </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>input point </td></tr>
    <tr><td class="paramname">k</td><td>the scalar </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point*k</dd></dl>
<p>Return a random scalar ie an integer in [1,order)</p>
<p>Return the zero (or infinite) point on this curve</p>
<p>Verify EC_Group domain </p><dl class="section return"><dt>Returns</dt><dd>true if group is valid. false otherwise</dd></dl>
<p>Return PEM representation of named EC group Deprecated: Use EC_Group(name).PEM_encode() if this is needed</p>
<p>Return a set of known named EC groups</p>
<p>Construct an uninitialized PointGFp</p>
<p>Construct the zero point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>The base curve</td></tr>
  </table>
  </dd>
</dl>
<p>Copy constructor</p>
<p>Move Constructor</p>
<p>Standard Assignment</p>
<p>Move Assignment</p>
<p>Construct a point from its affine coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>the base curve </td></tr>
    <tr><td class="paramname">x</td><td>affine x coordinate </td></tr>
    <tr><td class="paramname">y</td><td>affine y coordinate</td></tr>
  </table>
  </dd>
</dl>
<p>EC2OSP - elliptic curve to octet string primitive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>which format to encode using</td></tr>
  </table>
  </dd>
</dl>
<p>+= Operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the PointGFp to add to the local value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting PointGFp</dd></dl>
<p>-= Operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the PointGFp to subtract from the local value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting PointGFp</dd></dl>
<p>*= Operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the PointGFp to multiply with *this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting PointGFp</dd></dl>
<p>Negate this point </p><dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>get affine x coordinate </p><dl class="section return"><dt>Returns</dt><dd>affine x coordinate</dd></dl>
<p>get affine y coordinate </p><dl class="section return"><dt>Returns</dt><dd>affine y coordinate</dd></dl>
<p>Force this point to affine coordinates</p>
<p>Force all points on the list to affine coordinates</p>
<p>Is this the point at infinity? </p><dl class="section return"><dt>Returns</dt><dd>true, if this point is at infinity, false otherwise.</dd></dl>
<p>Checks whether the point is to be found on the underlying curve; used to prevent fault attacks. </p><dl class="section return"><dt>Returns</dt><dd>if the point is on the curve</dd></dl>
<p>swaps the states of *this and other, does not throw! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to swap values with</td></tr>
  </table>
  </dd>
</dl>
<p>Randomize the point representation The actual value (get_affine_x, get_affine_y) does not change</p>
<p>Randomize the point representation The actual value (get_affine_x, get_affine_y) does not change</p>
<p>Equality operator</p>
<p>Point addition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the point to add to *this </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point addition. Array version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_words</td><td>the words of the x coordinate of the other point </td></tr>
    <tr><td class="paramname">x_size</td><td>size of x_words </td></tr>
    <tr><td class="paramname">y_words</td><td>the words of the y coordinate of the other point </td></tr>
    <tr><td class="paramname">y_size</td><td>size of y_words </td></tr>
    <tr><td class="paramname">z_words</td><td>the words of the z coordinate of the other point </td></tr>
    <tr><td class="paramname">z_size</td><td>size of z_words </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point addition - mixed J+A </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>affine point to add - assumed to be affine! </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point addition - mixed J+A. Array version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_words</td><td>the words of the x coordinate of the other point </td></tr>
    <tr><td class="paramname">x_size</td><td>size of x_words </td></tr>
    <tr><td class="paramname">y_words</td><td>the words of the y coordinate of the other point </td></tr>
    <tr><td class="paramname">y_size</td><td>size of y_words </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point doubling </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Repeated point doubling </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>number of doublings to perform </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point addition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the point to add to *this </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>other plus *this</dd></dl>
<p>Point doubling </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this doubled</dd></dl>
<p>Return the zero (aka infinite) point associated with this curve</p>
<p>Return base curve of this point </p><dl class="section return"><dt>Returns</dt><dd>the curve over GF(p) of this point</dd></dl>
<p>You should not need to use this</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>ec domain parameters of the involved ec keys </td></tr>
    <tr><td class="paramname">kdf_spec</td><td>name of the key derivation function </td></tr>
    <tr><td class="paramname">length</td><td>length of the secret to be derived </td></tr>
    <tr><td class="paramname">compression_type</td><td>format of encoded keys (affects the secret derivation if single_hash_mode is used) </td></tr>
    <tr><td class="paramname">flags</td><td>options, see documentation of ECIES_Flags</td></tr>
    <tr><td class="paramname">private_key</td><td>the (ephemeral) private key which is used to derive the secret </td></tr>
    <tr><td class="paramname">ecies_params</td><td>settings for ecies </td></tr>
    <tr><td class="paramname">for_encryption</td><td>disable cofactor mode if the secret will be used for encryption (according to ISO 18033 cofactor mode is only used during decryption) </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use</td></tr>
  </table>
  </dd>
</dl>
<p>Performs a key agreement with the provided keys and derives the secret from the result </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eph_public_key_bin</td><td>the encoded (ephemeral) public key which belongs to the used (ephemeral) private key </td></tr>
    <tr><td class="paramname">other_public_key_point</td><td>public key point of the other party</td></tr>
  </table>
  </dd>
</dl>
<p>zero operand allowed</p>
<p>non-zero operand</p>
<p>Get the name of the underlying public key scheme. </p><dl class="section return"><dt>Returns</dt><dd>name of the public key scheme</dd></dl>
<p>Return the estimated strength of the underlying key against the best currently known attack. Note that this ignores anything but pure attacks against the key itself and do not take into account padding schemes, usage mistakes, etc which might reduce the strength. However it does suffice to provide an upper bound.</p>
<dl class="section return"><dt>Returns</dt><dd>estimated strength in bits</dd></dl>
<p>Return an integer value best approximating the length of the primary security parameter. For example for RSA this will be the size of the modulus, for ECDSA the size of the ECC group, and for McEliece the size of the code will be returned.</p>
<p>Get the OID of the underlying public key scheme. </p><dl class="section return"><dt>Returns</dt><dd>OID of the public key scheme</dd></dl>
<p><a class="el" href="class_test.html">Test</a> the key values for consistency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>rng to use </td></tr>
    <tr><td class="paramname">strong</td><td>whether to perform strong and lengthy version of the test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the test is passed</dd>
<dd>
X.509 AlgorithmIdentifier for this key</dd>
<dd>
BER encoded public key bits</dd>
<dd>
X.509 subject key encoding for this key object</dd>
<dd>
Hash of the subject public key</dd></dl>
<p>Returns more than 1 if the output of this algorithm (ciphertext, signature) should be treated as more than one value. This is used for algorithms like DSA and ECDSA, where the (r,s) output pair can be encoded as either a plain binary list or a TLV tagged DER encoding depending on the protocol.</p>
<p>This function is public but applications should have few reasons to ever call this.</p>
<dl class="section return"><dt>Returns</dt><dd>number of message parts</dd></dl>
<p>Returns how large each of the message parts refered to by message_parts() is</p>
<p>This function is public but applications should have few reasons to ever call this.</p>
<dl class="section return"><dt>Returns</dt><dd>size of the message parts in bits</dd></dl>
<p>This is an internal library function exposed on key types. In almost all cases applications should use wrappers in <a class="el" href="pubkey_8h_source.html">pubkey.h</a></p>
<p>Return an encryption operation for this key/params or throw</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator. The PK_Op may maintain a reference to the RNG and use it many times. The rng must outlive any operations which reference it. </td></tr>
    <tr><td class="paramname">params</td><td>additional parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>This is an internal library function exposed on key types. In almost all cases applications should use wrappers in <a class="el" href="pubkey_8h_source.html">pubkey.h</a></p>
<p>Return a KEM encryption operation for this key/params or throw</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator. The PK_Op may maintain a reference to the RNG and use it many times. The rng must outlive any operations which reference it. </td></tr>
    <tr><td class="paramname">params</td><td>additional parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>This is an internal library function exposed on key types. In almost all cases applications should use wrappers in <a class="el" href="pubkey_8h_source.html">pubkey.h</a></p>
<p>Return a verification operation for this key/params or throw </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>additional parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Encrypt a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array </td></tr>
    <tr><td class="paramname">rng</td><td>the random number source to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted message</dd></dl>
<p>Encrypt a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message </td></tr>
    <tr><td class="paramname">rng</td><td>the random number source to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted message</dd></dl>
<p>Return the maximum allowed message size in bytes. </p><dl class="section return"><dt>Returns</dt><dd>maximum message size in bytes</dd></dl>
<p>Return an upper bound on the ciphertext length</p>
<p>Decrypt a ciphertext, throwing an exception if the input seems to be invalid (eg due to an accidental or malicious error in the ciphertext).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the ciphertext as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decrypted message</dd></dl>
<p>Same as above, but taking a vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the ciphertext </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decrypted message</dd></dl>
<p>Decrypt a ciphertext. If the ciphertext is invalid (eg due to invalid padding) or is not the expected length, instead returns a random string of the expected length. Use to avoid oracle attacks, especially against PKCS #1 v1.5 decryption.</p>
<p>Decrypt a ciphertext. If the ciphertext is invalid (eg due to invalid padding) or is not the expected length, instead returns a random string of the expected length. Use to avoid oracle attacks, especially against PKCS #1 v1.5 decryption.</p>
<p>Additionally checks (also in const time) that: contents[required_content_offsets[i]] == required_content_bytes[i] for 0 &lt;= i &lt; required_contents</p>
<p>Used for example in TLS, which encodes the client version in the content bytes: if there is any timing variation the version check can be used as an oracle to recover the key.</p>
<p>Return an upper bound on the plaintext length for a particular ciphertext input length</p>
<p>Construct a PK Signer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to use inside this signer </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use </td></tr>
    <tr><td class="paramname">emsa</td><td>the EMSA to use An example would be "EMSA1(SHA-224)". </td></tr>
    <tr><td class="paramname">format</td><td>the signature format to use </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Sign a message all in one go </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message to sign as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array </td></tr>
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signature</dd></dl>
<p>Sign a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message to sign </td></tr>
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signature</dd></dl>
<p>Add a message part (single byte). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the byte to add</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message part to add as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message part to add</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message part to add</td></tr>
  </table>
  </dd>
</dl>
<p>Get the signature of the so far processed message (provided by the calls to update()). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signature of the total message</dd></dl>
<p>Set the output format of the signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the signature format to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return an upper bound on the length of the signatures this PK_Signer will produce</p>
<p>Construct a PK Verifier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pub_key</td><td>the public key to verify against </td></tr>
    <tr><td class="paramname">emsa</td><td>the EMSA to use (eg "EMSA3(SHA-1)") </td></tr>
    <tr><td class="paramname">format</td><td>the signature format to use </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Verify a signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message that the signature belongs to, as a byte array </td></tr>
    <tr><td class="paramname">msg_length</td><td>the length of the above byte array msg </td></tr>
    <tr><td class="paramname">sig</td><td>the signature as a byte array </td></tr>
    <tr><td class="paramname">sig_length</td><td>the length of the above byte array sig </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the signature is valid</dd></dl>
<p>Verify a signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message that the signature belongs to </td></tr>
    <tr><td class="paramname">sig</td><td>the signature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the signature is valid</dd></dl>
<p>Add a message part (single byte) of the message corresponding to the signature to be verified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the byte to add</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part of the message corresponding to the signature to be verified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_part</td><td>the new message part as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part of the message corresponding to the signature to be verified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the new message part</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part of the message corresponding to the signature to be verified.</p>
<p>Check the signature of the buffered message, i.e. the one build by successive calls to update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature to be verified as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the signature is valid, false otherwise</dd></dl>
<p>Check the signature of the buffered message, i.e. the one build by successive calls to update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature to be verified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the signature is valid, false otherwise</dd></dl>
<p>Set the format of the signatures fed to this verifier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the signature format to use</td></tr>
  </table>
  </dd>
</dl>
<p>Construct a PK Key Agreement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to use </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use </td></tr>
    <tr><td class="paramname">kdf</td><td>name of the KDF to use (or 'Raw' for no KDF) </td></tr>
    <tr><td class="paramname">provider</td><td>the algo provider to use (or empty for default)</td></tr>
  </table>
  </dd>
</dl>
<p>Perform Key Agreement Operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired key output size </td></tr>
    <tr><td class="paramname">in</td><td>the other parties key </td></tr>
    <tr><td class="paramname">in_len</td><td>the length of in in bytes </td></tr>
    <tr><td class="paramname">params</td><td>extra derivation params </td></tr>
    <tr><td class="paramname">params_len</td><td>the length of params in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Perform Key Agreement Operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired key output size </td></tr>
    <tr><td class="paramname">in</td><td>the other parties key </td></tr>
    <tr><td class="paramname">params</td><td>extra derivation params </td></tr>
    <tr><td class="paramname">params_len</td><td>the length of params in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Perform Key Agreement Operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired key output size </td></tr>
    <tr><td class="paramname">in</td><td>the other parties key </td></tr>
    <tr><td class="paramname">in_len</td><td>the length of in in bytes </td></tr>
    <tr><td class="paramname">params</td><td>extra derivation params</td></tr>
  </table>
  </dd>
</dl>
<p>Perform Key Agreement Operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired key output size </td></tr>
    <tr><td class="paramname">in</td><td>the other parties key </td></tr>
    <tr><td class="paramname">params</td><td>extra derivation params</td></tr>
  </table>
  </dd>
</dl>
<p>Return the underlying size of the value that is agreed. If derive_key is called with a length of 0 with a "Raw" KDF, it will return a value of this size.</p>
<p>Construct an instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to use inside the encryptor </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use </td></tr>
    <tr><td class="paramname">kem_param</td><td>additional KEM parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Generate a shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_encapsulated_key</td><td>the generated encapsulated key </td></tr>
    <tr><td class="paramname">out_shared_key</td><td>the generated shared key </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use </td></tr>
    <tr><td class="paramname">salt</td><td>a salt value used in the KDF </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of the salt value in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Generate a shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_encapsulated_key</td><td>the generated encapsulated key </td></tr>
    <tr><td class="paramname">out_shared_key</td><td>the generated shared key </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use </td></tr>
    <tr><td class="paramname">salt</td><td>a salt value used in the KDF</td></tr>
  </table>
  </dd>
</dl>
<p>Generate a shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_encapsulated_key</td><td>the generated encapsulated key </td></tr>
    <tr><td class="paramname">out_shared_key</td><td>the generated shared key </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use</td></tr>
  </table>
  </dd>
</dl>
<p>Construct an instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to use inside the decryptor </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use </td></tr>
    <tr><td class="paramname">kem_param</td><td>additional KEM parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Decrypts the shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encap_key</td><td>the encapsulated key </td></tr>
    <tr><td class="paramname">encap_key_len</td><td>size of the encapsulated key in bytes </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a salt value used in the KDF </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of the salt value in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shared data encryption key</dd></dl>
<p>Decrypts the shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encap_key</td><td>the encapsulated key </td></tr>
    <tr><td class="paramname">encap_key_len</td><td>size of the encapsulated key in bytes </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shared data encryption key</dd></dl>
<p>Decrypts the shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encap_key</td><td>the encapsulated key </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a salt value used in the KDF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shared data encryption key</dd></dl>
<p>Note: keeps persistent reference to order</p>
<dl class="section return"><dt>Returns</dt><dd>XMSS registry name for the chosen parameter set.</dd></dl>
<p>Retrieves the uniform length of a message, and the size of each node. This correlates to XMSS parameter "n" defined in [1].</p>
<dl class="section return"><dt>Returns</dt><dd>element length in bytes.</dd>
<dd>
The height (number of levels - 1) of the tree</dd></dl>
<p>The Winternitz parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>numeric base used for internal representation of data.</dd></dl>
<p>Returns the estimated pre-quantum security level of the chosen algorithm.</p>
<p>Randomize a byte array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the byte array to hold the random output. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array output in bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns false if it is known that this RNG object is not able to accept externally provided inputs (via add_entropy, randomize_with_input, etc). In this case, any such provided inputs are ignored.</p>
<p>If this function returns true, then inputs may or may not be accepted.</p>
<p>Incorporate some additional data into the RNG state. For example adding nonces or timestamps from a peer's protocol message can help hedge against VM state rollback attacks. A few RNG types do not accept any externally provided input, in which case this function is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a byte array containg the entropy to be added </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array in</td></tr>
  </table>
  </dd>
</dl>
<p>Incorporate some additional data into the RNG state.</p>
<p>Incorporate entropy into the RNG state then produce output. Some RNG types implement this using a single operation, default calls add_entropy + randomize in sequence.</p>
<p>Use this to further bind the outputs to your current process/protocol state. For instance if generating a new key for use in a session, include a session ID or other such value. See NIST SP 800-90 A, B, C series for more ideas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>buffer to hold the random output </td></tr>
    <tr><td class="paramname">output_len</td><td>size of the output buffer in bytes </td></tr>
    <tr><td class="paramname">input</td><td>entropy buffer to incorporate </td></tr>
    <tr><td class="paramname">input_len</td><td>size of the input buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>This calls <code>randomize_with_input</code> using some timestamps as extra input.</p>
<p>For a stateful RNG using non-random but potentially unique data the extra input can help protect against problems with fork, VM state rollback, or other cases where somehow an RNG state is duplicated. If both of the duplicated RNG states later incorporate a timestamp (and the timestamps don't themselves repeat), their outputs will diverge.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of this RNG type</dd></dl>
<p>Clear all internally held values of this RNG </p><dl class="section post"><dt>Postcondition</dt><dd>is_seeded() == false</dd></dl>
<p>Check whether this RNG is seeded. </p><dl class="section return"><dt>Returns</dt><dd>true if this RNG was already seeded, false otherwise.</dd></dl>
<p>Poll provided sources for up to poll_bits bits of entropy or until the timeout expires. Returns estimate of the number of bits collected.</p>
<p>Reseed by reading specified bits from the RNG</p>
<p>Return a random vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>number of bytes in the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>randomized vector of length bytes</dd></dl>
<p>Return a random byte </p><dl class="section return"><dt>Returns</dt><dd>random byte</dd>
<dd>
a random byte that is greater than zero</dd></dl>
<p>Create a seeded and active RNG object for general application use Added in 1.8.0 Use AutoSeeded_RNG instead</p>
<p>Return a list of the certificates of CAs that we trust in this type/context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring</td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. For instance for type "tls-client", context specifies the servers name.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a cert chain we can use, ordered from leaf to root, or else an empty vector.</p>
<p>It is assumed that the caller can get the private key of the leaf with private_key_for</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_key_types</td><td>specifies the key types desired ("RSA", "DSA", "ECDSA", etc), or empty if there is no preference by the caller.</td></tr>
    <tr><td class="paramname">acceptable_CAs</td><td>the CAs the requestor will accept (possibly empty) </td></tr>
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a cert chain we can use, ordered from leaf to root, or else an empty vector.</p>
<p>This virtual function is deprecated, and will be removed in a future release. Use (and override) find_cert_chain instead.</p>
<p>It is assumed that the caller can get the private key of the leaf with private_key_for</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_key_types</td><td>specifies the key types desired ("RSA", "DSA", "ECDSA", etc), or empty if there is no preference by the caller.</td></tr>
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring</td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a cert chain we can use, ordered from leaf to root, or else an empty vector.</p>
<p>It is assumed that the caller can get the private key of the leaf with private_key_for</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_key_type</td><td>specifies the type of key requested ("RSA", "DSA", "ECDSA", etc)</td></tr>
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring</td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>private key associated with this certificate if we should use it with this context. cert was returned by cert_chain </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this object should retain ownership of the returned key; it should not be deleted by the caller.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we should attempt SRP authentication</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>identifier for client-side SRP auth, if available for this type/context. Should return empty string if password auth not desired/available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
    <tr><td class="paramname">identifier</td><td>specifies what identifier we want the password for. This will be a value previously returned by srp_identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>password for client-side SRP auth, if available for this identifier/type/context.</dd></dl>
<p>Retrieve SRP verifier parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the PSK identity hint for this type/context</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
    <tr><td class="paramname">identity_hint</td><td>was passed by the server (but may be empty) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the PSK identity we want to use</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
    <tr><td class="paramname">identity</td><td>is a PSK identity previously returned by psk_identity for the same type and context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the PSK used for identity, or throw an exception if no key exists</dd></dl>
<p>The year <br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 The month, 1 through 12 for Jan to Dec <br />
<br />
<br />
<br />
<br />
<br />
<br />
 The day of the month, 1 through 31 (or 28 or 30 based on month <br />
<br />
<br />
<br />
<br />
<br />
 Hour in 24-hour form, 0 to 23 <br />
<br />
<br />
<br />
<br />
 Minutes in the hour, 0 to 60 <br />
</p><pre class="fragment">Seconds in the minute, 0 to 60, but might be slightly
</pre><p> larger to deal with leap seconds on some systems</p>
<p>Initialize a calendar_point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the year </td></tr>
    <tr><td class="paramname">mon</td><td>the month </td></tr>
    <tr><td class="paramname">d</td><td>the day </td></tr>
    <tr><td class="paramname">h</td><td>the hour </td></tr>
    <tr><td class="paramname">min</td><td>the minute </td></tr>
    <tr><td class="paramname">sec</td><td>the second</td></tr>
  </table>
  </dd>
</dl>
<p>Returns an STL timepoint object</p>
<p>Returns a human readable string of the struct's components. Formatting might change over time. Currently it is RFC339 'iso-date-time'.</p>
<p>Read from the source. Moves the internal offset so that every call to read will return a new portion of the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the byte array to write the result to </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array out </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes that was actually read and put into out</dd></dl>
<p>Read from the source but do not modify the internal offset. Consecutive calls to peek() will return portions of the source starting at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the byte array to write the output to </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array out </td></tr>
    <tr><td class="paramname">peek_offset</td><td>the offset into the stream to read at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes that was actually read and put into out</dd></dl>
<p><a class="el" href="class_test.html">Test</a> whether the source still has data that can be read. </p><dl class="section return"><dt>Returns</dt><dd>true if there is no more data to read, false otherwise</dd></dl>
<p>return the id of this data source </p><dl class="section return"><dt>Returns</dt><dd>std::string representing the id of this data source</dd></dl>
<p>Read one byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the byte to read to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes that was actually read and put into out</dd></dl>
<p>Peek at one byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>an output byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes that was actually read and put into out</dd></dl>
<p>Discard the next N bytes of the data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>the number of bytes to discard </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes actually discarded</dd>
<dd>
number of bytes read so far.</dd></dl>
<p>Load a DLL (or fail with an exception) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lib_name</td><td>name or path to a library</td></tr>
  </table>
  </dd>
</dl>
<p>If you don't use a full path, the search order will be defined by whatever the system linker does by default. Always using fully qualified pathnames can help prevent code injection attacks (eg via manipulation of LD_LIBRARY_PATH on Linux)</p>
<p>Unload the DLL </p><dl class="section warning"><dt>Warning</dt><dd>Any pointers returned by resolve()/resolve_symbol() should not be used after this destructor runs.</dd></dl>
<p>Load a symbol (or fail with an exception) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>names the symbol to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the loaded symbol</dd></dl>
<p>Convenience function for casting symbol to the right type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>names the symbol to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the loaded symbol</dd></dl>
<p>Find a certificate by Subject DN and (optionally) key identifier </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject_dn</td><td>the subject's distinguished name </td></tr>
    <tr><td class="paramname">key_id</td><td>an optional key id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matching certificate or nullptr otherwise</dd></dl>
<p>Find all certificates with a given Subject DN. Subject DN and even the key identifier might not be unique.</p>
<p>Find a certificate by searching for one with a matching SHA-1 hash of public key. Used for OCSP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_hash</td><td>SHA-1 hash of the subject's public key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matching certificate or nullptr otherwise</dd></dl>
<p>Find a certificate by searching for one with a matching SHA-256 hash of raw subject name. Used for OCSP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject_hash</td><td>SHA-256 hash of the subject's raw name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matching certificate or nullptr otherwise</dd></dl>
<p>Finds a CRL for the given certificate </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>the subject certificate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the CRL for subject or nullptr otherwise</dd>
<dd>
whether the certificate is known </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>certififcate to be searched</td></tr>
  </table>
  </dd>
</dl>
<p>Creates an empty name NameConstraints.</p>
<p>Creates NameConstraints from a list of permitted and excluded subtrees. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permitted_subtrees</td><td>names for which the certificate is permitted </td></tr>
    <tr><td class="paramname">excluded_subtrees</td><td>names for which the certificate is not permitted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>permitted names</dd>
<dd>
excluded names</dd></dl>
<p>Sign a PKCS#10 <a class="el" href="struct_request.html">Request</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>the request to sign </td></tr>
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
    <tr><td class="paramname">not_before</td><td>the starting time for the certificate </td></tr>
    <tr><td class="paramname">not_after</td><td>the expiration time for the certificate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting certificate</dd></dl>
<p>Sign a PKCS#10 <a class="el" href="struct_request.html">Request</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>the request to sign </td></tr>
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
    <tr><td class="paramname">serial_number</td><td>the serial number the cert will be assigned. </td></tr>
    <tr><td class="paramname">not_before</td><td>the starting time for the certificate </td></tr>
    <tr><td class="paramname">not_after</td><td>the expiration time for the certificate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting certificate</dd></dl>
<p>Get the certificate of this CA. </p><dl class="section return"><dt>Returns</dt><dd>CA certificate</dd></dl>
<p>Create a new and empty CRL for this CA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">issue_time</td><td>the issue time (typically system_clock::now) </td></tr>
    <tr><td class="paramname">next_update</td><td>the time interval after issue_data within which a new CRL will be produced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new CRL</dd></dl>
<p>Create a new CRL by with additional entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">last_crl</td><td>the last CRL of this CA to add the new entries to </td></tr>
    <tr><td class="paramname">new_entries</td><td>contains the new CRL entries to be added to the CRL </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">issue_time</td><td>the issue time (typically system_clock::now) </td></tr>
    <tr><td class="paramname">next_update</td><td>the time interval after issue_data within which a new CRL will be produced.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new and empty CRL for this CA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">next_update</td><td>the time to set in next update in seconds as the offset from the current time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new CRL</dd></dl>
<p>Create a new CRL by with additional entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">last_crl</td><td>the last CRL of this CA to add the new entries to </td></tr>
    <tr><td class="paramname">new_entries</td><td>contains the new CRL entries to be added to the CRL </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">next_update</td><td>the time to set in next update in seconds as the offset from the current time</td></tr>
  </table>
  </dd>
</dl>
<p>Interface for creating new certificates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signer</td><td>a signing object </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">sig_algo</td><td>the signature algorithm identifier </td></tr>
    <tr><td class="paramname">pub_key</td><td>the serialized public key </td></tr>
    <tr><td class="paramname">not_before</td><td>the start time of the certificate </td></tr>
    <tr><td class="paramname">not_after</td><td>the end time of the certificate </td></tr>
    <tr><td class="paramname">issuer_dn</td><td>the DN of the issuer </td></tr>
    <tr><td class="paramname">subject_dn</td><td>the DN of the subject </td></tr>
    <tr><td class="paramname">extensions</td><td>an optional list of certificate extensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly minted certificate</dd></dl>
<p>Interface for creating new certificates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signer</td><td>a signing object </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">serial_number</td><td>the serial number the cert will be assigned </td></tr>
    <tr><td class="paramname">sig_algo</td><td>the signature algorithm identifier </td></tr>
    <tr><td class="paramname">pub_key</td><td>the serialized public key </td></tr>
    <tr><td class="paramname">not_before</td><td>the start time of the certificate </td></tr>
    <tr><td class="paramname">not_after</td><td>the end time of the certificate </td></tr>
    <tr><td class="paramname">issuer_dn</td><td>the DN of the issuer </td></tr>
    <tr><td class="paramname">subject_dn</td><td>the DN of the subject </td></tr>
    <tr><td class="paramname">extensions</td><td>an optional list of certificate extensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly minted certificate</dd></dl>
<p>Create a new CA object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ca_certificate</td><td>the certificate of the CA </td></tr>
    <tr><td class="paramname">key</td><td>the private key of the CA </td></tr>
    <tr><td class="paramname">hash_fn</td><td>name of a hash function to use for signing </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new CA object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ca_certificate</td><td>the certificate of the CA </td></tr>
    <tr><td class="paramname">key</td><td>the private key of the CA </td></tr>
    <tr><td class="paramname">opts</td><td>additional options, e.g. padding, as key value pairs </td></tr>
    <tr><td class="paramname">hash_fn</td><td>name of a hash function to use for signing </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OID representing this extension</dd></dl>
<p>Make a copy of this extension </p><dl class="section return"><dt>Returns</dt><dd>copy of this</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">require_rev</td><td>if true, revocation information is required</td></tr>
    <tr><td class="paramname">minimum_key_strength</td><td>is the minimum strength (in terms of operations, eg 80 means 2^80) of a signature. Signatures weaker than this are rejected. If more than 80, SHA-1 signatures are also rejected. If possible use at least setting 110. <pre class="fragment">80 bit strength requires 1024 bit RSA
110 bit strength requires 2k bit RSA
128 bit strength requires ~3k bit RSA or P-256
</pre> </td></tr>
    <tr><td class="paramname">ocsp_all_intermediates</td><td>Make OCSP requests for all CAs as well as end entity (if OCSP enabled in path validation request)</td></tr>
    <tr><td class="paramname">require_rev</td><td>if true, revocation information is required </td></tr>
    <tr><td class="paramname">minimum_key_strength</td><td>is the minimum strength (in terms of operations, eg 80 means 2^80) of a signature. Signatures weaker than this are rejected. </td></tr>
    <tr><td class="paramname">ocsp_all_intermediates</td><td>Make OCSP requests for all CAs as well as end entity (if OCSP enabled in path validation request) </td></tr>
    <tr><td class="paramname">trusted_hashes</td><td>a set of trusted hashes. Any signatures created using a hash other than one of these will be rejected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether revocation information is required</dd>
<dd>
whether all intermediate CAs should also be OCSPed. If false then only end entity OCSP is required/requested.</dd>
<dd>
trusted signature hash functions</dd>
<dd>
minimum required key strength</dd>
<dd>
the set of hash functions you are implicitly trusting by trusting this result.</dd>
<dd>
the trust root of the validation if successful throws an exception if the validation failed</dd>
<dd>
the full path from subject to trust root This path may be empty</dd>
<dd>
true iff the validation was successful</dd>
<dd>
true iff no warnings occured during validation</dd>
<dd>
overall validation result code</dd>
<dd>
a set of status codes for each certificate in the chain</dd>
<dd>
the subset of status codes that are warnings</dd>
<dd>
string representation of the validation result</dd>
<dd>
string representation of the warnings</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>validation status code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>corresponding validation status message</dd></dl>
<p>Create a Path_Validation_Result </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>list of validation status codes </td></tr>
    <tr><td class="paramname">cert_chain</td><td>the certificate chain that was validated</td></tr>
  </table>
  </dd>
</dl>
<p>Create a Path_Validation_Result </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>validation status code</td></tr>
  </table>
  </dd>
</dl>
<p>the subject common name</p>
<p>the subject counry</p>
<p>the subject organization</p>
<p>the subject organizational unit</p>
<p>the subject locality</p>
<p>the subject state</p>
<p>the subject serial number</p>
<p>the subject email adress</p>
<p>the subject URI</p>
<p>the subject IPv4 address</p>
<p>the subject DNS</p>
<p>the subject XMPP</p>
<p>the subject challenge password</p>
<p>the subject notBefore</p>
<p>the subject notAfter</p>
<p>Indicates whether the certificate request</p>
<p>Indicates the BasicConstraints path limit</p>
<p>The key constraints for the subject public key</p>
<p>The key extended constraints for the subject public key</p>
<p>Additional X.509 extensions</p>
<p>Mark the certificate as a CA certificate and set the path limit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>the path limit to be set in the BasicConstraints extension.</td></tr>
  </table>
  </dd>
</dl>
<p>Choose a padding scheme different from the default for the key used.</p>
<p>Set the notBefore of the certificate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the notBefore value of the certificate</td></tr>
  </table>
  </dd>
</dl>
<p>Set the notAfter of the certificate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the notAfter value of the certificate</td></tr>
  </table>
  </dd>
</dl>
<p>Add the key constraints of the KeyUsage extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constr</td><td>the constraints to set</td></tr>
  </table>
  </dd>
</dl>
<p>Add constraints to the ExtendedKeyUsage extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>the oid to add</td></tr>
  </table>
  </dd>
</dl>
<p>Add constraints to the ExtendedKeyUsage extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name to look up the oid to add</td></tr>
  </table>
  </dd>
</dl>
<p>Construct a new options object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>define the common name of this object. An example for this parameter would be "common_name/country/organization/organizational_unit". </td></tr>
    <tr><td class="paramname">expire_time</td><td>the expiration time (from the current clock in seconds)</td></tr>
  </table>
  </dd>
</dl>
<p>Encode whatever this object is into to </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>the DER_Encoder that will be written to</td></tr>
  </table>
  </dd>
</dl>
<p>Decode whatever this object is from from </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the BER_Decoder that will be read from</td></tr>
  </table>
  </dd>
</dl>
<p>Return the encoding of this object. This is a convenience method when just one object needs to be serialized. Use DER_Encoder for complicated encodings.</p>
<p>Set up to BER decode the data in buf of length len</p>
<p>Set up to BER decode the data in vec</p>
<p>Set up to BER decode the data in vec</p>
<p>Set up to BER decode the data in src</p>
<p>Set up to BER decode the data in obj</p>
<p>Set up to BER decode the data in obj</p>
<p>Get the next object in the data stream. If EOF, returns an object with type NO_OBJECT.</p>
<p>Push an object back onto the stream. Throws if another object was previously pushed and has not been subsequently read out.</p>
<p>Push an object back onto the stream. Throws if another object was previously pushed and has not been subsequently read out.</p>
<p>Return true if there is at least one more item remaining</p>
<p>Verify the stream is concluded, throws otherwise. Returns (*this)</p>
<p>Verify the stream is concluded, throws otherwise. Returns (*this)</p>
<p>Discard any data that remains unread Returns (*this)</p>
<p>Start decoding a constructed data (sequence or set)</p>
<p>Finish decoding a constructed data, throws if any data remains. Returns the parent of *this (ie the object on which start_cons was called).</p>
<p>Get next object and copy value to POD type Asserts value length is equal to POD type sizeof. Asserts Type tag and optional Class tag according to parameters. Copy value to POD type (struct, union, C-style array, std::array, etc.). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>POD type reference where to copy object value </td></tr>
    <tr><td class="paramname">type_tag</td><td>ASN1_Tag enum to assert type on object read </td></tr>
    <tr><td class="paramname">class_tag</td><td>ASN1_Tag enum to assert class on object read (default: CONTEXT_SPECIFIC) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this reference <br />
<br />
<br />
</dd></dl>
<p>Decode a BER encoded BOOLEAN</p>
<p>Decode an integer value which is typed as an octet string</p>
<p>DER encode, writing to an internal buffer Use get_contents or get_contents_unlocked to read the results after all encoding is completed.</p>
<p>DER encode, writing to</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>If this constructor is used, get_contents* may not be called.</td></tr>
  </table>
  </dd>
</dl>
<p>DER encode, writing to</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>If this constructor is used, get_contents* may not be called.</td></tr>
  </table>
  </dd>
</dl>
<p>DER encode, calling append to write output If this constructor is used, get_contents* may not be called.</p>
<p>Insert raw bytes directly into the output stream</p>
<dl class="section return"><dt>Returns</dt><dd>length of the output of this function in bytes</dd></dl>
<p>Add new input to process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>of param in in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Add new input to process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a secure_vector</td></tr>
  </table>
  </dd>
</dl>
<p>Add new input to process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a std::vector</td></tr>
  </table>
  </dd>
</dl>
<p>Add an integer in big-endian order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the value</td></tr>
  </table>
  </dd>
</dl>
<p>Add new input to process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the input to process as a std::string. Will be interpreted as a byte array based on the strings encoding.</td></tr>
  </table>
  </dd>
</dl>
<p>Process a single byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the byte to process</td></tr>
  </table>
  </dd>
</dl>
<p>Complete the computation and retrieve the final result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The byte array to be filled with the result. Must be of length output_length()</td></tr>
  </table>
  </dd>
</dl>
<p>Complete the computation and retrieve the final result. </p><dl class="section return"><dt>Returns</dt><dd>secure_vector holding the result</dd></dl>
<p>Update and finalize computation. Does the same as calling update() and final() consecutively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the call to final()</dd></dl>
<p>Update and finalize computation. Does the same as calling update() and final() consecutively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the call to final()</dd></dl>
<p>Update and finalize computation. Does the same as calling update() and final() consecutively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the call to final()</dd></dl>
<p>Update and finalize computation. Does the same as calling update() and final() consecutively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input to process as a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the call to final()</dd></dl>
<p>Add more data to the computation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>is an input buffer </td></tr>
    <tr><td class="paramname">length</td><td>is the length of input in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Write the final output to out </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>is an output buffer of output_length()</td></tr>
  </table>
  </dd>
</dl>
<p>Constructor for fixed length keys </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keylen</td><td>the supported key length</td></tr>
  </table>
  </dd>
</dl>
<p>Constructor for variable length keys </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_k</td><td>the smallest supported key length </td></tr>
    <tr><td class="paramname">max_k</td><td>the largest supported key length </td></tr>
    <tr><td class="paramname">k_mod</td><td>the number of bytes the key must be a multiple of</td></tr>
    <tr><td class="paramname">length</td><td>is a key length in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff this length is a valid length for this algo</dd>
<dd>
minimum key length in bytes</dd>
<dd>
maximum key length in bytes</dd>
<dd>
key length multiple in bytes</dd></dl>
<p>Create a SCAN_Name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>A SCAN-format name</td></tr>
  </table>
  </dd>
</dl>
<p>Create a SCAN_Name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>A SCAN-format name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>original input string</dd>
<dd>
algorithm name</dd>
<dd>
number of arguments</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower</td><td>is the lower bound </td></tr>
    <tr><td class="paramname">upper</td><td>is the upper bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the number of arguments is between lower and upper</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>which argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ith argument</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>which argument </td></tr>
    <tr><td class="paramname">def_value</td><td>the default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ith argument or the default value</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>which argument </td></tr>
    <tr><td class="paramname">def_value</td><td>the default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ith argument as an integer, or the default value</dd>
<dd>
cipher mode (if any)</dd>
<dd>
cipher mode padding (if any)</dd></dl>
<p>Reset the state.</p>
<dl class="section return"><dt>Returns</dt><dd>object describing limits on key size</dd>
<dd>
minimum allowed key length</dd>
<dd>
maximum allowed key length</dd></dl>
<p>Check whether a given key length is valid for this algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the key length to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key length is valid.</dd></dl>
<p>Set the symmetric key of this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the SymmetricKey to be set.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the symmetric key of this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the to be set as a byte array. </td></tr>
    <tr><td class="paramname">length</td><td>in bytes of key param</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the algorithm name</dd></dl>
<p>Run the key schedule </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key </td></tr>
    <tr><td class="paramname">length</td><td>of key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of this octet string in bytes</dd>
<dd>
this object as a secure_vector&lt;uint8_t&gt;</dd>
<dd>
start of this string</dd>
<dd>
end of this string</dd>
<dd>
this encoded as hex</dd></dl>
<p>XOR the contents of another octet string into this one </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>octet string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this</dd></dl>
<p>Force to have odd parity</p>
<p>Create a new OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>is a hex encoded string</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new random OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>is a random number generator </td></tr>
    <tr><td class="paramname">len</td><td>is the desired length in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is an array </td></tr>
    <tr><td class="paramname">len</td><td>is the length of in in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a bytestring</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new OctetString </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a bytestring</td></tr>
    <tr><td class="paramname">row</td><td>the row </td></tr>
    <tr><td class="paramname">col</td><td>the column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sbox entry at this row/column</dd>
<dd>
name of this parameter set</dd></dl>
<p>Return a representation used for building larger tables For internal use</p>
<p>Default GOST parameters are the ones given in GOST R 34.11 for testing purposes; these sboxes are also used by Crypto++, and, at least according to Wikipedia, the Central Bank of Russian Federation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>of the parameter set</td></tr>
  </table>
  </dd>
</dl>
<p>Create an instance based on a name, or return null if the algo combination cannot be found.</p>
<p>Create an instance based on a name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name Throws Lookup_Error if not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Begin compressing. Most compression algorithms offer a tunable time/compression tradeoff parameter generally represented by an integer in the range of 1 to 9.</p>
<p>If 0 or a value out of range is provided, a compression algorithm specific default is used.</p>
<p>Process some data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out parameter which will possibly be resized or swapped </td></tr>
    <tr><td class="paramname">offset</td><td>an offset into blocks to begin processing </td></tr>
    <tr><td class="paramname">flush</td><td>if true the compressor will be told to flush state</td></tr>
  </table>
  </dd>
</dl>
<p>Finish compressing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_block</td><td>in/out parameter </td></tr>
    <tr><td class="paramname">offset</td><td>an offset into final_block to begin processing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the compression algorithm</dd></dl>
<p>Reset the state and abort the current message; start can be called again to process a new message.</p>
<p>Create an instance based on a name, or return null if the algo combination cannot be found.</p>
<p>Create an instance based on a name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name Throws Lookup_Error if not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Begin decompressing. Decompression does not support levels, as compression does.</p>
<p>Process some data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out parameter which will possibly be resized or swapped </td></tr>
    <tr><td class="paramname">offset</td><td>an offset into blocks to begin processing</td></tr>
  </table>
  </dd>
</dl>
<p>Finish decompressing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_block</td><td>in/out parameter </td></tr>
    <tr><td class="paramname">offset</td><td>an offset into final_block to begin processing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the decompression algorithm</dd></dl>
<p>Reset the state and abort the current message; start can be called again to process a new message.</p>
<p>Return a new entropy source of a particular type, or null Each entropy source may require substantial resources (eg, a file handle or socket instance), so try to share them among multiple RNGs, or just use the preconfigured global list accessed by Entropy_Sources::global_sources()</p>
<dl class="section return"><dt>Returns</dt><dd>name identifying this entropy source</dd></dl>
<p>Perform an entropy gathering poll </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>will be provided with entropy via calls to add_entropy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>conservative estimate of actual entropy added to rng during poll</dd></dl>
<p>Poll just a single named source. Ordinally only used for testing</p>
<p>Write bytes into the buffered filter, which will them emit them in calls to buffered_block in the subclass </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input bytes </td></tr>
    <tr><td class="paramname">length</td><td>of in in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Finish a message, emitting to buffered_block and buffered_final Will throw an exception if less than final_minimum bytes were written into the filter.</p>
<p>Initialize a Buffered_Filter </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>the function buffered_block will be called with inputs which are a multiple of this size </td></tr>
    <tr><td class="paramname">final_minimum</td><td>the function buffered_final will be called with at least this many bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>The block processor, implemented by subclasses </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input bytes </td></tr>
    <tr><td class="paramname">length</td><td>the size of input, guaranteed to be a multiple of block_size</td></tr>
  </table>
  </dd>
</dl>
<p>The final block, implemented by subclasses </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input bytes </td></tr>
    <tr><td class="paramname">length</td><td>the size of input, guaranteed to be at least final_minimum bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>block size of inputs</dd>
<dd>
current position in the buffer</dd></dl>
<p>Reset the buffer position</p>
<dl class="section return"><dt>Returns</dt><dd>descriptive name for this filter</dd></dl>
<p>Write a portion of a message to this filter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array input</td></tr>
  </table>
  </dd>
</dl>
<p>Start a new message. Must be closed by end_msg() before another message can be started.</p>
<p>Notify that the current message is finished; flush buffers and do end-of-message processing (if any).</p>
<p>Check whether this filter is an attachable filter. </p><dl class="section return"><dt>Returns</dt><dd>true if this filter is attachable, false otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>some input for the filter </td></tr>
    <tr><td class="paramname">length</td><td>the length of in</td></tr>
    <tr><td class="paramname">in</td><td>some input for the filter</td></tr>
    <tr><td class="paramname">in</td><td>some input for the filter</td></tr>
    <tr><td class="paramname">in</td><td>some input for the filter </td></tr>
    <tr><td class="paramname">length</td><td>the number of bytes of in to send</td></tr>
  </table>
  </dd>
</dl>
<p>Start a new message in *this and all following filters. Only for internal use, not intended for use in client applications.</p>
<p>End a new message in *this and all following filters. Only for internal use, not intended for use in client applications.</p>
<p>Set the active port </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_port</td><td>the new value</td></tr>
  </table>
  </dd>
</dl>
<p>Attach another filter to this one </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>filter to attach</td></tr>
    <tr><td class="paramname">filters</td><td>the filters to set </td></tr>
    <tr><td class="paramname">count</td><td>number of items in filters</td></tr>
  </table>
  </dd>
</dl>
<p>Create an instance based on a name If provider is empty then best available is chosen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name </td></tr>
    <tr><td class="paramname">provider</td><td>provider implementation to choose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a null pointer if the algo/provider combination cannot be found</dd></dl>
<p>Create an instance based on a name, or throw if the algo/provider combination cannot be found. If provider is empty then best available is chosen.</p>
<dl class="section return"><dt>Returns</dt><dd>list of available providers for this algorithm, empty if not available</dd>
<dd>
KDF name</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>buffer holding the derived key, must be of length key_len </td></tr>
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">secret_len</td><td>size of secret in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of salt in bytes </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
    <tr><td class="paramname">label_len</td><td>size of label in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">secret_len</td><td>size of secret in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of salt in bytes </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
    <tr><td class="paramname">label_len</td><td>size of label in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of salt in bytes </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired output length in bytes </td></tr>
    <tr><td class="paramname">secret</td><td>the secret input </td></tr>
    <tr><td class="paramname">secret_len</td><td>size of secret in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a diversifier </td></tr>
    <tr><td class="paramname">label</td><td>purpose for the derived keying material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd>
<dd>
new object representing the same algorithm as *this</dd></dl>
<p>Base enumerator for encoding and decoding</p>
<p>Sign symbol definitions for positive and negative numbers</p>
<p>DivideByZero Exception</p>
<p>Create empty BigInt</p>
<p>Create BigInt from 64 bit integer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>initial value of this BigInt</td></tr>
  </table>
  </dd>
</dl>
<p>Copy Constructor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the BigInt to copy</td></tr>
  </table>
  </dd>
</dl>
<p>Create BigInt from a string. If the string starts with 0x the rest of the string will be interpreted as hexadecimal digits. Otherwise, it will be interpreted as a decimal number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to parse for an integer value</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the byte array holding the value </td></tr>
    <tr><td class="paramname">length</td><td>size of buf</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the byte vector holding the value</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the byte array holding the value </td></tr>
    <tr><td class="paramname">length</td><td>size of buf </td></tr>
    <tr><td class="paramname">base</td><td>is the number base of the integer in buf</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the byte array holding the value </td></tr>
    <tr><td class="paramname">length</td><td>size of buf </td></tr>
    <tr><td class="paramname">max_bits</td><td>if the resulting integer is more than max_bits, it will be shifted so it is at most max_bits in length.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an array of words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>the words </td></tr>
    <tr><td class="paramname">length</td><td>number of words</td></tr>
  </table>
  </dd>
</dl>
<p>Create a random BigInt of the specified size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>random number generator </td></tr>
    <tr><td class="paramname">bits</td><td>size in bits </td></tr>
    <tr><td class="paramname">set_high_bit</td><td>if true, the highest bit is always set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>randomize</dd></dl>
<p>Create BigInt of specified size, all zeros </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sign</td><td>the sign </td></tr>
    <tr><td class="paramname">n</td><td>size of the internal register in words</td></tr>
  </table>
  </dd>
</dl>
<p>Move constructor</p>
<p>Move assignment</p>
<p>Copy assignment</p>
<p>Swap this value with another </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>BigInt to swap values with</td></tr>
  </table>
  </dd>
</dl>
<p>+= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to add to this</td></tr>
  </table>
  </dd>
</dl>
<p>+= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the word to add to this</td></tr>
  </table>
  </dd>
</dl>
<p>-= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to subtract from this</td></tr>
  </table>
  </dd>
</dl>
<p>-= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the word to subtract from this</td></tr>
  </table>
  </dd>
</dl>
<p>*= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to multiply with this</td></tr>
  </table>
  </dd>
</dl>
<p>*= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the word to multiply with this</td></tr>
  </table>
  </dd>
</dl>
<p>/= operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to divide this by</td></tr>
  </table>
  </dd>
</dl>
<p>Modulo operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the modulus to reduce this by</td></tr>
  </table>
  </dd>
</dl>
<p>Modulo operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the modulus (word) to reduce this by</td></tr>
  </table>
  </dd>
</dl>
<p>Left shift operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>the number of bits to shift this left by</td></tr>
  </table>
  </dd>
</dl>
<p>Right shift operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>the number of bits to shift this right by</td></tr>
  </table>
  </dd>
</dl>
<p>Increment operator</p>
<p>Decrement operator</p>
<p>Postfix increment operator</p>
<p>Postfix decrement operator</p>
<p>Unary negation operator </p><dl class="section return"><dt>Returns</dt><dd>negative this</dd></dl>
<p>! operator </p><dl class="section return"><dt>Returns</dt><dd>true iff this is zero, otherwise false</dd></dl>
<p>Multiply this with y </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to multiply with this </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Square value of *this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Set *this to y - *this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to subtract from as a sequence of words </td></tr>
    <tr><td class="paramname">y_size</td><td>length of y in words </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Set *this to (*this + y) % mod This function assumes *this is &gt;= 0 &amp;&amp; &lt; mod </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to add - assumed y &gt;= 0 and y &lt; mod </td></tr>
    <tr><td class="paramname">mod</td><td>the positive modulus </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Set *this to (*this - y) % mod This function assumes *this is &gt;= 0 &amp;&amp; &lt; mod </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the BigInt to subtract - assumed y &gt;= 0 and y &lt; mod </td></tr>
    <tr><td class="paramname">mod</td><td>the positive modulus </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace</td></tr>
  </table>
  </dd>
</dl>
<p>Return *this below mod</p>
<p>Assumes that *this is (if anything) only slightly larger than mod and performs repeated subtractions. It should not be used if *this is much larger than mod, instead of modulo operator.</p>
<p>Zeroize the BigInt. The size of the underlying register is not modified.</p>
<p>Compare this to another BigInt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt value to compare with </td></tr>
    <tr><td class="paramname">check_signs</td><td>include sign in comparison? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if (this&lt;n) return -1, if (this&gt;n) return 1, if both values are identical return 0 [like Perl's &lt;=&gt; operator]</dd></dl>
<p>Compare this to an integer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if (this&lt;n) return -1, if (this&gt;n) return 1, if both values are identical return 0 [like Perl's &lt;=&gt; operator]</dd></dl>
<p><a class="el" href="class_test.html">Test</a> if the integer has an even value </p><dl class="section return"><dt>Returns</dt><dd>true if the integer is even, false otherwise</dd></dl>
<p><a class="el" href="class_test.html">Test</a> if the integer has an odd value </p><dl class="section return"><dt>Returns</dt><dd>true if the integer is odd, false otherwise</dd></dl>
<p><a class="el" href="class_test.html">Test</a> if the integer is not zero </p><dl class="section return"><dt>Returns</dt><dd>true if the integer is non-zero, false otherwise</dd></dl>
<p><a class="el" href="class_test.html">Test</a> if the integer is zero </p><dl class="section return"><dt>Returns</dt><dd>true if the integer is zero, false otherwise</dd></dl>
<p>Set bit at specified position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>bit position to set</td></tr>
  </table>
  </dd>
</dl>
<p>Clear bit at specified position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>bit position to clear</td></tr>
  </table>
  </dd>
</dl>
<p>Clear all but the lowest n bits </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>amount of bits to keep</td></tr>
  </table>
  </dd>
</dl>
<p>Return bit value at specified position </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the bit offset to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the bit at position n is set, false otherwise</dd></dl>
<p>Return (a maximum of) 32 bits of the complete value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset to start extracting </td></tr>
    <tr><td class="paramname">length</td><td>amount of bits to extract (starting at offset) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer extracted from the register starting at offset with specified length</dd></dl>
<p>Convert this value into a uint32_t, if it is in the range [0 ... 2**32-1], or otherwise throw an exception. </p><dl class="section return"><dt>Returns</dt><dd>the value as a uint32_t if conversion is possible</dd></dl>
<p>Convert this value to a decimal string. Warning: decimal conversions are relatively slow</p>
<p>Convert this value to a hexadecimal string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the offset to get a byte from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte at offset n</dd></dl>
<p>Return the word at a specified position of the internal register </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>position in the register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value at position n</dd></dl>
<p>Tests if the sign of the integer is negative </p><dl class="section return"><dt>Returns</dt><dd>true, iff the integer has a negative sign</dd></dl>
<p>Tests if the sign of the integer is positive </p><dl class="section return"><dt>Returns</dt><dd>true, iff the integer has a positive sign</dd></dl>
<p>Return the sign of the integer </p><dl class="section return"><dt>Returns</dt><dd>the sign of the integer</dd>
<dd>
the opposite sign of the represented integer value</dd></dl>
<p>Flip the sign of this BigInt</p>
<p>Set sign of the integer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sign</td><td>new Sign to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absolute (positive) value of this</dd></dl>
<p>Give size of internal register </p><dl class="section return"><dt>Returns</dt><dd>size of internal register in words</dd></dl>
<p>Return how many words we need to hold this value </p><dl class="section return"><dt>Returns</dt><dd>significant words of the represented integer value</dd></dl>
<p>Give byte length of the integer </p><dl class="section return"><dt>Returns</dt><dd>byte length of the represented integer value</dd></dl>
<p>Get the bit length of the integer </p><dl class="section return"><dt>Returns</dt><dd>bit length of the represented integer value</dd></dl>
<p>Return a mutable pointer to the register </p><dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the internal register</dd></dl>
<p>Return a const pointer to the register </p><dl class="section return"><dt>Returns</dt><dd>a pointer to the start of the internal register</dd></dl>
<p>Increase internal register buffer to at least n words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>new size of register</td></tr>
  </table>
  </dd>
</dl>
<p>Resize the vector to the minimum word size to hold the integer, or min_size words, whichever is larger</p>
<p>Fill BigInt with a random number with size of bitsize</p>
<p>If <code>set_high_bit</code> is true, the highest bit will be set, which causes the entropy to be <em>bits-1</em>. Otherwise the highest bit is randomly chosen by the rng, causing the entropy to be <em>bits</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">bitsize</td><td>number of bits the created random value should have </td></tr>
    <tr><td class="paramname">set_high_bit</td><td>if true, the highest bit is always set</td></tr>
  </table>
  </dd>
</dl>
<p>Store BigInt-value in a given byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>destination byte array for the integer value</td></tr>
  </table>
  </dd>
</dl>
<p>Read integer value from a byte array with given size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>byte array buffer containing the integer </td></tr>
    <tr><td class="paramname">length</td><td>size of buf</td></tr>
  </table>
  </dd>
</dl>
<p>Read integer value from a byte array (secure_vector&lt;uint8_t&gt;) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the array to load from</td></tr>
    <tr><td class="paramname">base</td><td>the base to measure the size for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of this integer in base base</dd></dl>
<p>Place the value into out, zero-padding up to size words Throw if *this cannot be represented in size words</p>
<p>If predicate is true assign other to *this Uses a masked operation to avoid side channels</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">min</td><td>the minimum value (must be non-negative) </td></tr>
    <tr><td class="paramname">max</td><td>the maximum value (must be non-negative and &gt; min) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random integer in [min,max)</dd></dl>
<p>Create a power of two </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the power of two to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bigint representing 2^n</dd></dl>
<p>Encode the integer value from a BigInt to a std::vector of bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>secure_vector of bytes containing the bytes of the integer</dd></dl>
<p>Encode the integer value from a BigInt to a secure_vector of bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>secure_vector of bytes containing the bytes of the integer</dd></dl>
<p>Encode the integer value from a BigInt to a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>destination byte array for the encoded integer </td></tr>
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
    <tr><td class="paramname">length</td><td>size of buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Encode the integer value from a BigInt to a std::vector of bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
    <tr><td class="paramname">base</td><td>number-base of resulting byte array representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>secure_vector of bytes containing the integer with given base</dd></dl>
<p>Encode the integer value from a BigInt to a secure_vector of bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
    <tr><td class="paramname">base</td><td>number-base of resulting byte array representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>secure_vector of bytes containing the integer with given base</dd></dl>
<p>Encode the integer value from a BigInt to a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>destination byte array for the encoded integer value with given base </td></tr>
    <tr><td class="paramname">n</td><td>the BigInt to use as integer source </td></tr>
    <tr><td class="paramname">base</td><td>number-base of resulting byte array representation</td></tr>
  </table>
  </dd>
</dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
    <tr><td class="paramname">length</td><td>size of buf </td></tr>
    <tr><td class="paramname">base</td><td>number-base of the integer in buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
    <tr><td class="paramname">base</td><td>number-base of the integer in buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Create a BigInt from an integer in a byte array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the binary value to load </td></tr>
    <tr><td class="paramname">base</td><td>number-base of the integer in buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BigInt representing the integer in the byte array</dd></dl>
<p>Encode a BigInt to a byte array according to IEEE 1363 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the BigInt to encode </td></tr>
    <tr><td class="paramname">bytes</td><td>the length of the resulting secure_vector&lt;uint8_t&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a secure_vector&lt;uint8_t&gt; containing the encoded BigInt</dd></dl>
<p>Encode two BigInt to a byte array according to IEEE 1363 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>the first BigInt to encode </td></tr>
    <tr><td class="paramname">n2</td><td>the second BigInt to encode </td></tr>
    <tr><td class="paramname">bytes</td><td>the length of the encoding of each single BigInt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a secure_vector&lt;uint8_t&gt; containing the concatenation of the two encoded BigInt</dd></dl>
<p>Set output = vec[idx].m_reg in constant time All words of vec must have the same size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modulus</td><td>the modulus </td></tr>
    <tr><td class="paramname">hints</td><td>Passed to set_modulus if modulus &gt; 0 </td></tr>
    <tr><td class="paramname">disable_montgomery_arith</td><td>Disables use of Montgomery representation. Likely only useful for testing.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the base</p>
<p>Set the exponent</p>
<p>All three of the above functions must have already been called. </p><dl class="section return"><dt>Returns</dt><dd>result of g^xp</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modulus</td><td>Optionally call set_modulus </td></tr>
    <tr><td class="paramname">hints</td><td>Passed to set_modulus if modulus &gt; 0 </td></tr>
    <tr><td class="paramname">disable_montgomery_arith</td><td>Disables use of Montgomery representation. Likely only useful for testing.</td></tr>
  </table>
  </dd>
</dl>
<p>Multiply mod p </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first operand </td></tr>
    <tr><td class="paramname">y</td><td>the second operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x * y) % p</dd></dl>
<p>Square mod p </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to square </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x * x) % p</dd></dl>
<p>Cube mod p </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to cube </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x * x * x) % p</dd></dl>
<p>Server side step 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the verification value saved from client registration </td></tr>
    <tr><td class="paramname">group_id</td><td>the SRP group id </td></tr>
    <tr><td class="paramname">hash_id</td><td>the SRP hash in use </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SRP-6 B value</dd></dl>
<p>Server side step 2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the client's value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared symmetric key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the number of shares needed to reconstruct </td></tr>
    <tr><td class="paramname">N</td><td>the number of shares generated </td></tr>
    <tr><td class="paramname">secret</td><td>the secret to split </td></tr>
    <tr><td class="paramname">secret_len</td><td>the length of the secret </td></tr>
    <tr><td class="paramname">identifier</td><td>the 16 byte share identifier </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator to use</td></tr>
    <tr><td class="paramname">shares</td><td>the list of shares</td></tr>
    <tr><td class="paramname">hex_input</td><td>the share encoded in hexadecimal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hex representation</dd>
<dd>
share identifier</dd>
<dd>
size of this share in bytes</dd>
<dd>
if this TSS share was initialized or not</dd></dl>
<p>Add padding bytes to buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>data to pad </td></tr>
    <tr><td class="paramname">final_block_bytes</td><td>size of the final block in bytes </td></tr>
    <tr><td class="paramname">block_size</td><td>size of each block in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Remove padding bytes from block </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>the last block </td></tr>
    <tr><td class="paramname">len</td><td>the size of the block in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of data bytes, or if the padding is invalid returns len</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_size</td><td>of the cipher </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>valid block size for this padding mode</dd>
<dd>
name of the mode</dd></dl>
<p>virtual destructor</p>
<p>Create an instance based on a name If provider is empty then best available is chosen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>algorithm name </td></tr>
    <tr><td class="paramname">provider</td><td>provider implementation to choose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a null pointer if the algo/provider combination cannot be found</dd></dl>
<p>Create an instance based on a name, or throw if the algo/provider combination cannot be found. If provider is empty then best available is chosen.</p>
<dl class="section return"><dt>Returns</dt><dd>list of available providers for this algorithm, empty if not available</dd>
<dd>
new instance of this same algorithm</dd>
<dd>
name of this PBKDF</dd></dl>
<p>Derive a key from a passphrase for a number of iterations specified by either iterations or if iterations == 0 then running until msec time has elapsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer to store the derived key, must be of out_len bytes </td></tr>
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more) </td></tr>
    <tr><td class="paramname">msec</td><td>if iterations is zero, then instead the PBKDF is run until msec milliseconds has passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations performed</dd></dl>
<p>Derive a key from a passphrase for a number of iterations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer to store the derived key, must be of out_len bytes </td></tr>
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more)</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase, running until msec time has elapsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer to store the derived key, must be of out_len bytes </td></tr>
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">msec</td><td>if iterations is zero, then instead the PBKDF is run until msec milliseconds has passed. </td></tr>
    <tr><td class="paramname">iterations</td><td>set to the number iterations executed</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase for a number of iterations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key from a passphrase, running until msec time has elapsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">msec</td><td>if iterations is zero, then instead the PBKDF is run until msec milliseconds has passed. </td></tr>
    <tr><td class="paramname">iterations</td><td>set to the number iterations executed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derived key</dd></dl>
<p>Derive a key from a passphrase </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more)</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">iterations</td><td>the number of iterations to use (use 10K or more)</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt in bytes </td></tr>
    <tr><td class="paramname">msec</td><td>is how long to run the PBKDF </td></tr>
    <tr><td class="paramname">iterations</td><td>is set to the number of iterations used</td></tr>
  </table>
  </dd>
</dl>
<p>Derive a key from a passphrase using a certain amount of time </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_len</td><td>the desired length of the key to produce </td></tr>
    <tr><td class="paramname">passphrase</td><td>the password to derive the key from </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen salt </td></tr>
    <tr><td class="paramname">msec</td><td>is how long to run the PBKDF </td></tr>
    <tr><td class="paramname">iterations</td><td>is set to the number of iterations used</td></tr>
  </table>
  </dd>
</dl>
<p>Return the maximum input size in bytes we can support </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keybits</td><td>the size of the key in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>upper bound of input in bytes</dd></dl>
<p>Encode an input </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the plaintext </td></tr>
    <tr><td class="paramname">in_length</td><td>length of plaintext in bytes </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bits </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded plaintext</dd></dl>
<p>Encode an input </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the plaintext </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bits </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded plaintext</dd></dl>
<p>Decode an input </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valid_mask</td><td>written to specifies if output is valid </td></tr>
    <tr><td class="paramname">in</td><td>the encoded plaintext </td></tr>
    <tr><td class="paramname">in_len</td><td>length of encoded plaintext in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bytes of out[] written to along with validity mask (0xFF if valid, else 0x00)</dd></dl>
<p>Encode an input </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the plaintext </td></tr>
    <tr><td class="paramname">in_length</td><td>length of plaintext in bytes </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bits </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded plaintext</dd></dl>
<p>Add more data to the signature computation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some data </td></tr>
    <tr><td class="paramname">length</td><td>length of input in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>raw hash</dd></dl>
<p>Return the encoding of a message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the result of raw_data() </td></tr>
    <tr><td class="paramname">output_bits</td><td>the desired output bit size </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded signature</dd></dl>
<p>Verify the encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coded</td><td>the received (coded) message representative </td></tr>
    <tr><td class="paramname">raw</td><td>the computed (local, uncoded) message representative </td></tr>
    <tr><td class="paramname">key_bits</td><td>the size of the key in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if coded is a valid encoding of raw, otherwise false</dd></dl>
<p>Prepare sig_algo for use in choose_sig_format for x509 certs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>used for checking compatibility with the encoding scheme </td></tr>
    <tr><td class="paramname">cert_hash_name</td><td>is checked to equal the hash for the encoding </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>algorithm identifier to signatures created using this key, padding method and hash.</dd>
<dd>
a new object representing the same encoding method as *this</dd>
<dd>
the SCAN name of the encoding/padding scheme</dd></dl>
<p>User callback for getting the PIN. Will be passed the best available description of what we are attempting to load.</p>
<p>Blind a value. The blinding nonce k is freshly generated after BOTAN_BLINDING_REINIT_INTERVAL calls to blind(). BOTAN_BLINDING_REINIT_INTERVAL = 0 means a fresh nonce is only generated once. On every other call, an updated nonce is used for blinding: k' = k*k mod n. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to blind </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>blinded value</dd></dl>
<p>Unblind a value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to unblind </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unblinded value</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modulus</td><td>the modulus </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use for generating the nonce </td></tr>
    <tr><td class="paramname">fwd_func</td><td>a function that calculates the modular exponentiation of the public exponent and the given value (the nonce) </td></tr>
    <tr><td class="paramname">inv_func</td><td>a function that calculates the modular inverse of the given value (the nonce)</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the prime creation for DL groups.</p>
<p>The DL group encoding format variants.</p>
<p>Construct a DL group with uninitialized internal value. Use this constructor is you wish to set the groups values from a DER or PEM encoded group.</p>
<p>Construct a DL group that is registered in the configuration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name that is configured in the global configuration for the desired group. If no configuration file is specified, the default values from the file policy.cpp will be used. For instance, use "modp/ietf/3072".</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new group randomly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">type</td><td>specifies how the creation of primes p and q shall be performed. If type=Strong, then p will be determined as a safe prime, and q will be chosen as (p-1)/2. If type=Prime_Subgroup and qbits = 0, then the size of q will be determined according to the estimated difficulty of the DL problem. If type=DSA_Kosherizer, DSA primes will be created. </td></tr>
    <tr><td class="paramname">pbits</td><td>the number of bits of p </td></tr>
    <tr><td class="paramname">qbits</td><td>the number of bits of q. Leave it as 0 to have the value determined according to pbits.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a DSA group with a given seed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">seed</td><td>the seed to use to create the random primes </td></tr>
    <tr><td class="paramname">pbits</td><td>the desired bit size of the prime p </td></tr>
    <tr><td class="paramname">qbits</td><td>the desired bit size of the prime q.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a DL group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the prime p </td></tr>
    <tr><td class="paramname">g</td><td>the base g</td></tr>
  </table>
  </dd>
</dl>
<p>Create a DL group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the prime p </td></tr>
    <tr><td class="paramname">q</td><td>the prime q </td></tr>
    <tr><td class="paramname">g</td><td>the base g</td></tr>
  </table>
  </dd>
</dl>
<p>Decode a BER-encoded DL group param</p>
<p>Decode a BER-encoded DL group param</p>
<p>Get the prime p. </p><dl class="section return"><dt>Returns</dt><dd>prime p</dd></dl>
<p>Get the prime q, returns zero if q is not used </p><dl class="section return"><dt>Returns</dt><dd>prime q</dd></dl>
<p>Get the base g. </p><dl class="section return"><dt>Returns</dt><dd>base g</dd></dl>
<p>Perform validity checks on the group. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
    <tr><td class="paramname">strong</td><td>whether to perform stronger by lengthier tests </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object is consistent, false otherwise</dd></dl>
<p>Verify a public element, ie check if y = g^x for some x.</p>
<p>This is not a perfect test. It verifies that 1 &lt; y &lt; p and (if q is set) that y is in the subgroup of size q.</p>
<p>Verify a pair of elements y = g^x</p>
<p>This verifies that 1 &lt; x,y &lt; p and that y=g^x mod p</p>
<p>Encode this group into a string using PEM encoding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the encoding format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string holding the PEM encoded group</dd></dl>
<p>Encode this group into a string using DER encoding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the encoding format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string holding the DER encoded group</dd></dl>
<p>Reduce an integer modulo p </p><dl class="section return"><dt>Returns</dt><dd>x % p</dd></dl>
<p>Multiply and reduce an integer modulo p </p><dl class="section return"><dt>Returns</dt><dd>(x*y) % p</dd></dl>
<p>Return the inverse of x mod p</p>
<p>Reduce an integer modulo q Throws if q is unset on this DL_Group </p><dl class="section return"><dt>Returns</dt><dd>x % q</dd></dl>
<p>Multiply and reduce an integer modulo q Throws if q is unset on this DL_Group </p><dl class="section return"><dt>Returns</dt><dd>(x*y) % q</dd></dl>
<p>Multiply and reduce an integer modulo q Throws if q is unset on this DL_Group </p><dl class="section return"><dt>Returns</dt><dd>(x*y*z) % q</dd></dl>
<p>Square and reduce an integer modulo q Throws if q is unset on this DL_Group </p><dl class="section return"><dt>Returns</dt><dd>(x*x) % q</dd></dl>
<p>Return the inverse of x mod q Throws if q is unset on this DL_Group</p>
<p>Modular exponentiation</p>
<dl class="section warning"><dt>Warning</dt><dd>this function leaks the size of x via the number of loop iterations. Use the version taking the maximum size to avoid this.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>(g^x) % p</dd></dl>
<p>Modular exponentiation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the exponent </td></tr>
    <tr><td class="paramname">max_x_bits</td><td>x is assumed to be at most this many bits long.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(g^x) % p</dd></dl>
<p>Multi-exponentiate Return (g^x * y^z) % p</p>
<p>Return parameters for Montgomery reduction/exponentiation mod p</p>
<p>Return the size of p in bits Same as get_p().bits()</p>
<p>Return the size of p in bytes Same as get_p().bytes()</p>
<p>Return the size of q in bits Same as get_q().bits() Throws if q is unset</p>
<p>Return the size of q in bytes Same as get_q().bytes() Throws if q is unset</p>
<p>Return size in bits of a secret exponent</p>
<p>This attempts to balance between the attack costs of NFS (which depends on the size of the modulus) and Pollard's rho (which depends on the size of the exponent).</p>
<p>It may vary over time for a particular group, if the attack costs change.</p>
<p>Return an estimate of the strength of this group against discrete logarithm attacks (eg NFS). Warning: since this only takes into account known attacks it is by necessity an overestimate of the actual strength.</p>
<p>Decode a DER/BER encoded group into this instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ber</td><td>a vector containing the DER/BER encoded group </td></tr>
    <tr><td class="paramname">format</td><td>the format of the encoded group</td></tr>
  </table>
  </dd>
</dl>
<p>Decode a PEM encoded group into this instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pem</td><td>the PEM encoding of the group</td></tr>
  </table>
  </dd>
</dl>
<p>Return PEM representation of named DL group</p>
<p>Construct Domain paramers from specified parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>elliptic curve </td></tr>
    <tr><td class="paramname">base_point</td><td>a base point </td></tr>
    <tr><td class="paramname">order</td><td>the order of the base point </td></tr>
    <tr><td class="paramname">cofactor</td><td>the cofactor</td></tr>
  </table>
  </dd>
</dl>
<p>Construct Domain paramers from specified parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the elliptic curve p </td></tr>
    <tr><td class="paramname">a</td><td>the elliptic curve a param </td></tr>
    <tr><td class="paramname">b</td><td>the elliptic curve b param </td></tr>
    <tr><td class="paramname">base_x</td><td>the x coordinate of the base point </td></tr>
    <tr><td class="paramname">base_y</td><td>the y coordinate of the base point </td></tr>
    <tr><td class="paramname">order</td><td>the order of the base point </td></tr>
    <tr><td class="paramname">cofactor</td><td>the cofactor </td></tr>
    <tr><td class="paramname">oid</td><td>an optional OID used to identify this curve</td></tr>
  </table>
  </dd>
</dl>
<p>Decode a BER encoded ECC domain parameter set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ber_encoding</td><td>the bytes of the BER encoding</td></tr>
  </table>
  </dd>
</dl>
<p>Create an EC domain by OID (or throw if unknown) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>the OID of the EC domain to create</td></tr>
  </table>
  </dd>
</dl>
<p>Create an EC domain from PEM encoding (as from PEM_encode), or from an OID name (eg "secp256r1", or "1.2.840.10045.3.1.7") </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pem_or_oid</td><td>PEM-encoded data, or an OID</td></tr>
  </table>
  </dd>
</dl>
<p>Create an uninitialized EC_Group</p>
<p>Create the DER encoding of this domain </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">form</td><td>of encoding to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bytes encododed as DER</dd></dl>
<p>Return the PEM encoding (always in explicit form) </p><dl class="section return"><dt>Returns</dt><dd>string containing PEM data</dd></dl>
<p>Return domain parameter curve </p><dl class="section return"><dt>Returns</dt><dd>domain parameter curve</dd></dl>
<p>Return if a == -3 mod p</p>
<p>Return if a == 0 mod p</p>
<p>Return the size of p in bits (same as get_p().bits())</p>
<p>Return the size of p in bits (same as get_p().bytes())</p>
<p>Return the size of group order in bits (same as get_order().bits())</p>
<p>Return the size of p in bytes (same as get_order().bytes())</p>
<p>Return the prime modulus of the field</p>
<p>Return the a parameter of the elliptic curve equation</p>
<p>Return the b parameter of the elliptic curve equation</p>
<p>Return group base point </p><dl class="section return"><dt>Returns</dt><dd>base point</dd></dl>
<p>Return the x coordinate of the base point</p>
<p>Return the y coordinate of the base point</p>
<p>Return the order of the base point </p><dl class="section return"><dt>Returns</dt><dd>order of the base point</dd></dl>
<p>Return the cofactor </p><dl class="section return"><dt>Returns</dt><dd>the cofactor</dd></dl>
<p>Check if y is a plausible point on the curve</p>
<p>In particular, checks that it is a point on the curve, not infinity, and that it has order matching the group.</p>
<p>Return the OID of these domain parameters </p><dl class="section return"><dt>Returns</dt><dd>the OID as a string</dd></dl>
<p>Return the OID of these domain parameters </p><dl class="section return"><dt>Returns</dt><dd>the OID</dd></dl>
<p>Return a point on this curve with the affine values x, y</p>
<p>Multi exponentiate. Not constant time. </p><dl class="section return"><dt>Returns</dt><dd>base_point*x + pt*y</dd></dl>
<p>Blinded point multiplication, attempts resistance to side channels </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the scalar </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base_point*k</dd></dl>
<p>Blinded point multiplication, attempts resistance to side channels Returns just the x coordinate of the point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the scalar </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x coordinate of base_point*k</dd></dl>
<p>Blinded point multiplication, attempts resistance to side channels </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>input point </td></tr>
    <tr><td class="paramname">k</td><td>the scalar </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">ws</td><td>a temp workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>point*k</dd></dl>
<p>Return a random scalar ie an integer in [1,order)</p>
<p>Return the zero (or infinite) point on this curve</p>
<p>Verify EC_Group domain </p><dl class="section return"><dt>Returns</dt><dd>true if group is valid. false otherwise</dd></dl>
<p>Return PEM representation of named EC group Deprecated: Use EC_Group(name).PEM_encode() if this is needed</p>
<p>Return a set of known named EC groups</p>
<p>Construct an uninitialized PointGFp</p>
<p>Construct the zero point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>The base curve</td></tr>
  </table>
  </dd>
</dl>
<p>Copy constructor</p>
<p>Move Constructor</p>
<p>Standard Assignment</p>
<p>Move Assignment</p>
<p>Construct a point from its affine coordinates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>the base curve </td></tr>
    <tr><td class="paramname">x</td><td>affine x coordinate </td></tr>
    <tr><td class="paramname">y</td><td>affine y coordinate</td></tr>
  </table>
  </dd>
</dl>
<p>EC2OSP - elliptic curve to octet string primitive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>which format to encode using</td></tr>
  </table>
  </dd>
</dl>
<p>+= Operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the PointGFp to add to the local value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting PointGFp</dd></dl>
<p>-= Operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the PointGFp to subtract from the local value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting PointGFp</dd></dl>
<p>*= Operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the PointGFp to multiply with *this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting PointGFp</dd></dl>
<p>Negate this point </p><dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>get affine x coordinate </p><dl class="section return"><dt>Returns</dt><dd>affine x coordinate</dd></dl>
<p>get affine y coordinate </p><dl class="section return"><dt>Returns</dt><dd>affine y coordinate</dd></dl>
<p>Force this point to affine coordinates</p>
<p>Force all points on the list to affine coordinates</p>
<p>Is this the point at infinity? </p><dl class="section return"><dt>Returns</dt><dd>true, if this point is at infinity, false otherwise.</dd></dl>
<p>Checks whether the point is to be found on the underlying curve; used to prevent fault attacks. </p><dl class="section return"><dt>Returns</dt><dd>if the point is on the curve</dd></dl>
<p>swaps the states of *this and other, does not throw! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to swap values with</td></tr>
  </table>
  </dd>
</dl>
<p>Randomize the point representation The actual value (get_affine_x, get_affine_y) does not change</p>
<p>Randomize the point representation The actual value (get_affine_x, get_affine_y) does not change</p>
<p>Equality operator</p>
<p>Point addition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the point to add to *this </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point addition. Array version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_words</td><td>the words of the x coordinate of the other point </td></tr>
    <tr><td class="paramname">x_size</td><td>size of x_words </td></tr>
    <tr><td class="paramname">y_words</td><td>the words of the y coordinate of the other point </td></tr>
    <tr><td class="paramname">y_size</td><td>size of y_words </td></tr>
    <tr><td class="paramname">z_words</td><td>the words of the z coordinate of the other point </td></tr>
    <tr><td class="paramname">z_size</td><td>size of z_words </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point addition - mixed J+A </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>affine point to add - assumed to be affine! </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point addition - mixed J+A. Array version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_words</td><td>the words of the x coordinate of the other point </td></tr>
    <tr><td class="paramname">x_size</td><td>size of x_words </td></tr>
    <tr><td class="paramname">y_words</td><td>the words of the y coordinate of the other point </td></tr>
    <tr><td class="paramname">y_size</td><td>size of y_words </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point doubling </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Repeated point doubling </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>number of doublings to perform </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements</td></tr>
  </table>
  </dd>
</dl>
<p>Point addition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the point to add to *this </td></tr>
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>other plus *this</dd></dl>
<p>Point doubling </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workspace</td><td>temp space, at least WORKSPACE_SIZE elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this doubled</dd></dl>
<p>Return the zero (aka infinite) point associated with this curve</p>
<p>Return base curve of this point </p><dl class="section return"><dt>Returns</dt><dd>the curve over GF(p) of this point</dd></dl>
<p>You should not need to use this</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>ec domain parameters of the involved ec keys </td></tr>
    <tr><td class="paramname">kdf_spec</td><td>name of the key derivation function </td></tr>
    <tr><td class="paramname">length</td><td>length of the secret to be derived </td></tr>
    <tr><td class="paramname">compression_type</td><td>format of encoded keys (affects the secret derivation if single_hash_mode is used) </td></tr>
    <tr><td class="paramname">flags</td><td>options, see documentation of ECIES_Flags</td></tr>
    <tr><td class="paramname">private_key</td><td>the (ephemeral) private key which is used to derive the secret </td></tr>
    <tr><td class="paramname">ecies_params</td><td>settings for ecies </td></tr>
    <tr><td class="paramname">for_encryption</td><td>disable cofactor mode if the secret will be used for encryption (according to ISO 18033 cofactor mode is only used during decryption) </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use</td></tr>
  </table>
  </dd>
</dl>
<p>Performs a key agreement with the provided keys and derives the secret from the result </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eph_public_key_bin</td><td>the encoded (ephemeral) public key which belongs to the used (ephemeral) private key </td></tr>
    <tr><td class="paramname">other_public_key_point</td><td>public key point of the other party</td></tr>
  </table>
  </dd>
</dl>
<p>zero operand allowed</p>
<p>non-zero operand</p>
<p>Get the name of the underlying public key scheme. </p><dl class="section return"><dt>Returns</dt><dd>name of the public key scheme</dd></dl>
<p>Return the estimated strength of the underlying key against the best currently known attack. Note that this ignores anything but pure attacks against the key itself and do not take into account padding schemes, usage mistakes, etc which might reduce the strength. However it does suffice to provide an upper bound.</p>
<dl class="section return"><dt>Returns</dt><dd>estimated strength in bits</dd></dl>
<p>Return an integer value best approximating the length of the primary security parameter. For example for RSA this will be the size of the modulus, for ECDSA the size of the ECC group, and for McEliece the size of the code will be returned.</p>
<p>Get the OID of the underlying public key scheme. </p><dl class="section return"><dt>Returns</dt><dd>OID of the public key scheme</dd></dl>
<p><a class="el" href="class_test.html">Test</a> the key values for consistency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>rng to use </td></tr>
    <tr><td class="paramname">strong</td><td>whether to perform strong and lengthy version of the test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the test is passed</dd>
<dd>
X.509 AlgorithmIdentifier for this key</dd>
<dd>
BER encoded public key bits</dd>
<dd>
X.509 subject key encoding for this key object</dd>
<dd>
Hash of the subject public key</dd></dl>
<p>Returns more than 1 if the output of this algorithm (ciphertext, signature) should be treated as more than one value. This is used for algorithms like DSA and ECDSA, where the (r,s) output pair can be encoded as either a plain binary list or a TLV tagged DER encoding depending on the protocol.</p>
<p>This function is public but applications should have few reasons to ever call this.</p>
<dl class="section return"><dt>Returns</dt><dd>number of message parts</dd></dl>
<p>Returns how large each of the message parts refered to by message_parts() is</p>
<p>This function is public but applications should have few reasons to ever call this.</p>
<dl class="section return"><dt>Returns</dt><dd>size of the message parts in bits</dd></dl>
<p>This is an internal library function exposed on key types. In almost all cases applications should use wrappers in <a class="el" href="pubkey_8h_source.html">pubkey.h</a></p>
<p>Return an encryption operation for this key/params or throw</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator. The PK_Op may maintain a reference to the RNG and use it many times. The rng must outlive any operations which reference it. </td></tr>
    <tr><td class="paramname">params</td><td>additional parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>This is an internal library function exposed on key types. In almost all cases applications should use wrappers in <a class="el" href="pubkey_8h_source.html">pubkey.h</a></p>
<p>Return a KEM encryption operation for this key/params or throw</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator. The PK_Op may maintain a reference to the RNG and use it many times. The rng must outlive any operations which reference it. </td></tr>
    <tr><td class="paramname">params</td><td>additional parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>This is an internal library function exposed on key types. In almost all cases applications should use wrappers in <a class="el" href="pubkey_8h_source.html">pubkey.h</a></p>
<p>Return a verification operation for this key/params or throw </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>additional parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Encrypt a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array </td></tr>
    <tr><td class="paramname">rng</td><td>the random number source to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted message</dd></dl>
<p>Encrypt a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message </td></tr>
    <tr><td class="paramname">rng</td><td>the random number source to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encrypted message</dd></dl>
<p>Return the maximum allowed message size in bytes. </p><dl class="section return"><dt>Returns</dt><dd>maximum message size in bytes</dd></dl>
<p>Return an upper bound on the ciphertext length</p>
<p>Decrypt a ciphertext, throwing an exception if the input seems to be invalid (eg due to an accidental or malicious error in the ciphertext).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the ciphertext as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decrypted message</dd></dl>
<p>Same as above, but taking a vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the ciphertext </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decrypted message</dd></dl>
<p>Decrypt a ciphertext. If the ciphertext is invalid (eg due to invalid padding) or is not the expected length, instead returns a random string of the expected length. Use to avoid oracle attacks, especially against PKCS #1 v1.5 decryption.</p>
<p>Decrypt a ciphertext. If the ciphertext is invalid (eg due to invalid padding) or is not the expected length, instead returns a random string of the expected length. Use to avoid oracle attacks, especially against PKCS #1 v1.5 decryption.</p>
<p>Additionally checks (also in const time) that: contents[required_content_offsets[i]] == required_content_bytes[i] for 0 &lt;= i &lt; required_contents</p>
<p>Used for example in TLS, which encodes the client version in the content bytes: if there is any timing variation the version check can be used as an oracle to recover the key.</p>
<p>Return an upper bound on the plaintext length for a particular ciphertext input length</p>
<p>Construct a PK Signer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to use inside this signer </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use </td></tr>
    <tr><td class="paramname">emsa</td><td>the EMSA to use An example would be "EMSA1(SHA-224)". </td></tr>
    <tr><td class="paramname">format</td><td>the signature format to use </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Sign a message all in one go </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message to sign as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array </td></tr>
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signature</dd></dl>
<p>Sign a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message to sign </td></tr>
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signature</dd></dl>
<p>Add a message part (single byte). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the byte to add</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message part to add as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message part to add</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the message part to add</td></tr>
  </table>
  </dd>
</dl>
<p>Get the signature of the so far processed message (provided by the calls to update()). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signature of the total message</dd></dl>
<p>Set the output format of the signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the signature format to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return an upper bound on the length of the signatures this PK_Signer will produce</p>
<p>Construct a PK Verifier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pub_key</td><td>the public key to verify against </td></tr>
    <tr><td class="paramname">emsa</td><td>the EMSA to use (eg "EMSA3(SHA-1)") </td></tr>
    <tr><td class="paramname">format</td><td>the signature format to use </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Verify a signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message that the signature belongs to, as a byte array </td></tr>
    <tr><td class="paramname">msg_length</td><td>the length of the above byte array msg </td></tr>
    <tr><td class="paramname">sig</td><td>the signature as a byte array </td></tr>
    <tr><td class="paramname">sig_length</td><td>the length of the above byte array sig </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the signature is valid</dd></dl>
<p>Verify a signature. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message that the signature belongs to </td></tr>
    <tr><td class="paramname">sig</td><td>the signature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the signature is valid</dd></dl>
<p>Add a message part (single byte) of the message corresponding to the signature to be verified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the byte to add</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part of the message corresponding to the signature to be verified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_part</td><td>the new message part as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part of the message corresponding to the signature to be verified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the new message part</td></tr>
  </table>
  </dd>
</dl>
<p>Add a message part of the message corresponding to the signature to be verified.</p>
<p>Check the signature of the buffered message, i.e. the one build by successive calls to update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature to be verified as a byte array </td></tr>
    <tr><td class="paramname">length</td><td>the length of the above byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the signature is valid, false otherwise</dd></dl>
<p>Check the signature of the buffered message, i.e. the one build by successive calls to update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the signature to be verified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the signature is valid, false otherwise</dd></dl>
<p>Set the format of the signatures fed to this verifier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>the signature format to use</td></tr>
  </table>
  </dd>
</dl>
<p>Construct a PK Key Agreement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to use </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use </td></tr>
    <tr><td class="paramname">kdf</td><td>name of the KDF to use (or 'Raw' for no KDF) </td></tr>
    <tr><td class="paramname">provider</td><td>the algo provider to use (or empty for default)</td></tr>
  </table>
  </dd>
</dl>
<p>Perform Key Agreement Operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired key output size </td></tr>
    <tr><td class="paramname">in</td><td>the other parties key </td></tr>
    <tr><td class="paramname">in_len</td><td>the length of in in bytes </td></tr>
    <tr><td class="paramname">params</td><td>extra derivation params </td></tr>
    <tr><td class="paramname">params_len</td><td>the length of params in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Perform Key Agreement Operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired key output size </td></tr>
    <tr><td class="paramname">in</td><td>the other parties key </td></tr>
    <tr><td class="paramname">params</td><td>extra derivation params </td></tr>
    <tr><td class="paramname">params_len</td><td>the length of params in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Perform Key Agreement Operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired key output size </td></tr>
    <tr><td class="paramname">in</td><td>the other parties key </td></tr>
    <tr><td class="paramname">in_len</td><td>the length of in in bytes </td></tr>
    <tr><td class="paramname">params</td><td>extra derivation params</td></tr>
  </table>
  </dd>
</dl>
<p>Perform Key Agreement Operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_len</td><td>the desired key output size </td></tr>
    <tr><td class="paramname">in</td><td>the other parties key </td></tr>
    <tr><td class="paramname">params</td><td>extra derivation params</td></tr>
  </table>
  </dd>
</dl>
<p>Return the underlying size of the value that is agreed. If derive_key is called with a length of 0 with a "Raw" KDF, it will return a value of this size.</p>
<p>Construct an instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to use inside the encryptor </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use </td></tr>
    <tr><td class="paramname">kem_param</td><td>additional KEM parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Generate a shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_encapsulated_key</td><td>the generated encapsulated key </td></tr>
    <tr><td class="paramname">out_shared_key</td><td>the generated shared key </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use </td></tr>
    <tr><td class="paramname">salt</td><td>a salt value used in the KDF </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of the salt value in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Generate a shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_encapsulated_key</td><td>the generated encapsulated key </td></tr>
    <tr><td class="paramname">out_shared_key</td><td>the generated shared key </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use </td></tr>
    <tr><td class="paramname">salt</td><td>a salt value used in the KDF</td></tr>
  </table>
  </dd>
</dl>
<p>Generate a shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_encapsulated_key</td><td>the generated encapsulated key </td></tr>
    <tr><td class="paramname">out_shared_key</td><td>the generated shared key </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use</td></tr>
  </table>
  </dd>
</dl>
<p>Construct an instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to use inside the decryptor </td></tr>
    <tr><td class="paramname">rng</td><td>the RNG to use </td></tr>
    <tr><td class="paramname">kem_param</td><td>additional KEM parameters </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use</td></tr>
  </table>
  </dd>
</dl>
<p>Decrypts the shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encap_key</td><td>the encapsulated key </td></tr>
    <tr><td class="paramname">encap_key_len</td><td>size of the encapsulated key in bytes </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a salt value used in the KDF </td></tr>
    <tr><td class="paramname">salt_len</td><td>size of the salt value in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shared data encryption key</dd></dl>
<p>Decrypts the shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encap_key</td><td>the encapsulated key </td></tr>
    <tr><td class="paramname">encap_key_len</td><td>size of the encapsulated key in bytes </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shared data encryption key</dd></dl>
<p>Decrypts the shared key for data encryption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encap_key</td><td>the encapsulated key </td></tr>
    <tr><td class="paramname">desired_shared_key_len</td><td>desired size of the shared key in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>a salt value used in the KDF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shared data encryption key</dd></dl>
<p>Note: keeps persistent reference to order</p>
<dl class="section return"><dt>Returns</dt><dd>XMSS registry name for the chosen parameter set.</dd></dl>
<p>Retrieves the uniform length of a message, and the size of each node. This correlates to XMSS parameter "n" defined in [1].</p>
<dl class="section return"><dt>Returns</dt><dd>element length in bytes.</dd>
<dd>
The height (number of levels - 1) of the tree</dd></dl>
<p>The Winternitz parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>numeric base used for internal representation of data.</dd></dl>
<p>Returns the estimated pre-quantum security level of the chosen algorithm.</p>
<p>Randomize a byte array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the byte array to hold the random output. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array output in bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns false if it is known that this RNG object is not able to accept externally provided inputs (via add_entropy, randomize_with_input, etc). In this case, any such provided inputs are ignored.</p>
<p>If this function returns true, then inputs may or may not be accepted.</p>
<p>Incorporate some additional data into the RNG state. For example adding nonces or timestamps from a peer's protocol message can help hedge against VM state rollback attacks. A few RNG types do not accept any externally provided input, in which case this function is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a byte array containg the entropy to be added </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array in</td></tr>
  </table>
  </dd>
</dl>
<p>Incorporate some additional data into the RNG state.</p>
<p>Incorporate entropy into the RNG state then produce output. Some RNG types implement this using a single operation, default calls add_entropy + randomize in sequence.</p>
<p>Use this to further bind the outputs to your current process/protocol state. For instance if generating a new key for use in a session, include a session ID or other such value. See NIST SP 800-90 A, B, C series for more ideas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>buffer to hold the random output </td></tr>
    <tr><td class="paramname">output_len</td><td>size of the output buffer in bytes </td></tr>
    <tr><td class="paramname">input</td><td>entropy buffer to incorporate </td></tr>
    <tr><td class="paramname">input_len</td><td>size of the input buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>This calls <code>randomize_with_input</code> using some timestamps as extra input.</p>
<p>For a stateful RNG using non-random but potentially unique data the extra input can help protect against problems with fork, VM state rollback, or other cases where somehow an RNG state is duplicated. If both of the duplicated RNG states later incorporate a timestamp (and the timestamps don't themselves repeat), their outputs will diverge.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of this RNG type</dd></dl>
<p>Clear all internally held values of this RNG </p><dl class="section post"><dt>Postcondition</dt><dd>is_seeded() == false</dd></dl>
<p>Check whether this RNG is seeded. </p><dl class="section return"><dt>Returns</dt><dd>true if this RNG was already seeded, false otherwise.</dd></dl>
<p>Poll provided sources for up to poll_bits bits of entropy or until the timeout expires. Returns estimate of the number of bits collected.</p>
<p>Reseed by reading specified bits from the RNG</p>
<p>Return a random vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>number of bytes in the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>randomized vector of length bytes</dd></dl>
<p>Return a random byte </p><dl class="section return"><dt>Returns</dt><dd>random byte</dd>
<dd>
a random byte that is greater than zero</dd></dl>
<p>Create a seeded and active RNG object for general application use Added in 1.8.0 Use AutoSeeded_RNG instead</p>
<p>Return a list of the certificates of CAs that we trust in this type/context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring</td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. For instance for type "tls-client", context specifies the servers name.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a cert chain we can use, ordered from leaf to root, or else an empty vector.</p>
<p>It is assumed that the caller can get the private key of the leaf with private_key_for</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_key_types</td><td>specifies the key types desired ("RSA", "DSA", "ECDSA", etc), or empty if there is no preference by the caller.</td></tr>
    <tr><td class="paramname">acceptable_CAs</td><td>the CAs the requestor will accept (possibly empty) </td></tr>
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a cert chain we can use, ordered from leaf to root, or else an empty vector.</p>
<p>This virtual function is deprecated, and will be removed in a future release. Use (and override) find_cert_chain instead.</p>
<p>It is assumed that the caller can get the private key of the leaf with private_key_for</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_key_types</td><td>specifies the key types desired ("RSA", "DSA", "ECDSA", etc), or empty if there is no preference by the caller.</td></tr>
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring</td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a cert chain we can use, ordered from leaf to root, or else an empty vector.</p>
<p>It is assumed that the caller can get the private key of the leaf with private_key_for</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert_key_type</td><td>specifies the type of key requested ("RSA", "DSA", "ECDSA", etc)</td></tr>
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring</td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>private key associated with this certificate if we should use it with this context. cert was returned by cert_chain </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this object should retain ownership of the returned key; it should not be deleted by the caller.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we should attempt SRP authentication</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>identifier for client-side SRP auth, if available for this type/context. Should return empty string if password auth not desired/available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
    <tr><td class="paramname">identifier</td><td>specifies what identifier we want the password for. This will be a value previously returned by srp_identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>password for client-side SRP auth, if available for this identifier/type/context.</dd></dl>
<p>Retrieve SRP verifier parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the PSK identity hint for this type/context</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
    <tr><td class="paramname">identity_hint</td><td>was passed by the server (but may be empty) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the PSK identity we want to use</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies the type of operation occurring </td></tr>
    <tr><td class="paramname">context</td><td>specifies a context relative to type. </td></tr>
    <tr><td class="paramname">identity</td><td>is a PSK identity previously returned by psk_identity for the same type and context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the PSK used for identity, or throw an exception if no key exists</dd></dl>
<p>The year <br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
 The month, 1 through 12 for Jan to Dec <br />
<br />
<br />
<br />
<br />
<br />
<br />
 The day of the month, 1 through 31 (or 28 or 30 based on month <br />
<br />
<br />
<br />
<br />
<br />
 Hour in 24-hour form, 0 to 23 <br />
<br />
<br />
<br />
<br />
 Minutes in the hour, 0 to 60 <br />
</p><pre class="fragment">Seconds in the minute, 0 to 60, but might be slightly
</pre><p> larger to deal with leap seconds on some systems</p>
<p>Initialize a calendar_point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>the year </td></tr>
    <tr><td class="paramname">mon</td><td>the month </td></tr>
    <tr><td class="paramname">d</td><td>the day </td></tr>
    <tr><td class="paramname">h</td><td>the hour </td></tr>
    <tr><td class="paramname">min</td><td>the minute </td></tr>
    <tr><td class="paramname">sec</td><td>the second</td></tr>
  </table>
  </dd>
</dl>
<p>Returns an STL timepoint object</p>
<p>Returns a human readable string of the struct's components. Formatting might change over time. Currently it is RFC339 'iso-date-time'.</p>
<p>Read from the source. Moves the internal offset so that every call to read will return a new portion of the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the byte array to write the result to </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array out </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes that was actually read and put into out</dd></dl>
<p>Read from the source but do not modify the internal offset. Consecutive calls to peek() will return portions of the source starting at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the byte array to write the output to </td></tr>
    <tr><td class="paramname">length</td><td>the length of the byte array out </td></tr>
    <tr><td class="paramname">peek_offset</td><td>the offset into the stream to read at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes that was actually read and put into out</dd></dl>
<p><a class="el" href="class_test.html">Test</a> whether the source still has data that can be read. </p><dl class="section return"><dt>Returns</dt><dd>true if there is no more data to read, false otherwise</dd></dl>
<p>return the id of this data source </p><dl class="section return"><dt>Returns</dt><dd>std::string representing the id of this data source</dd></dl>
<p>Read one byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the byte to read to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes that was actually read and put into out</dd></dl>
<p>Peek at one byte. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>an output byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length in bytes that was actually read and put into out</dd></dl>
<p>Discard the next N bytes of the data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>the number of bytes to discard </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes actually discarded</dd>
<dd>
number of bytes read so far.</dd></dl>
<p>Load a DLL (or fail with an exception) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lib_name</td><td>name or path to a library</td></tr>
  </table>
  </dd>
</dl>
<p>If you don't use a full path, the search order will be defined by whatever the system linker does by default. Always using fully qualified pathnames can help prevent code injection attacks (eg via manipulation of LD_LIBRARY_PATH on Linux)</p>
<p>Unload the DLL </p><dl class="section warning"><dt>Warning</dt><dd>Any pointers returned by resolve()/resolve_symbol() should not be used after this destructor runs.</dd></dl>
<p>Load a symbol (or fail with an exception) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>names the symbol to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the loaded symbol</dd></dl>
<p>Convenience function for casting symbol to the right type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>names the symbol to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the loaded symbol</dd></dl>
<p>Find a certificate by Subject DN and (optionally) key identifier </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject_dn</td><td>the subject's distinguished name </td></tr>
    <tr><td class="paramname">key_id</td><td>an optional key id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matching certificate or nullptr otherwise</dd></dl>
<p>Find all certificates with a given Subject DN. Subject DN and even the key identifier might not be unique.</p>
<p>Find a certificate by searching for one with a matching SHA-1 hash of public key. Used for OCSP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_hash</td><td>SHA-1 hash of the subject's public key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matching certificate or nullptr otherwise</dd></dl>
<p>Find a certificate by searching for one with a matching SHA-256 hash of raw subject name. Used for OCSP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject_hash</td><td>SHA-256 hash of the subject's raw name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a matching certificate or nullptr otherwise</dd></dl>
<p>Finds a CRL for the given certificate </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>the subject certificate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the CRL for subject or nullptr otherwise</dd>
<dd>
whether the certificate is known </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cert</td><td>certififcate to be searched</td></tr>
  </table>
  </dd>
</dl>
<p>Creates an empty name NameConstraints.</p>
<p>Creates NameConstraints from a list of permitted and excluded subtrees. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permitted_subtrees</td><td>names for which the certificate is permitted </td></tr>
    <tr><td class="paramname">excluded_subtrees</td><td>names for which the certificate is not permitted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>permitted names</dd>
<dd>
excluded names</dd></dl>
<p>Sign a PKCS#10 <a class="el" href="struct_request.html">Request</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>the request to sign </td></tr>
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
    <tr><td class="paramname">not_before</td><td>the starting time for the certificate </td></tr>
    <tr><td class="paramname">not_after</td><td>the expiration time for the certificate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting certificate</dd></dl>
<p>Sign a PKCS#10 <a class="el" href="struct_request.html">Request</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>the request to sign </td></tr>
    <tr><td class="paramname">rng</td><td>the rng to use </td></tr>
    <tr><td class="paramname">serial_number</td><td>the serial number the cert will be assigned. </td></tr>
    <tr><td class="paramname">not_before</td><td>the starting time for the certificate </td></tr>
    <tr><td class="paramname">not_after</td><td>the expiration time for the certificate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting certificate</dd></dl>
<p>Get the certificate of this CA. </p><dl class="section return"><dt>Returns</dt><dd>CA certificate</dd></dl>
<p>Create a new and empty CRL for this CA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">issue_time</td><td>the issue time (typically system_clock::now) </td></tr>
    <tr><td class="paramname">next_update</td><td>the time interval after issue_data within which a new CRL will be produced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new CRL</dd></dl>
<p>Create a new CRL by with additional entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">last_crl</td><td>the last CRL of this CA to add the new entries to </td></tr>
    <tr><td class="paramname">new_entries</td><td>contains the new CRL entries to be added to the CRL </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">issue_time</td><td>the issue time (typically system_clock::now) </td></tr>
    <tr><td class="paramname">next_update</td><td>the time interval after issue_data within which a new CRL will be produced.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new and empty CRL for this CA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">next_update</td><td>the time to set in next update in seconds as the offset from the current time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new CRL</dd></dl>
<p>Create a new CRL by with additional entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">last_crl</td><td>the last CRL of this CA to add the new entries to </td></tr>
    <tr><td class="paramname">new_entries</td><td>contains the new CRL entries to be added to the CRL </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">next_update</td><td>the time to set in next update in seconds as the offset from the current time</td></tr>
  </table>
  </dd>
</dl>
<p>Interface for creating new certificates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signer</td><td>a signing object </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">sig_algo</td><td>the signature algorithm identifier </td></tr>
    <tr><td class="paramname">pub_key</td><td>the serialized public key </td></tr>
    <tr><td class="paramname">not_before</td><td>the start time of the certificate </td></tr>
    <tr><td class="paramname">not_after</td><td>the end time of the certificate </td></tr>
    <tr><td class="paramname">issuer_dn</td><td>the DN of the issuer </td></tr>
    <tr><td class="paramname">subject_dn</td><td>the DN of the subject </td></tr>
    <tr><td class="paramname">extensions</td><td>an optional list of certificate extensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly minted certificate</dd></dl>
<p>Interface for creating new certificates </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signer</td><td>a signing object </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">serial_number</td><td>the serial number the cert will be assigned </td></tr>
    <tr><td class="paramname">sig_algo</td><td>the signature algorithm identifier </td></tr>
    <tr><td class="paramname">pub_key</td><td>the serialized public key </td></tr>
    <tr><td class="paramname">not_before</td><td>the start time of the certificate </td></tr>
    <tr><td class="paramname">not_after</td><td>the end time of the certificate </td></tr>
    <tr><td class="paramname">issuer_dn</td><td>the DN of the issuer </td></tr>
    <tr><td class="paramname">subject_dn</td><td>the DN of the subject </td></tr>
    <tr><td class="paramname">extensions</td><td>an optional list of certificate extensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly minted certificate</dd></dl>
<p>Create a new CA object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ca_certificate</td><td>the certificate of the CA </td></tr>
    <tr><td class="paramname">key</td><td>the private key of the CA </td></tr>
    <tr><td class="paramname">hash_fn</td><td>name of a hash function to use for signing </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new CA object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ca_certificate</td><td>the certificate of the CA </td></tr>
    <tr><td class="paramname">key</td><td>the private key of the CA </td></tr>
    <tr><td class="paramname">opts</td><td>additional options, e.g. padding, as key value pairs </td></tr>
    <tr><td class="paramname">hash_fn</td><td>name of a hash function to use for signing </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OID representing this extension</dd></dl>
<p>Make a copy of this extension </p><dl class="section return"><dt>Returns</dt><dd>copy of this</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">require_rev</td><td>if true, revocation information is required</td></tr>
    <tr><td class="paramname">minimum_key_strength</td><td>is the minimum strength (in terms of operations, eg 80 means 2^80) of a signature. Signatures weaker than this are rejected. If more than 80, SHA-1 signatures are also rejected. If possible use at least setting 110. <pre class="fragment">80 bit strength requires 1024 bit RSA
110 bit strength requires 2k bit RSA
128 bit strength requires ~3k bit RSA or P-256
</pre> </td></tr>
    <tr><td class="paramname">ocsp_all_intermediates</td><td>Make OCSP requests for all CAs as well as end entity (if OCSP enabled in path validation request)</td></tr>
    <tr><td class="paramname">require_rev</td><td>if true, revocation information is required </td></tr>
    <tr><td class="paramname">minimum_key_strength</td><td>is the minimum strength (in terms of operations, eg 80 means 2^80) of a signature. Signatures weaker than this are rejected. </td></tr>
    <tr><td class="paramname">ocsp_all_intermediates</td><td>Make OCSP requests for all CAs as well as end entity (if OCSP enabled in path validation request) </td></tr>
    <tr><td class="paramname">trusted_hashes</td><td>a set of trusted hashes. Any signatures created using a hash other than one of these will be rejected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether revocation information is required</dd>
<dd>
whether all intermediate CAs should also be OCSPed. If false then only end entity OCSP is required/requested.</dd>
<dd>
trusted signature hash functions</dd>
<dd>
minimum required key strength</dd>
<dd>
the set of hash functions you are implicitly trusting by trusting this result.</dd>
<dd>
the trust root of the validation if successful throws an exception if the validation failed</dd>
<dd>
the full path from subject to trust root This path may be empty</dd>
<dd>
true iff the validation was successful</dd>
<dd>
true iff no warnings occured during validation</dd>
<dd>
overall validation result code</dd>
<dd>
a set of status codes for each certificate in the chain</dd>
<dd>
the subset of status codes that are warnings</dd>
<dd>
string representation of the validation result</dd>
<dd>
string representation of the warnings</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>validation status code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>corresponding validation status message</dd></dl>
<p>Create a Path_Validation_Result </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>list of validation status codes </td></tr>
    <tr><td class="paramname">cert_chain</td><td>the certificate chain that was validated</td></tr>
  </table>
  </dd>
</dl>
<p>Create a Path_Validation_Result </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>validation status code</td></tr>
  </table>
  </dd>
</dl>
<p>the subject common name</p>
<p>the subject counry</p>
<p>the subject organization</p>
<p>the subject organizational unit</p>
<p>the subject locality</p>
<p>the subject state</p>
<p>the subject serial number</p>
<p>the subject email adress</p>
<p>the subject URI</p>
<p>the subject IPv4 address</p>
<p>the subject DNS</p>
<p>the subject XMPP</p>
<p>the subject challenge password</p>
<p>the subject notBefore</p>
<p>the subject notAfter</p>
<p>Indicates whether the certificate request</p>
<p>Indicates the BasicConstraints path limit</p>
<p>The key constraints for the subject public key</p>
<p>The key extended constraints for the subject public key</p>
<p>Additional X.509 extensions</p>
<p>Mark the certificate as a CA certificate and set the path limit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>the path limit to be set in the BasicConstraints extension.</td></tr>
  </table>
  </dd>
</dl>
<p>Choose a padding scheme different from the default for the key used.</p>
<p>Set the notBefore of the certificate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the notBefore value of the certificate</td></tr>
  </table>
  </dd>
</dl>
<p>Set the notAfter of the certificate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the notAfter value of the certificate</td></tr>
  </table>
  </dd>
</dl>
<p>Add the key constraints of the KeyUsage extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constr</td><td>the constraints to set</td></tr>
  </table>
  </dd>
</dl>
<p>Add constraints to the ExtendedKeyUsage extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>the oid to add</td></tr>
  </table>
  </dd>
</dl>
<p>Add constraints to the ExtendedKeyUsage extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name to look up the oid to add</td></tr>
  </table>
  </dd>
</dl>
<p>Construct a new options object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>define the common name of this object. An example for this parameter would be "common_name/country/organization/organizational_unit". </td></tr>
    <tr><td class="paramname">expire_time</td><td>the expiration time (from the current clock in seconds)</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="asn1__obj_8h_source.html#l00065">65</a> of file <a class="el" href="asn1__obj_8h_source.html">asn1_obj.h</a>.</p>

</div>
</div>
<a id="aa0df5a86f85160d4d4b3cfdb3fe37b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0df5a86f85160d4d4b3cfdb3fe37b55">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Path_Validation_Result Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This class represents ASN.1 object identifiers. Append another component onto the OID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>the OID to add the new component to </td></tr>
    <tr><td class="paramname">new_comp</td><td>the new component to add</td></tr>
  </table>
  </dd>
</dl>
<p>Compare two OIDs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first OID </td></tr>
    <tr><td class="paramname">b</td><td>the second OID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a is lexicographically smaller than b</dd></dl>
<p>Concatenate two strings </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an octet string </td></tr>
    <tr><td class="paramname">y</td><td>an octet string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x concatenated with y</dd></dl>
<p>XOR two strings </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an octet string </td></tr>
    <tr><td class="paramname">y</td><td>an octet string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x XORed with y</dd></dl>
<p>BigInt Division </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an integer </td></tr>
    <tr><td class="paramname">y</td><td>a non-zero integer </td></tr>
    <tr><td class="paramname">q</td><td>will be set to x / y </td></tr>
    <tr><td class="paramname">r</td><td>will be set to x % y</td></tr>
  </table>
  </dd>
</dl>
<p>NIST Prime reduction functions.</p>
<p>Reduces the value in place</p>
<p>ws is a workspace function which is used as a temporary, and will be resized as needed.</p>
<p>Fused multiply-add </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>an integer </td></tr>
    <tr><td class="paramname">b</td><td>an integer </td></tr>
    <tr><td class="paramname">c</td><td>an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(a*b)+c</dd></dl>
<p>Fused subtract-multiply </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>an integer </td></tr>
    <tr><td class="paramname">b</td><td>an integer </td></tr>
    <tr><td class="paramname">c</td><td>an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(a-b)*c</dd></dl>
<p>Fused multiply-subtract </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>an integer </td></tr>
    <tr><td class="paramname">b</td><td>an integer </td></tr>
    <tr><td class="paramname">c</td><td>an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(a*b)-c</dd></dl>
<p>Compute the greatest common divisor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a positive integer </td></tr>
    <tr><td class="paramname">y</td><td>a positive integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gcd(x,y)</dd></dl>
<p>Least common multiple </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a positive integer </td></tr>
    <tr><td class="paramname">y</td><td>a positive integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>z, smallest integer such that z % x == 0 and z % y == 0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x*x)</dd></dl>
<p>Modular inversion </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a positive integer </td></tr>
    <tr><td class="paramname">modulus</td><td>a positive integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>y st (x*y) % modulus == 1 or 0 if no such value Not const time</dd></dl>
<p>Const time modular inversion Requires the modulus be odd</p>
<p>Return a^-1 * 2^k mod b Returns k, between n and 2n Not const time</p>
<p>Call almost_montgomery_inverse and correct the result to a^-1 mod b</p>
<p>Compute the Jacobi symbol. If n is prime, this is equivalent to the Legendre symbol. </p><dl class="section see"><dt>See also</dt><dd><a href="http://mathworld.wolfram.com/JacobiSymbol.html">http://mathworld.wolfram.com/JacobiSymbol.html</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is a non-negative integer </td></tr>
    <tr><td class="paramname">n</td><td>is an odd integer &gt; 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(n / m)</dd></dl>
<p>Modular exponentation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>an integer base </td></tr>
    <tr><td class="paramname">x</td><td>a positive exponent </td></tr>
    <tr><td class="paramname">m</td><td>a positive modulus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(b^x) % m</dd></dl>
<p>Compute the square root of x modulo a prime using the Shanks-Tonnelli algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input </td></tr>
    <tr><td class="paramname">p</td><td>the prime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>y such that (y*y)p == x, or -1 if no such integer</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a positive integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of the zero bits in x, or, equivalently, the largest value of n such that 2^n divides x evenly. Returns zero if n is less than or equal to zero.</dd></dl>
<p>Check for primality </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a positive integer to test for primality </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">prob</td><td>chance of false positive is bounded by 1/2**prob </td></tr>
    <tr><td class="paramname">is_random</td><td>true if n was randomly chosen by us </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all primality tests passed, otherwise false</dd></dl>
<p>Randomly generate a prime suitable for discrete logarithm parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">bits</td><td>how large the resulting prime should be in bits </td></tr>
    <tr><td class="paramname">coprime</td><td>a positive integer that (prime - 1) should be coprime to </td></tr>
    <tr><td class="paramname">equiv</td><td>a non-negative number that the result should be equivalent to modulo equiv_mod </td></tr>
    <tr><td class="paramname">equiv_mod</td><td>the modulus equiv should be checked against </td></tr>
    <tr><td class="paramname">prob</td><td>use test so false positive is bounded by 1/2**prob </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random prime with the specified criteria</dd></dl>
<p>Return a 'safe' prime, of the form p=2*q+1 with q prime </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">bits</td><td>is how long the resulting prime should be </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>prime randomly chosen from safe primes of length bits</dd></dl>
<p>Generate DSA parameters using the FIPS 186 kosherizer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">p_out</td><td>where the prime p will be stored </td></tr>
    <tr><td class="paramname">q_out</td><td>where the prime q will be stored </td></tr>
    <tr><td class="paramname">pbits</td><td>how long p will be in bits </td></tr>
    <tr><td class="paramname">qbits</td><td>how long q will be in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random seed used to generate this parameter set</dd></dl>
<p>Generate DSA parameters using the FIPS 186 kosherizer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">p_out</td><td>where the prime p will be stored </td></tr>
    <tr><td class="paramname">q_out</td><td>where the prime q will be stored </td></tr>
    <tr><td class="paramname">pbits</td><td>how long p will be in bits </td></tr>
    <tr><td class="paramname">qbits</td><td>how long q will be in bits </td></tr>
    <tr><td class="paramname">seed</td><td>the seed used to generate the parameters </td></tr>
    <tr><td class="paramname">offset</td><td>optional offset from seed to start searching at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if seed generated a valid DSA parameter set, otherwise false. p_out and q_out are only valid if true was returned.</dd></dl>
<p>Rivest's Package Tranform </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>the random number generator to use </td></tr>
    <tr><td class="paramname">cipher</td><td>the block cipher to use (aont_package takes ownership) </td></tr>
    <tr><td class="paramname">input</td><td>the input data buffer </td></tr>
    <tr><td class="paramname">input_len</td><td>the length of the input data in bytes </td></tr>
    <tr><td class="paramname">output</td><td>the output data buffer (must be at least input_len + cipher-&gt;BLOCK_SIZE bytes long)</td></tr>
  </table>
  </dd>
</dl>
<p>Encrypt a key under a key encryption key using the algorithm described in RFC 3394</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the plaintext key to encrypt </td></tr>
    <tr><td class="paramname">kek</td><td>the key encryption key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>key encrypted under kek</dd></dl>
<p>Decrypt a key under a key encryption key using the algorithm described in RFC 3394</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the encrypted key to decrypt </td></tr>
    <tr><td class="paramname">kek</td><td>the key encryption key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>key decrypted under kek</dd></dl>
<p>SRP6a Client side </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">username</td><td>the username we are attempting login for </td></tr>
    <tr><td class="paramname">password</td><td>the password we are attempting to use </td></tr>
    <tr><td class="paramname">group_id</td><td>specifies the shared SRP group </td></tr>
    <tr><td class="paramname">hash_id</td><td>specifies a secure hash function </td></tr>
    <tr><td class="paramname">salt</td><td>is the salt value sent by the server </td></tr>
    <tr><td class="paramname">B</td><td>is the server's public value </td></tr>
    <tr><td class="paramname">rng</td><td>is a random number generator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(A,K) the client public key and the shared secret key Generate a new SRP-6 verifier </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">identifier</td><td>a username or other client identifier </td></tr>
    <tr><td class="paramname">password</td><td>the secret used to authenticate user </td></tr>
    <tr><td class="paramname">salt</td><td>a randomly chosen value, at least 128 bits long </td></tr>
    <tr><td class="paramname">group_id</td><td>specifies the shared SRP group </td></tr>
    <tr><td class="paramname">hash_id</td><td>specifies a secure hash function Return the group id for this SRP param set, or else thrown an exception </td></tr>
    <tr><td class="paramname">N</td><td>the group modulus </td></tr>
    <tr><td class="paramname">g</td><td>the group generator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>group identifier</dd></dl>
<p>MGF1 from PKCS #1 v2.0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>hash function to use </td></tr>
    <tr><td class="paramname">in</td><td>input buffer </td></tr>
    <tr><td class="paramname">in_len</td><td>size of the input buffer in bytes </td></tr>
    <tr><td class="paramname">out</td><td>output buffer </td></tr>
    <tr><td class="paramname">out_len</td><td>size of the output buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Point multiplication operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar value </td></tr>
    <tr><td class="paramname">point</td><td>the point value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar*point on the curve</dd></dl>
<p>ECC point multiexponentiation - not constant time! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>a point </td></tr>
    <tr><td class="paramname">z1</td><td>a scalar </td></tr>
    <tr><td class="paramname">p2</td><td>a point </td></tr>
    <tr><td class="paramname">z2</td><td>a scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(p1 * z1 + p2 * z2)</dd></dl>
<p>McEliece Integrated Encryption System Derive a shared key using MCE KEM and encrypt/authenticate the plaintext and AD using AES-256 in OCB mode.</p>
<p>McEliece Integrated Encryption System Derive a shared key using MCE KEM and decrypt/authenticate the ciphertext and AD using AES-256 in OCB mode.</p>
<p>Encrypt with PBES2 from PKCS #5 v2.0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_bits</td><td>the input </td></tr>
    <tr><td class="paramname">passphrase</td><td>the passphrase to use for encryption </td></tr>
    <tr><td class="paramname">msec</td><td>how many milliseconds to run PBKDF2 </td></tr>
    <tr><td class="paramname">cipher</td><td>specifies the block cipher to use to encrypt </td></tr>
    <tr><td class="paramname">digest</td><td>specifies the PRF to use with PBKDF2 (eg "HMAC(SHA-1)") </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator</td></tr>
  </table>
  </dd>
</dl>
<p>Decrypt a PKCS #5 v2.0 encrypted stream </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_bits</td><td>the input </td></tr>
    <tr><td class="paramname">passphrase</td><td>the passphrase to use for decryption </td></tr>
    <tr><td class="paramname">params</td><td>the PBES2 parameters</td></tr>
    <tr><td class="paramname">x</td><td>the secret (EC)DSA key </td></tr>
    <tr><td class="paramname">q</td><td>the group order </td></tr>
    <tr><td class="paramname">h</td><td>the message hash already reduced mod q </td></tr>
    <tr><td class="paramname">hash</td><td>the hash function used to generate h</td></tr>
  </table>
  </dd>
</dl>
<p>Return a shared reference to a global PRNG instance provided by the operating system. For instance might be instantiated by /dev/urandom or CryptGenRandom.</p>
<p>Check that key constraints are permitted for a specific public key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pub_key</td><td>the public key on which the constraints shall be enforced on </td></tr>
    <tr><td class="paramname">constraints</td><td>the constraints that shall be enforced on the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>if the given constraints are not permitted for this key</td></tr>
  </table>
  </dd>
</dl>
<p>Choose the default signature format for a certain public key signature scheme. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>will be the key to choose a padding scheme for </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use </td></tr>
    <tr><td class="paramname">hash_fn</td><td>is the desired hash function </td></tr>
    <tr><td class="paramname">alg_id</td><td>will be set to the chosen scheme </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A PK_Signer object for generating signatures</dd></dl>
<p><a class="el" href="namespace_botan_1_1_p_k_i_x.html">PKIX</a> Path Validation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end_cert</td><td>certificate to validate </td></tr>
    <tr><td class="paramname">restrictions</td><td>path validation restrictions </td></tr>
    <tr><td class="paramname">trusted_roots</td><td>list of stores that contain trusted certificates </td></tr>
    <tr><td class="paramname">hostname</td><td>if not empty, compared against the DNS name in end_cert </td></tr>
    <tr><td class="paramname">usage</td><td>if not set to UNSPECIFIED, compared against the key usage in end_cert </td></tr>
    <tr><td class="paramname">validation_time</td><td>what reference time to use for validation </td></tr>
    <tr><td class="paramname">ocsp_timeout</td><td>timeout for OCSP operations, 0 disables OCSP check </td></tr>
    <tr><td class="paramname">ocsp_resp</td><td>additional OCSP responses to consider (eg from peer) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the path validation</dd></dl>
<p><a class="el" href="namespace_botan_1_1_p_k_i_x.html">PKIX</a> Path Validation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end_cert</td><td>certificate to validate </td></tr>
    <tr><td class="paramname">restrictions</td><td>path validation restrictions </td></tr>
    <tr><td class="paramname">store</td><td>store that contains trusted certificates </td></tr>
    <tr><td class="paramname">hostname</td><td>if not empty, compared against the DNS name in end_cert </td></tr>
    <tr><td class="paramname">usage</td><td>if not set to UNSPECIFIED, compared against the key usage in end_cert </td></tr>
    <tr><td class="paramname">validation_time</td><td>what reference time to use for validation </td></tr>
    <tr><td class="paramname">ocsp_timeout</td><td>timeout for OCSP operations, 0 disables OCSP check </td></tr>
    <tr><td class="paramname">ocsp_resp</td><td>additional OCSP responses to consider (eg from peer) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of the path validation </dd></dl>

</div>
</div>
<a id="a0f25b10ed41d28e8a0f7026b35b96838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f25b10ed41d28e8a0f7026b35b96838">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">5&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modular inversion using extended binary Euclidian algorithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a positive integer </td></tr>
    <tr><td class="paramname">modulus</td><td>a positive integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>y st (x*y) % modulus == 1 or 0 if no such value Not const time </dd></dl>

</div>
</div>
<a id="a835833515e6080a0d56a13ff99ef4958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835833515e6080a0d56a13ff99ef4958">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform base64 decoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some base64 input </td></tr>
    <tr><td class="paramname">ignore_ws</td><td>ignore whitespace on input; if false, throw an exception if whitespace is encountered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded base64 output Calculate the size of output buffer for base64_encode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_length</td><td>the length of input in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of output buffer in bytes</dd></dl>
<p>Calculate the size of output buffer for base64_decode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_length</td><td>the length of input in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of output buffer in bytes</dd></dl>
<p>A class handling runtime CPU feature detection. It is limited to just the features necessary to implement CPU specific code in <a class="el" href="namespace_botan.html">Botan</a>, rather than being a general purpose utility.</p>
<p>This class supports:</p>
<ul>
<li>x86 features using CPUID. x86 is also the only processor with accurate cache line detection currently.</li>
<li>PowerPC AltiVec detection on Linux, NetBSD, OpenBSD, and Darwin</li>
<li>ARM NEON and crypto extensions detection. On Linux and Android systems which support getauxval, that is used to access CPU feature information. Otherwise a relatively portable but thread-unsafe mechanism involving executing probe functions which catching SIGILL signal is used. </li>
</ul>
<p>Probe the CPU and see what extensions are supported</p>
<p>Deprecated equivalent to o &lt;&lt; "CPUID flags: " &lt;&lt; CPUID::to_string() &lt;&lt; "\n";</p>
<p>Return a possibly empty string containing list of known CPU extensions. Each name will be seperated by a space, and the ordering will be arbitrary. This list only contains values that are useful to <a class="el" href="namespace_botan.html">Botan</a> (for example FMA instructions are not checked).</p>
<p>Example outputs "sse2 ssse3 rdtsc", "neon arm_aes", "altivec"</p>
<p>Return a best guess of the cache line size</p>
<p>Probe the CPU and see what extensions are supported</p>
<p>Deprecated equivalent to o &lt;&lt; "CPUID flags: " &lt;&lt; CPUID::to_string() &lt;&lt; "\n";</p>
<p>Return a possibly empty string containing list of known CPU extensions. Each name will be seperated by a space, and the ordering will be arbitrary. This list only contains values that are useful to <a class="el" href="namespace_botan.html">Botan</a> (for example FMA instructions are not checked).</p>
<p>Example outputs "sse2 ssse3 rdtsc", "neon arm_aes", "altivec"</p>
<p>Return a best guess of the cache line size</p>

<p class="definition">Definition at line <a class="el" href="cpuid_8h_source.html#l00036">36</a> of file <a class="el" href="cpuid_8h_source.html">cpuid.h</a>.</p>

</div>
</div>
<a id="a306d82593a051b515b926e213e8040f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306d82593a051b515b926e213e8040f2">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">4&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Format ASN.1 data and call a virtual to format</p>
<p>Key wrap. See RFC 3394 and NIST SP800-38F </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the value to be encrypted </td></tr>
    <tr><td class="paramname">input_len</td><td>length of input, must be a multiple of 8 </td></tr>
    <tr><td class="paramname">bc</td><td>a keyed 128-bit block cipher that will be used to encrypt input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input encrypted under NIST key wrap algorithm</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the value to be decrypted, output of nist_key_wrap </td></tr>
    <tr><td class="paramname">input_len</td><td>length of input </td></tr>
    <tr><td class="paramname">bc</td><td>a keyed 128-bit block cipher that will be used to decrypt input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input decrypted under NIST key wrap algorithm Throws an exception if decryption fails.</dd></dl>
<p>KWP (key wrap with padding). See RFC 5649 and NIST SP800-38F </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the value to be encrypted </td></tr>
    <tr><td class="paramname">input_len</td><td>length of input </td></tr>
    <tr><td class="paramname">bc</td><td>a keyed 128-bit block cipher that will be used to encrypt input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input encrypted under NIST key wrap algorithm</dd></dl>
<p>This is an interface to a generic PSK (pre-shared key) database. It might be implemented as a plaintext storage or via some mechanism that encrypts the keys and/or values.</p>
<p>Return a version string of the form "MAJOR.MINOR.PATCH" where each of the values is an integer. Same as version_short_string except returning a pointer to the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">print_context_specific</td><td>if true, try to parse nested context specific data. </td></tr>
    <tr><td class="paramname">max_depth</td><td>do not recurse more than this many times. If zero, recursion is unbounded.</td></tr>
  </table>
  </dd>
</dl>
<p>This is called for each element</p>
<p>This is called to format binary elements that we don't know how to convert to a string The result will be passed as value to format; the tags are included as a hint to aid decoding.</p>
<p>Return the set of names for which get() will return a value.</p>
<p>Return the value associated with the specified</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>or otherwise throw an exception.</td></tr>
  </table>
  </dd>
</dl>
<p>Set a value that can later be accessed with get(). If name already exists in the database, the old value will be overwritten.</p>
<p>Remove a PSK from the database</p>
<p>Returns if the values in the PSK database are encrypted. If false, saved values are being stored in plaintext.</p>
<p>Get a PSK in the form of a string (eg if the PSK is a password)</p>
<p>Return the set of names for which get() will return a value.</p>
<p>Return the value associated with the specified</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>or otherwise throw an exception.</td></tr>
  </table>
  </dd>
</dl>
<p>Set a value that can later be accessed with get(). If name already exists in the database, the old value will be overwritten.</p>
<p>Remove a PSK from the database</p>
<p>Returns if the values in the PSK database are encrypted. If false, saved values are being stored in plaintext.</p>
<p>Get a PSK in the form of a string (eg if the PSK is a password)</p>

<p class="definition">Definition at line <a class="el" href="asn1__print_8h_source.html#l00022">22</a> of file <a class="el" href="asn1__print_8h_source.html">asn1_print.h</a>.</p>

</div>
</div>
<a id="a1ad149e905ab31f7795dbf2ca0c4b336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad149e905ab31f7795dbf2ca0c4b336">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BigInt Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">7&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a prime suitable for RSA p/q </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keygen_rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">prime_test_rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">bits</td><td>how large the resulting prime should be in bits (must be &gt;= 512) </td></tr>
    <tr><td class="paramname">coprime</td><td>a positive integer that (prime - 1) should be coprime to </td></tr>
    <tr><td class="paramname">prob</td><td>use test so false positive is bounded by 1/2**prob </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random prime with the specified criteria </dd></dl>

</div>
</div>
<a id="a33bceeeb9c924b9a9600daa1fe19b073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33bceeeb9c924b9a9600daa1fe19b073">&#9670;&nbsp;</a></span>BOTAN_PUBLIC_API() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Botan::BOTAN_PUBLIC_API </td>
          <td>(</td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">8&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_test.html">Test</a> if the positive integer x is a perfect square ie if there exists some positive integer y st y*y == x See FIPS 186-4 sec C.4 </p><dl class="section return"><dt>Returns</dt><dd>0 if the integer is not a perfect square, otherwise returns the positive y st y*y == x</dd></dl>
<p>Perform PBKDF2. The prf is assumed to be keyed already. </p>

</div>
</div>
<a id="a5ec087b9959d7ffcbc195dcedbf10513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec087b9959d7ffcbc195dcedbf10513">&#9670;&nbsp;</a></span>bswap_4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::bswap_4 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap 4 Ts in an array </p>

<p class="definition">Definition at line <a class="el" href="bswap_8h_source.html#l00089">89</a> of file <a class="el" href="bswap_8h_source.html">bswap.h</a>.</p>

</div>
</div>
<a id="a0e7eef69e50c79362b967f2c4f81a377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7eef69e50c79362b967f2c4f81a377">&#9670;&nbsp;</a></span>choose_sig_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PK_Signer * Botan::choose_sig_format </td>
          <td>(</td>
          <td class="paramtype">const Private_Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomNumberGenerator &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hash_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AlgorithmIdentifier &amp;&#160;</td>
          <td class="paramname"><em>alg_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">* Choose the default signature format for a certain public key signature
* scheme.
*
* The only option recognized by opts at this moment is "padding"
* Find an entry from src/build-data/oids.txt under [signature] of the form
* &lt;sig_algo&gt;/&lt;padding&gt;[(&lt;hash_algo&gt;)] and add {"padding",&lt;padding&gt;}
* to opts.
* </pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>will be the key to choose a padding scheme for </td></tr>
    <tr><td class="paramname">opts</td><td>contains additional options for building the certificate </td></tr>
    <tr><td class="paramname">rng</td><td>the random generator to use </td></tr>
    <tr><td class="paramname">hash_fn</td><td>is the desired hash function </td></tr>
    <tr><td class="paramname">alg_id</td><td>will be set to the chosen scheme </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A PK_Signer object for generating signatures </dd></dl>

<p class="definition">Definition at line <a class="el" href="x509__ca_8cpp_source.html#l00326">326</a> of file <a class="el" href="x509__ca_8cpp_source.html">x509_ca.cpp</a>.</p>

</div>
</div>
<a id="a9c7c302096cd87d7a8a12d6038260206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7c302096cd87d7a8a12d6038260206">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::clamp </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clamp </p>

<p class="definition">Definition at line <a class="el" href="rounding_8h_source.html#l00045">45</a> of file <a class="el" href="rounding_8h_source.html">rounding.h</a>.</p>

</div>
</div>
<a id="a7ce0c066e1e47c17c9ed2d4c5ae35b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce0c066e1e47c17c9ed2d4c5ae35b34">&#9670;&nbsp;</a></span>clear_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::clear_bytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Zero out some bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to memory to zero </td></tr>
    <tr><td class="paramname">bytes</td><td>the number of bytes to zero in ptr </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mem__ops_8h_source.html#l00079">79</a> of file <a class="el" href="mem__ops_8h_source.html">mem_ops.h</a>.</p>

</div>
</div>
<a id="aeb6cf2051aa89f9d76cf4d55c126b314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6cf2051aa89f9d76cf4d55c126b314">&#9670;&nbsp;</a></span>clear_mem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::clear_mem </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Zero memory before use. This simply calls memset and should not be used in cases where the compiler cannot see the call as a side-effecting operation (for example, if calling clear_mem before deallocating memory, the compiler would be allowed to omit the call to memset entirely under the as-if rule.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to an array of Ts to zero </td></tr>
    <tr><td class="paramname">n</td><td>the number of Ts pointed to by ptr </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mem__ops_8h_source.html#l00097">97</a> of file <a class="el" href="mem__ops_8h_source.html">mem_ops.h</a>.</p>

</div>
</div>
<a id="a81dcdaaa3ce9b5c1025d32be2594b2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dcdaaa3ce9b5c1025d32be2594b2de">&#9670;&nbsp;</a></span>copy_mem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::copy_mem </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the destination array </td></tr>
    <tr><td class="paramname">in</td><td>the source array </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements of in/out </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mem__ops_8h_source.html#l00108">108</a> of file <a class="el" href="mem__ops_8h_source.html">mem_ops.h</a>.</p>

</div>
</div>
<a id="a4045abfe1da803ec251fcfd4d04b0c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4045abfe1da803ec251fcfd4d04b0c10">&#9670;&nbsp;</a></span>ctz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::ctz </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the trailing zero bits in n </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum x st 2^x divides n </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit__ops_8h_source.html#l00097">97</a> of file <a class="el" href="bit__ops_8h_source.html">bit_ops.h</a>.</p>

</div>
</div>
<a id="a27c25f0333e84e5540be288b4298b766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c25f0333e84e5540be288b4298b766">&#9670;&nbsp;</a></span>erase_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Botan::erase_chars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a SCAN-style algorithm name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan_name</td><td>the name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name components Split a string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the input string </td></tr>
    <tr><td class="paramname">delim</td><td>the delimitor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string split by delim Split a string on a character predicate </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the input string </td></tr>
    <tr><td class="paramname">pred</td><td>the predicate</td></tr>
  </table>
  </dd>
</dl>
<p>This function will likely be removed in a future release Erase characters from a string </p>

<p class="definition">Definition at line <a class="el" href="parsing_8cpp_source.html#l00308">308</a> of file <a class="el" href="parsing_8cpp_source.html">parsing.cpp</a>.</p>

</div>
</div>
<a id="a2a0b6b61c8483eb1efca4564bb144828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0b6b61c8483eb1efca4564bb144828">&#9670;&nbsp;</a></span>expand_mask_16bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Botan::expand_mask_16bit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand an input to a bit mask depending on it being being zero or non-zero </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tst</td><td>the input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mask 0xFFFF if tst is non-zero and 0 otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="code__based__util_8h_source.html#l00025">25</a> of file <a class="el" href="code__based__util_8h_source.html">code_based_util.h</a>.</p>

</div>
</div>
<a id="a664573e9a1043c872e3d0c03d4d9f2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664573e9a1043c872e3d0c03d4d9f2ec">&#9670;&nbsp;</a></span>find_roots_gf2m_decomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">secure_vector&lt; gf2m &gt; Botan::find_roots_gf2m_decomp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_botan_1_1polyn__gf2m.html">polyn_gf2m</a> &amp;&#160;</td>
          <td class="paramname"><em>polyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>code_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the roots of a polynomial over GF(2^m) using the method by Federenko et al. </p>

<p class="definition">Definition at line <a class="el" href="gf2m__rootfind__dcmp_8cpp_source.html#l00311">311</a> of file <a class="el" href="gf2m__rootfind__dcmp_8cpp_source.html">gf2m_rootfind_dcmp.cpp</a>.</p>

</div>
</div>
<a id="a22646ab3e050b0bf8f3ec55184c467c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22646ab3e050b0bf8f3ec55184c467c6">&#9670;&nbsp;</a></span>get_aead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a> (2,0) AEAD_Mode AEAD_Mode* Botan::get_aead </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interface for AEAD (Authenticated Encryption with Associated Data) modes. These modes provide both encryption and message authentication, and can authenticate additional per-message data which is not included in the ciphertext (for instance a sequence number). Get an AEAD mode by name (eg "AES-128/GCM" or "Serpent/EAX") </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>AEAD name </td></tr>
    <tr><td class="paramname">direction</td><td>ENCRYPTION or DECRYPTION </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="aead_8h_source.html#l00114">114</a> of file <a class="el" href="aead_8h_source.html">aead.h</a>.</p>

</div>
</div>
<a id="ac22e1d5609dbde74a5f45f729f4c4c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22e1d5609dbde74a5f45f729f4c4c6a">&#9670;&nbsp;</a></span>get_bc_pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BlockCipherModePaddingMethod* Botan::get_bc_pad </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>algo_spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a block cipher padding method by name </p>

<p class="definition">Definition at line <a class="el" href="mode__pad_8cpp_source.html#l00018">18</a> of file <a class="el" href="mode__pad_8cpp_source.html">mode_pad.cpp</a>.</p>

</div>
</div>
<a id="ad10dc938a651323dddbfe3c1e985774b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10dc938a651323dddbfe3c1e985774b">&#9670;&nbsp;</a></span>get_byte()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t Botan::get_byte </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Byte extraction </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_num</td><td>which byte to extract, 0 == highest byte </td></tr>
    <tr><td class="paramname">input</td><td>the value to extract from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>byte byte_num of input </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00039">39</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a9074784e382345388cdeb6db3e69c823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9074784e382345388cdeb6db3e69c823">&#9670;&nbsp;</a></span>get_cipher_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a> (2,0) Cipher_Mode Cipher_Mode* Botan::get_cipher_mode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>algo_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_botan.html#a8d9547a8fb3e868810b169b20ac389ee">Cipher_Dir</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>provider</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Interface for cipher modes Get a cipher mode by name (eg "AES-128/CBC" or "Serpent/XTS") </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>cipher name </td></tr>
    <tr><td class="paramname">direction</td><td>ENCRYPTION or DECRYPTION </td></tr>
    <tr><td class="paramname">provider</td><td>provider implementation to choose </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="cipher__mode_8h_source.html#l00189">189</a> of file <a class="el" href="cipher__mode_8h_source.html">cipher_mode.h</a>.</p>

</div>
</div>
<a id="a053bdfc377dda32b5d3c116e19c9d394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053bdfc377dda32b5d3c116e19c9d394">&#9670;&nbsp;</a></span>get_pbkdf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PBKDF* Botan::get_pbkdf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>algo_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>provider</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Password based key derivation function factory method </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo_spec</td><td>the name of the desired PBKDF algorithm </td></tr>
    <tr><td class="paramname">provider</td><td>the provider to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to newly allocated object of that type </dd></dl>

<p class="definition">Definition at line <a class="el" href="pbkdf_8h_source.html#l00232">232</a> of file <a class="el" href="pbkdf_8h_source.html">pbkdf.h</a>.</p>

</div>
</div>
<a id="a68b05d4e236673d9d185cbfb1144cebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b05d4e236673d9d185cbfb1144cebc">&#9670;&nbsp;</a></span>get_sig_paddings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOTAN_TEST_API const std::vector&lt; std::string &gt; Botan::get_sig_paddings </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>algo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the allowed padding schemes when using the given algorithm (key type) for creating digital signatures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo</td><td>the algorithm for which to look up supported padding schemes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of supported padding schemes </dd></dl>

<p class="definition">Definition at line <a class="el" href="padding_8cpp_source.html#l00030">30</a> of file <a class="el" href="padding_8cpp_source.html">padding.cpp</a>.</p>

</div>
</div>
<a id="abb6896c37db627e3ab8e1fa7c72f79fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6896c37db627e3ab8e1fa7c72f79fd">&#9670;&nbsp;</a></span>hamming_weight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::hamming_weight </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute Hamming weights </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bits in n set to 1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit__ops_8h_source.html#l00080">80</a> of file <a class="el" href="bit__ops_8h_source.html">bit_ops.h</a>.</p>

</div>
</div>
<a id="acc6c58c9b9ef1e9aa417eb2e71371828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6c58c9b9ef1e9aa417eb2e71371828">&#9670;&nbsp;</a></span>has_filesystem_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Botan::has_filesystem_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No_Filesystem_Access Exception </p>

<p class="definition">Definition at line <a class="el" href="filesystem_8cpp_source.html#l00167">167</a> of file <a class="el" href="filesystem_8cpp_source.html">filesystem.cpp</a>.</p>

</div>
</div>
<a id="a02a63d270351924b382780ee6d5b80c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a63d270351924b382780ee6d5b80c3">&#9670;&nbsp;</a></span>hex_encode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Botan::hex_encode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uppercase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform hex encoding </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>some input </td></tr>
    <tr><td class="paramname">uppercase</td><td>should output be upper or lower case? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hexadecimal representation of input </dd></dl>

<p class="definition">Definition at line <a class="el" href="hex_8h_source.html#l00046">46</a> of file <a class="el" href="hex_8h_source.html">hex.h</a>.</p>

</div>
</div>
<a id="ad6c09360d3936ba7077b2d8b14d6cbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c09360d3936ba7077b2d8b14d6cbaa">&#9670;&nbsp;</a></span>high_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::high_bit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index of the highest set bit T is an unsigned integer type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the highest set bit in n </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit__ops_8h_source.html#l00037">37</a> of file <a class="el" href="bit__ops_8h_source.html">bit_ops.h</a>.</p>

</div>
</div>
<a id="a5c191055a4f5a2dba6bfde0e8056eaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c191055a4f5a2dba6bfde0e8056eaab">&#9670;&nbsp;</a></span>initialize_allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::initialize_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure the allocator is initialized </p>

<p class="definition">Definition at line <a class="el" href="mem__ops_8cpp_source.html#l00044">44</a> of file <a class="el" href="mem__ops_8cpp_source.html">mem_ops.cpp</a>.</p>

</div>
</div>
<a id="aa000b3df41820d97dbeef2594dd82843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa000b3df41820d97dbeef2594dd82843">&#9670;&nbsp;</a></span>is_bailie_psw_probable_prime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BOTAN_TEST_API Botan::is_bailie_psw_probable_prime </td>
          <td>(</td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Modular_Reducer &amp;&#160;</td>
          <td class="paramname"><em>mod_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform Bailie-PSW primality test</p>
<p>This is a combination of Miller-Rabin with base 2 and a Lucas test. No known composite integer passes both tests, though it is conjectured that infinitely many composite counterexamples exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the positive integer to test </td></tr>
    <tr><td class="paramname">mod_n</td><td>a pre-created Modular_Reducer for n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n seems probably prime, false if n is composite </dd></dl>

<p class="definition">Definition at line <a class="el" href="primality_8cpp_source.html#l00095">95</a> of file <a class="el" href="primality_8cpp_source.html">primality.cpp</a>.</p>

</div>
</div>
<a id="a3972bbdb57116e08e72c3559d8db5bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3972bbdb57116e08e72c3559d8db5bf2">&#9670;&nbsp;</a></span>is_bailie_psw_probable_prime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Botan::is_bailie_psw_probable_prime </td>
          <td>(</td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform Bailie-PSW primality test</p>
<p>This is a combination of Miller-Rabin with base 2 and a Lucas test. No known composite integer passes both tests, though it is conjectured that infinitely many composite counterexamples exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the positive integer to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n seems probably prime, false if n is composite </dd></dl>

<p class="definition">Definition at line <a class="el" href="primality_8cpp_source.html#l00101">101</a> of file <a class="el" href="primality_8cpp_source.html">primality.cpp</a>.</p>

</div>
</div>
<a id="adfa47db9abf09a2846078163792d949c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa47db9abf09a2846078163792d949c">&#9670;&nbsp;</a></span>is_lucas_probable_prime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BOTAN_TEST_API Botan::is_lucas_probable_prime </td>
          <td>(</td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Modular_Reducer &amp;&#160;</td>
          <td class="paramname"><em>mod_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform Lucas primality test </p><dl class="section see"><dt>See also</dt><dd>FIPS 186-4 C.3.3</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it is possible to construct composite integers which pass this test alone.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the positive integer to test </td></tr>
    <tr><td class="paramname">mod_n</td><td>a pre-created Modular_Reducer for n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if n seems probably prime, false if n is composite </dd></dl>

<p class="definition">Definition at line <a class="el" href="primality_8cpp_source.html#l00017">17</a> of file <a class="el" href="primality_8cpp_source.html">primality.cpp</a>.</p>

</div>
</div>
<a id="a83e0f4d2a60382f64d3bc66e5643d1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e0f4d2a60382f64d3bc66e5643d1b3">&#9670;&nbsp;</a></span>is_miller_rabin_probable_prime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BOTAN_TEST_API Botan::is_miller_rabin_probable_prime </td>
          <td>(</td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Modular_Reducer &amp;&#160;</td>
          <td class="paramname"><em>mod_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomNumberGenerator &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform t iterations of a Miller-Rabin primality test with random bases</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the positive integer to test </td></tr>
    <tr><td class="paramname">mod_n</td><td>a pre-created Modular_Reducer for n </td></tr>
    <tr><td class="paramname">rng</td><td>a random number generator </td></tr>
    <tr><td class="paramname">t</td><td>number of tests to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of primality test </dd></dl>

<p class="definition">Definition at line <a class="el" href="primality_8cpp_source.html#l00146">146</a> of file <a class="el" href="primality_8cpp_source.html">primality.cpp</a>.</p>

</div>
</div>
<a id="aeab1f8b408a2ea772778740017bddcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab1f8b408a2ea772778740017bddcd5">&#9670;&nbsp;</a></span>is_power_of_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Botan::is_power_of_2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Power of 2 test. T should be an unsigned integer type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>an integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff arg is 2^n for some n &gt; 0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit__ops_8h_source.html#l00025">25</a> of file <a class="el" href="bit__ops_8h_source.html">bit_ops.h</a>.</p>

</div>
</div>
<a id="a640029f085cc0a904b32e20f42303dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640029f085cc0a904b32e20f42303dd2">&#9670;&nbsp;</a></span>load_be() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Botan::load_be </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a big-endian word </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th T of in, as a big-endian value </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00105">105</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a5773c133cf22abd1269664b59c16244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5773c133cf22abd1269664b59c16244a">&#9670;&nbsp;</a></span>load_be() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::load_be </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load two big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00345">345</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a0b0c4a782d518167985566686e4d1a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0c4a782d518167985566686e4d1a95">&#9670;&nbsp;</a></span>load_be() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::load_be </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load four big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
    <tr><td class="paramname">x2</td><td>where the third word will be written </td></tr>
    <tr><td class="paramname">x3</td><td>where the fourth word will be written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00360">360</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a996923074c3867c0f2ce1d1b96b8fd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996923074c3867c0f2ce1d1b96b8fd4b">&#9670;&nbsp;</a></span>load_be() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::load_be </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load eight big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
    <tr><td class="paramname">x2</td><td>where the third word will be written </td></tr>
    <tr><td class="paramname">x3</td><td>where the fourth word will be written </td></tr>
    <tr><td class="paramname">x4</td><td>where the fifth word will be written </td></tr>
    <tr><td class="paramname">x5</td><td>where the sixth word will be written </td></tr>
    <tr><td class="paramname">x6</td><td>where the seventh word will be written </td></tr>
    <tr><td class="paramname">x7</td><td>where the eighth word will be written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00382">382</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a0b13c515a5a6599c5074fd9471192b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b13c515a5a6599c5074fd9471192b69">&#9670;&nbsp;</a></span>load_be() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::load_be </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a variable number of big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output array of words </td></tr>
    <tr><td class="paramname">in</td><td>the input array of bytes </td></tr>
    <tr><td class="paramname">count</td><td>how many words are in in </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00403">403</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="ab6bab280ff3476b4539a9c2946c690f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bab280ff3476b4539a9c2946c690f1">&#9670;&nbsp;</a></span>load_be&lt; uint16_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="namespace_botan.html#a640029f085cc0a904b32e20f42303dd2">Botan::load_be</a>&lt; uint16_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a big-endian uint16_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint16_t of in, as a big-endian value </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00137">137</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a859a883d8cb8ec54d5c8d62969260bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859a883d8cb8ec54d5c8d62969260bd8">&#9670;&nbsp;</a></span>load_be&lt; uint32_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="namespace_botan.html#a640029f085cc0a904b32e20f42303dd2">Botan::load_be</a>&lt; uint32_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a big-endian uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint32_t of in, as a big-endian value </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00177">177</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a96d5556307d65f0974740f8c3fc33639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d5556307d65f0974740f8c3fc33639">&#9670;&nbsp;</a></span>load_be&lt; uint64_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="namespace_botan.html#a640029f085cc0a904b32e20f42303dd2">Botan::load_be</a>&lt; uint64_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a big-endian uint64_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint64_t of in, as a big-endian value </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00215">215</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a745efa1d08234fe3b785f17c19ec26b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745efa1d08234fe3b785f17c19ec26b7">&#9670;&nbsp;</a></span>load_le() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Botan::load_le </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a little-endian word </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th T of in, as a litte-endian value </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00121">121</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="abb60b6e5af3132bc5095cfcbaa90fc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb60b6e5af3132bc5095cfcbaa90fc35">&#9670;&nbsp;</a></span>load_le() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::load_le </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load two little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00255">255</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a03b8aebd623614ee2d8804bb82b96928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b8aebd623614ee2d8804bb82b96928">&#9670;&nbsp;</a></span>load_le() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::load_le </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load four little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
    <tr><td class="paramname">x2</td><td>where the third word will be written </td></tr>
    <tr><td class="paramname">x3</td><td>where the fourth word will be written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00270">270</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a170a82161413e005b53c3db27d79678e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170a82161413e005b53c3db27d79678e">&#9670;&nbsp;</a></span>load_le() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::load_le </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load eight little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
    <tr><td class="paramname">x2</td><td>where the third word will be written </td></tr>
    <tr><td class="paramname">x3</td><td>where the fourth word will be written </td></tr>
    <tr><td class="paramname">x4</td><td>where the fifth word will be written </td></tr>
    <tr><td class="paramname">x5</td><td>where the sixth word will be written </td></tr>
    <tr><td class="paramname">x6</td><td>where the seventh word will be written </td></tr>
    <tr><td class="paramname">x7</td><td>where the eighth word will be written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00292">292</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a42d83d9e349598b56af765a1acb441bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d83d9e349598b56af765a1acb441bc">&#9670;&nbsp;</a></span>load_le() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::load_le </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a variable number of little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output array of words </td></tr>
    <tr><td class="paramname">in</td><td>the input array of bytes </td></tr>
    <tr><td class="paramname">count</td><td>how many words are in in </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00313">313</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="aeb5c38bea458b6183ef69afd5ec0cc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5c38bea458b6183ef69afd5ec0cc42">&#9670;&nbsp;</a></span>load_le&lt; uint16_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="namespace_botan.html#a745efa1d08234fe3b785f17c19ec26b7">Botan::load_le</a>&lt; uint16_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a little-endian uint16_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint16_t of in, as a little-endian value </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00157">157</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a2d9442a9a8c4177d35388d0c82f7f2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9442a9a8c4177d35388d0c82f7f2e0">&#9670;&nbsp;</a></span>load_le&lt; uint32_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="namespace_botan.html#a745efa1d08234fe3b785f17c19ec26b7">Botan::load_le</a>&lt; uint32_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a little-endian uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint32_t of in, as a little-endian value </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00196">196</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="af8e343d945901fa17325279d27a14e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e343d945901fa17325279d27a14e39">&#9670;&nbsp;</a></span>load_le&lt; uint64_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="namespace_botan.html#a745efa1d08234fe3b785f17c19ec26b7">Botan::load_le</a>&lt; uint64_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a little-endian uint64_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint64_t of in, as a little-endian value </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00235">235</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="aae0c04508a1e70c5d4ecf363e8b75f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0c04508a1e70c5d4ecf363e8b75f00">&#9670;&nbsp;</a></span>low_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::low_bit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index of the lowest set bit T is an unsigned integer type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the lowest set bit in n </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit__ops_8h_source.html#l00052">52</a> of file <a class="el" href="bit__ops_8h_source.html">bit_ops.h</a>.</p>

</div>
</div>
<a id="afa1f23105ed52b51390e214db16b6900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1f23105ed52b51390e214db16b6900">&#9670;&nbsp;</a></span>make_uint16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint16_t Botan::make_uint16 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a uint16_t from two bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>the first byte </td></tr>
    <tr><td class="paramname">i1</td><td>the second byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>i0 || i1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00052">52</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a690f1a5eaa98c00b71ef8320322e722e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690f1a5eaa98c00b71ef8320322e722e">&#9670;&nbsp;</a></span>make_uint32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t Botan::make_uint32 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a uint32_t from four bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>the first byte </td></tr>
    <tr><td class="paramname">i1</td><td>the second byte </td></tr>
    <tr><td class="paramname">i2</td><td>the third byte </td></tr>
    <tr><td class="paramname">i3</td><td>the fourth byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>i0 || i1 || i2 || i3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00065">65</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a267c278fd265a2fc255df8b8de93dde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267c278fd265a2fc255df8b8de93dde2">&#9670;&nbsp;</a></span>make_uint64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t Botan::make_uint64 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a uint32_t from eight bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i0</td><td>the first byte </td></tr>
    <tr><td class="paramname">i1</td><td>the second byte </td></tr>
    <tr><td class="paramname">i2</td><td>the third byte </td></tr>
    <tr><td class="paramname">i3</td><td>the fourth byte </td></tr>
    <tr><td class="paramname">i4</td><td>the fifth byte </td></tr>
    <tr><td class="paramname">i5</td><td>the sixth byte </td></tr>
    <tr><td class="paramname">i6</td><td>the seventh byte </td></tr>
    <tr><td class="paramname">i7</td><td>the eighth byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>i0 || i1 || i2 || i3 || i4 || i5 || i6 || i7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00085">85</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a967fe441532a76e590a656bb8b9f177a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967fe441532a76e590a656bb8b9f177a">&#9670;&nbsp;</a></span>map_keys_as_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;K&gt; Botan::map_keys_as_set </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>kv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the keys of a map as a std::set </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00034">34</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="ac84dac7bdfb3e9c9ecb19a2e55596ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84dac7bdfb3e9c9ecb19a2e55596ded">&#9670;&nbsp;</a></span>mceliece_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">secure_vector&lt; uint8_t &gt; Botan::mceliece_decrypt </td>
          <td>(</td>
          <td class="paramtype">secure_vector&lt; gf2m &gt; &amp;&#160;</td>
          <td class="paramname"><em>error_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ciphertext_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const McEliece_PrivateKey &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>p_err_pos_len</code> must point to the available length of <code>error_pos</code> on input, the function will set it to the actual number of errors returned in the <code>error_pos</code> array </p>

<p class="definition">Definition at line <a class="el" href="goppa__code_8cpp_source.html#l00164">164</a> of file <a class="el" href="goppa__code_8cpp_source.html">goppa_code.cpp</a>.</p>

</div>
</div>
<a id="ad2d5621df44479136319b391ff899802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d5621df44479136319b391ff899802">&#9670;&nbsp;</a></span>miller_rabin_test_iterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::miller_rabin_test_iterations </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>random</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return required number of Miller-Rabin tests in order to reach the specified probability of error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_bits</td><td>the bit-length of the integer being tested </td></tr>
    <tr><td class="paramname">prob</td><td>chance of false positive is bounded by 1/2**prob </td></tr>
    <tr><td class="paramname">random</td><td>is set if (and only if) the integer was randomly generated by us and thus cannot have been maliciously constructed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="primality_8cpp_source.html#l00168">168</a> of file <a class="el" href="primality_8cpp_source.html">primality.cpp</a>.</p>

</div>
</div>
<a id="a569119add8b600e92227182777726fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569119add8b600e92227182777726fb1">&#9670;&nbsp;</a></span>monty_multi_exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BigInt Botan::monty_multi_exp </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="class_botan_1_1_montgomery___params.html">Montgomery_Params</a> &gt;&#160;</td>
          <td class="paramname"><em>params_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return (x^z1 * y^z2) % p </p>

<p class="definition">Definition at line <a class="el" href="monty__exp_8cpp_source.html#l00171">171</a> of file <a class="el" href="monty__exp_8cpp_source.html">monty_exp.cpp</a>.</p>

</div>
</div>
<a id="ad0da4682632518b5b7b11848dc3025e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0da4682632518b5b7b11848dc3025e3">&#9670;&nbsp;</a></span>mul64x64_128()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::mul64x64_128 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a 64x64-&gt;128 bit multiplication </p>

<p class="definition">Definition at line <a class="el" href="mul128_8h_source.html#l00083">83</a> of file <a class="el" href="mul128_8h_source.html">mul128.h</a>.</p>

</div>
</div>
<a id="a3778103665c2cb22e4f311002755cd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3778103665c2cb22e4f311002755cd53">&#9670;&nbsp;</a></span>oaep_find_delim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">secure_vector&lt;uint8_t&gt; Botan::oaep_find_delim </td>
          <td>(</td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>valid_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>input_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const secure_vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Phash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OAEP (called EME1 in IEEE 1363 and in earlier versions of the library) as specified in PKCS#1 v2.0 (RFC 2437) </p>

<p class="definition">Definition at line <a class="el" href="lib_2pk__pad_2eme__oaep_2oaep_8cpp_source.html#l00093">93</a> of file <a class="el" href="lib_2pk__pad_2eme__oaep_2oaep_8cpp_source.html">oaep.cpp</a>.</p>

</div>
</div>
<a id="a253008bbfcdaedb01ffa8cc88fd1b168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253008bbfcdaedb01ffa8cc88fd1b168">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Botan::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GeneralName &amp;&#160;</td>
          <td class="paramname"><em>gn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>X.509 GeneralName Type. </p>
<p>Handles parsing GeneralName types in their BER and canonical string encoding. Allows matching GeneralNames against each other using the rules laid out in the RFC 5280, sec. 4.2.1.10 (Name Contraints). </p>

<p class="definition">Definition at line <a class="el" href="name__constraint_8cpp_source.html#l00221">221</a> of file <a class="el" href="name__constraint_8cpp_source.html">name_constraint.cpp</a>.</p>

</div>
</div>
<a id="a4139683b6cc649ac5a8b6da64dcd60c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4139683b6cc649ac5a8b6da64dcd60c8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Botan::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GeneralSubtree &amp;&#160;</td>
          <td class="paramname"><em>gs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A single Name Constraint. </p>
<p>The Name Constraint extension adds a minimum and maximum path length to a GeneralName to form a constraint. The length limits are currently unused. </p>

<p class="definition">Definition at line <a class="el" href="name__constraint_8cpp_source.html#l00264">264</a> of file <a class="el" href="name__constraint_8cpp_source.html">name_constraint.cpp</a>.</p>

</div>
</div>
<a id="aa477faffd5421eda38e1760113cd52a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa477faffd5421eda38e1760113cd52a5">&#9670;&nbsp;</a></span>OS2ECP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; BigInt, BigInt &gt; BOTAN_UNSTABLE_API Botan::OS2ECP </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>curve_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>curve_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>curve_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform point decoding Use EC_Group::OS2ECP instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the encoded point </td></tr>
    <tr><td class="paramname">data_len</td><td>length of data in bytes </td></tr>
    <tr><td class="paramname">curve_p</td><td>the curve equation prime </td></tr>
    <tr><td class="paramname">curve_a</td><td>the curve equation a parameter </td></tr>
    <tr><td class="paramname">curve_b</td><td>the curve equation b parameter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="point__gfp_8cpp_source.html#l00680">680</a> of file <a class="el" href="point__gfp_8cpp_source.html">point_gfp.cpp</a>.</p>

</div>
</div>
<a id="a72fa2ef88c6068dab54c14e9b5571b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fa2ef88c6068dab54c14e9b5571b51">&#9670;&nbsp;</a></span>passes_miller_rabin_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Botan::passes_miller_rabin_test </td>
          <td>(</td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Modular_Reducer &amp;&#160;</td>
          <td class="paramname"><em>mod_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_botan_1_1_montgomery___params.html">Montgomery_Params</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>monty_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigInt &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a single Miller-Rabin test with specified base</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the positive integer to test </td></tr>
    <tr><td class="paramname">mod_n</td><td>a pre-created Modular_Reducer for n </td></tr>
    <tr><td class="paramname">monty_n</td><td>Montgomery parameters for n </td></tr>
    <tr><td class="paramname">a</td><td>the base to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of primality test </dd></dl>

<p class="definition">Definition at line <a class="el" href="primality_8cpp_source.html#l00107">107</a> of file <a class="el" href="primality_8cpp_source.html">primality.cpp</a>.</p>

</div>
</div>
<a id="ae10f56ac44d39dac92ae756ff4c26510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10f56ac44d39dac92ae756ff4c26510">&#9670;&nbsp;</a></span>poly_double_supported_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Botan::poly_double_supported_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true iff poly_double_n is implemented for this size. </p>

<p class="definition">Definition at line <a class="el" href="poly__dbl_8h_source.html#l00022">22</a> of file <a class="el" href="poly__dbl_8h_source.html">poly_dbl.h</a>.</p>

</div>
</div>
<a id="ac80126ae204756cd304ffeab9085c6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80126ae204756cd304ffeab9085c6f4">&#9670;&nbsp;</a></span>probe_provider_private_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Botan::probe_provider_private_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>algo_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>possible</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new key For ECC keys, algo_params specifies EC group (eg, "secp256r1") For DH/DSA/ElGamal keys, algo_params is DL group (eg, "modp/ietf/2048") For RSA, algo_params is integer keylength For McEliece, algo_params is n,t If algo_params is left empty, suitable default parameters are chosen. </p>

<p class="definition">Definition at line <a class="el" href="pk__algs_8cpp_source.html#l00408">408</a> of file <a class="el" href="pk__algs_8cpp_source.html">pk_algs.cpp</a>.</p>

</div>
</div>
<a id="a292061a5124df501cb59c2f899f78235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292061a5124df501cb59c2f899f78235">&#9670;&nbsp;</a></span>replace_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Botan::replace_char </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>from_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>to_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a character in a string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the input string </td></tr>
    <tr><td class="paramname">from_char</td><td>the character to replace </td></tr>
    <tr><td class="paramname">to_char</td><td>the character to replace it with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>str with all instances of from_char replaced by to_char </dd></dl>

<p class="definition">Definition at line <a class="el" href="parsing_8cpp_source.html#l00332">332</a> of file <a class="el" href="parsing_8cpp_source.html">parsing.cpp</a>.</p>

</div>
</div>
<a id="a64033c1b7127eae1491a8eadd11d1ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64033c1b7127eae1491a8eadd11d1ecb">&#9670;&nbsp;</a></span>replace_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Botan::replace_chars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>to_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a character in a string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the input string </td></tr>
    <tr><td class="paramname">from_chars</td><td>the characters to replace </td></tr>
    <tr><td class="paramname">to_char</td><td>the character to replace it with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>str with all instances of from_chars replaced by to_char </dd></dl>

<p class="definition">Definition at line <a class="el" href="parsing_8cpp_source.html#l00319">319</a> of file <a class="el" href="parsing_8cpp_source.html">parsing.cpp</a>.</p>

</div>
</div>
<a id="a124bfd8e6621e1ad0d19d902ce10f149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124bfd8e6621e1ad0d19d902ce10f149">&#9670;&nbsp;</a></span>reverse_bytes() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Botan::reverse_bytes </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap a 16 bit integer </p>

<p class="definition">Definition at line <a class="el" href="bswap_8h_source.html#l00024">24</a> of file <a class="el" href="bswap_8h_source.html">bswap.h</a>.</p>

</div>
</div>
<a id="a5c0e57eb245139c321b18d1d242c9e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0e57eb245139c321b18d1d242c9e9f">&#9670;&nbsp;</a></span>reverse_bytes() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Botan::reverse_bytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap a 32 bit integer </p>

<p class="definition">Definition at line <a class="el" href="bswap_8h_source.html#l00032">32</a> of file <a class="el" href="bswap_8h_source.html">bswap.h</a>.</p>

</div>
</div>
<a id="ae04de07006f5cfa825328813ea7d3985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04de07006f5cfa825328813ea7d3985">&#9670;&nbsp;</a></span>reverse_bytes() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Botan::reverse_bytes </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap a 64 bit integer </p>

<p class="definition">Definition at line <a class="el" href="bswap_8h_source.html#l00057">57</a> of file <a class="el" href="bswap_8h_source.html">bswap.h</a>.</p>

</div>
</div>
<a id="aebdcf273bc754092e425287b1cf05208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdcf273bc754092e425287b1cf05208">&#9670;&nbsp;</a></span>RFC4880_round_iterations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::RFC4880_round_iterations </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Round an arbitrary iteration count to next largest iteration count supported by RFC4880 encoding. </p>

<p class="definition">Definition at line <a class="el" href="pgp__s2k_8h_source.html#l00032">32</a> of file <a class="el" href="pgp__s2k_8h_source.html">pgp_s2k.h</a>.</p>

</div>
</div>
<a id="a08a31a219cbddcbfcb2f6fc770fcaed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a31a219cbddcbfcb2f6fc770fcaed4">&#9670;&nbsp;</a></span>rotl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ROT, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T Botan::rotl </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bit rotation left by a compile-time constant amount </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input word </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input rotated left by ROT bits </dd></dl>

<p class="definition">Definition at line <a class="el" href="rotate_8h_source.html#l00021">21</a> of file <a class="el" href="rotate_8h_source.html">rotate.h</a>.</p>

</div>
</div>
<a id="a2e3ac5eb5fe20890242666142e72a8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3ac5eb5fe20890242666142e72a8f6">&#9670;&nbsp;</a></span>rotl_var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Botan::rotl_var </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bit rotation left, variable rotation amount </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input word </td></tr>
    <tr><td class="paramname">rot</td><td>the number of bits to rotate, must be between 0 and sizeof(T)*8-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input rotated left by rot bits </dd></dl>

<p class="definition">Definition at line <a class="el" href="rotate_8h_source.html#l00046">46</a> of file <a class="el" href="rotate_8h_source.html">rotate.h</a>.</p>

</div>
</div>
<a id="ada30f39e9838317878d9da1e095bdfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada30f39e9838317878d9da1e095bdfe8">&#9670;&nbsp;</a></span>rotr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ROT, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T Botan::rotr </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bit rotation right by a compile-time constant amount </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input word </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input rotated right by ROT bits </dd></dl>

<p class="definition">Definition at line <a class="el" href="rotate_8h_source.html#l00033">33</a> of file <a class="el" href="rotate_8h_source.html">rotate.h</a>.</p>

</div>
</div>
<a id="ae58d929c7e8f311bc908091212d969dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58d929c7e8f311bc908091212d969dd">&#9670;&nbsp;</a></span>rotr_var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Botan::rotr_var </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bit rotation right, variable rotation amount </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input word </td></tr>
    <tr><td class="paramname">rot</td><td>the number of bits to rotate, must be between 0 and sizeof(T)*8-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input rotated right by rot bits </dd></dl>

<p class="definition">Definition at line <a class="el" href="rotate_8h_source.html#l00058">58</a> of file <a class="el" href="rotate_8h_source.html">rotate.h</a>.</p>

</div>
</div>
<a id="a4595be1d36c60aea04cc4fad870956a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4595be1d36c60aea04cc4fad870956a3">&#9670;&nbsp;</a></span>round_down()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T Botan::round_down </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>align_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Round down </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer </td></tr>
    <tr><td class="paramname">align_to</td><td>the alignment boundary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n rounded down to a multiple of align_to </dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8h_source.html#l00037">37</a> of file <a class="el" href="rounding_8h_source.html">rounding.h</a>.</p>

</div>
</div>
<a id="af02949267c5d95ff4e34cb64c5404a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02949267c5d95ff4e34cb64c5404a4f">&#9670;&nbsp;</a></span>round_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::round_up </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Round up </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a non-negative integer </td></tr>
    <tr><td class="paramname">align_to</td><td>the alignment boundary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n rounded up to a multiple of align_to </dd></dl>

<p class="definition">Definition at line <a class="el" href="rounding_8h_source.html#l00021">21</a> of file <a class="el" href="rounding_8h_source.html">rounding.h</a>.</p>

</div>
</div>
<a id="abaf9f9ec7cd1cb34fa0a9b98592fcb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf9f9ec7cd1cb34fa0a9b98592fcb84">&#9670;&nbsp;</a></span>same_mem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Botan::same_mem </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Memory comparison, input insensitive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>a pointer to an array </td></tr>
    <tr><td class="paramname">p2</td><td>a pointer to another array </td></tr>
    <tr><td class="paramname">n</td><td>the number of Ts in p1 and p2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff p1[i] == p2[i] forall i in [0...n) </dd></dl>

<p class="definition">Definition at line <a class="el" href="mem__ops_8h_source.html#l00158">158</a> of file <a class="el" href="mem__ops_8h_source.html">mem_ops.h</a>.</p>

</div>
</div>
<a id="ae1b6ad71a73156fb774a71db9e99eb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b6ad71a73156fb774a71db9e99eb5a">&#9670;&nbsp;</a></span>scrypt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::scrypt </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>output</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>output_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>salt</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>salt_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scrypt key derivation function (RFC 7914) Before 2.8 this function was the primary interface for scrypt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the output will be placed here </td></tr>
    <tr><td class="paramname">output_len</td><td>length of output </td></tr>
    <tr><td class="paramname">password</td><td>the user password </td></tr>
    <tr><td class="paramname">salt</td><td>the salt </td></tr>
    <tr><td class="paramname">salt_len</td><td>length of salt </td></tr>
    <tr><td class="paramname">N</td><td>the CPU/Memory cost parameter, must be power of 2 </td></tr>
    <tr><td class="paramname">r</td><td>the block size parameter </td></tr>
    <tr><td class="paramname">p</td><td>the parallelization parameter</td></tr>
  </table>
  </dd>
</dl>
<p>Suitable parameters for most uses would be N = 32768, r = 8, p = 1</p>
<p>Scrypt uses approximately (p + N + 1) * 128 * r bytes of memory </p>

<p class="definition">Definition at line <a class="el" href="scrypt_8h_source.html#l00106">106</a> of file <a class="el" href="scrypt_8h_source.html">scrypt.h</a>.</p>

</div>
</div>
<a id="ace49e77ed072090e3a7df831742981a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace49e77ed072090e3a7df831742981a6">&#9670;&nbsp;</a></span>set_mem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::set_mem </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set memory to a fixed value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to an array </td></tr>
    <tr><td class="paramname">n</td><td>the number of Ts pointed to by ptr </td></tr>
    <tr><td class="paramname">val</td><td>the value to set each byte to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mem__ops_8h_source.html#l00123">123</a> of file <a class="el" href="mem__ops_8h_source.html">mem_ops.h</a>.</p>

</div>
</div>
<a id="ae2167ee9b593409c1ca300b1fbec0691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2167ee9b593409c1ca300b1fbec0691">&#9670;&nbsp;</a></span>sig_algo_and_pad_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Botan::sig_algo_and_pad_ok </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>algo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the given padding scheme is valid for the given signature algorithm (key type).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo</td><td>the signature algorithm to be used </td></tr>
    <tr><td class="paramname">padding</td><td>the padding scheme to be used </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="padding_8cpp_source.html#l00037">37</a> of file <a class="el" href="padding_8cpp_source.html">padding.cpp</a>.</p>

</div>
</div>
<a id="acec63fb9306fc59d57604c157777361d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec63fb9306fc59d57604c157777361d">&#9670;&nbsp;</a></span>significant_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Botan::significant_bytes </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of significant bytes in n </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>an integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of significant bytes in n </dd></dl>

<p class="definition">Definition at line <a class="el" href="bit__ops_8h_source.html#l00066">66</a> of file <a class="el" href="bit__ops_8h_source.html">bit_ops.h</a>.</p>

</div>
</div>
<a id="a26f4a43173adf5f333b598149c3eef1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f4a43173adf5f333b598149c3eef1e">&#9670;&nbsp;</a></span>store_be() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_be </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a big-endian uint16_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint16_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00434">434</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a237738c57bc371f45785750daad2cf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237738c57bc371f45785750daad2cf7f">&#9670;&nbsp;</a></span>store_be() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_be </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a big-endian uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint32_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00466">466</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="af55277e5a97f10bb1f19a121bfcce030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55277e5a97f10bb1f19a121bfcce030">&#9670;&nbsp;</a></span>store_be() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_be </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a big-endian uint64_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint64_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00502">502</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="adf2d43d6f22f9440efca19d126179271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2d43d6f22f9440efca19d126179271">&#9670;&nbsp;</a></span>store_be() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_be </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store two big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00561">561</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a2c8b865c60e5d60524c7c79d66b4b120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8b865c60e5d60524c7c79d66b4b120">&#9670;&nbsp;</a></span>store_be() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_be </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store four big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
    <tr><td class="paramname">x2</td><td>the third word </td></tr>
    <tr><td class="paramname">x3</td><td>the fourth word </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00593">593</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="ac7562c0698d83b375aef50abc64bcdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7562c0698d83b375aef50abc64bcdd2">&#9670;&nbsp;</a></span>store_be() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_be </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store eight big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
    <tr><td class="paramname">x2</td><td>the third word </td></tr>
    <tr><td class="paramname">x3</td><td>the fourth word </td></tr>
    <tr><td class="paramname">x4</td><td>the fifth word </td></tr>
    <tr><td class="paramname">x5</td><td>the sixth word </td></tr>
    <tr><td class="paramname">x6</td><td>the seventh word </td></tr>
    <tr><td class="paramname">x7</td><td>the eighth word </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00640">640</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="ac0c49ee3a99775f2fba422752fdbc21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c49ee3a99775f2fba422752fdbc21a">&#9670;&nbsp;</a></span>store_le() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_le </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a little-endian uint16_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint16_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00450">450</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="aced6f16a306b58cc117c3a03e04cf788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced6f16a306b58cc117c3a03e04cf788">&#9670;&nbsp;</a></span>store_le() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_le </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a little-endian uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint32_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00484">484</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="ac123595229ef6588f851540b9b774800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac123595229ef6588f851540b9b774800">&#9670;&nbsp;</a></span>store_le() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_le </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a little-endian uint64_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint64_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00524">524</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a0bf3a60376720003e37586a548175426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf3a60376720003e37586a548175426">&#9670;&nbsp;</a></span>store_le() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_le </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store two little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00548">548</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a7ba9e7bbb06b5843eb883b1fdbe22848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba9e7bbb06b5843eb883b1fdbe22848">&#9670;&nbsp;</a></span>store_le() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_le </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store four little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
    <tr><td class="paramname">x2</td><td>the third word </td></tr>
    <tr><td class="paramname">x3</td><td>the fourth word </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00576">576</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a7b4ba47d9124f22d4f31e9a1e6522053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4ba47d9124f22d4f31e9a1e6522053">&#9670;&nbsp;</a></span>store_le() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::store_le </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store eight little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
    <tr><td class="paramname">x2</td><td>the third word </td></tr>
    <tr><td class="paramname">x3</td><td>the fourth word </td></tr>
    <tr><td class="paramname">x4</td><td>the fifth word </td></tr>
    <tr><td class="paramname">x5</td><td>the sixth word </td></tr>
    <tr><td class="paramname">x6</td><td>the seventh word </td></tr>
    <tr><td class="paramname">x7</td><td>the eighth word </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loadstor_8h_source.html#l00614">614</a> of file <a class="el" href="loadstor_8h_source.html">loadstor.h</a>.</p>

</div>
</div>
<a id="a8ffe6aa56dd7683af8e6408daf290312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffe6aa56dd7683af8e6408daf290312">&#9670;&nbsp;</a></span>string_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Botan::string_join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Join a string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strs</td><td>strings to join </td></tr>
    <tr><td class="paramname">delim</td><td>the delimitor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string joined by delim </dd></dl>

<p class="definition">Definition at line <a class="el" href="parsing_8cpp_source.html#l00178">178</a> of file <a class="el" href="parsing_8cpp_source.html">parsing.cpp</a>.</p>

</div>
</div>
<a id="aaf096546028928a2d760aa504a9a2a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf096546028928a2d760aa504a9a2a74">&#9670;&nbsp;</a></span>throw_invalid_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOTAN_NORETURN void BOTAN_UNSTABLE_API Botan::throw_invalid_argument </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when an invalid argument is used Throws Invalid_Argument </p>

<p class="definition">Definition at line <a class="el" href="assert_8cpp_source.html#l00013">13</a> of file <a class="el" href="assert_8cpp_source.html">assert.cpp</a>.</p>

</div>
</div>
<a id="ad46752d75e4f165d48d1ab2c5c33033b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46752d75e4f165d48d1ab2c5c33033b">&#9670;&nbsp;</a></span>throw_invalid_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOTAN_NORETURN void BOTAN_UNSTABLE_API Botan::throw_invalid_state </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called when an invalid state is encountered Throws Invalid_State </p>

<p class="definition">Definition at line <a class="el" href="assert_8cpp_source.html#l00022">22</a> of file <a class="el" href="assert_8cpp_source.html">assert.cpp</a>.</p>

</div>
</div>
<a id="a2d7ee67f502279fc24a01b42c5451c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7ee67f502279fc24a01b42c5451c3c">&#9670;&nbsp;</a></span>ucs2_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string BOTAN_UNSTABLE_API Botan::ucs2_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ucs2</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a sequence of UCS-2 (big endian) characters to a UTF-8 string This is used for ASN.1 BMPString type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ucs2</td><td>the sequence of UCS-2 characters </td></tr>
    <tr><td class="paramname">len</td><td>length of ucs2 in bytes, must be a multiple of 2 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="charset_8cpp_source.html#l00061">61</a> of file <a class="el" href="charset_8cpp_source.html">charset.cpp</a>.</p>

</div>
</div>
<a id="a2bb4359def9a750e534e6ece252bd319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb4359def9a750e534e6ece252bd319">&#9670;&nbsp;</a></span>ucs4_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string BOTAN_UNSTABLE_API Botan::ucs4_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>ucs4</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a sequence of UCS-4 (big endian) characters to a UTF-8 string This is used for ASN.1 UniversalString type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ucs4</td><td>the sequence of UCS-4 characters </td></tr>
    <tr><td class="paramname">len</td><td>length of ucs4 in bytes, must be a multiple of 4 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="charset_8cpp_source.html#l00078">78</a> of file <a class="el" href="charset_8cpp_source.html">charset.cpp</a>.</p>

</div>
</div>
<a id="a590c935190a5568639820d98a911f7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590c935190a5568639820d98a911f7cd">&#9670;&nbsp;</a></span>utf8_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string BOTAN_UNSTABLE_API Botan::utf8_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a UTF-8 string to Latin-1 If a character outside the Latin-1 range is encountered, an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="charset_8cpp_source.html#l00098">98</a> of file <a class="el" href="charset_8cpp_source.html">charset.cpp</a>.</p>

</div>
</div>
<a id="ae62a85e0371b9210c98d9dcdb1632502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62a85e0371b9210c98d9dcdb1632502">&#9670;&nbsp;</a></span>value_exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Botan::value_exists </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Existence check for values </p>

<p class="definition">Definition at line <a class="el" href="stl__util_8h_source.html#l00086">86</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a id="ab8509bd05c79dd4ea42fda5448fda5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8509bd05c79dd4ea42fda5448fda5b5">&#9670;&nbsp;</a></span>x500_name_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Botan::x500_name_cmp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse an ASN.1 OID </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oid</td><td>the OID in string form </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OID components Compare two names using the X.509 comparison algorithm </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name1</td><td>the first name </td></tr>
    <tr><td class="paramname">name2</td><td>the second name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if name1 is the same as name2 by the X.509 comparison rules </dd></dl>

<p class="definition">Definition at line <a class="el" href="parsing_8cpp_source.html#l00228">228</a> of file <a class="el" href="parsing_8cpp_source.html">parsing.cpp</a>.</p>

</div>
</div>
<a id="a9c8197d5fc973d59ae216ca5f865be55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8197d5fc973d59ae216ca5f865be55">&#9670;&nbsp;</a></span>xor_buf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::xor_buf </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>XOR arrays. Postcondition out[i] = in[i] ^ out[i] forall i = 0...length </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the input/output buffer </td></tr>
    <tr><td class="paramname">in</td><td>the read-only input buffer </td></tr>
    <tr><td class="paramname">length</td><td>the length of the buffers </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mem__ops_8h_source.html#l00174">174</a> of file <a class="el" href="mem__ops_8h_source.html">mem_ops.h</a>.</p>

</div>
</div>
<a id="a47f27789ca2bd6074362a06f2ee5bea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f27789ca2bd6074362a06f2ee5bea4">&#9670;&nbsp;</a></span>xor_buf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Botan::xor_buf </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in2</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>XOR arrays. Postcondition out[i] = in[i] ^ in2[i] forall i = 0...length </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output buffer </td></tr>
    <tr><td class="paramname">in</td><td>the first input buffer </td></tr>
    <tr><td class="paramname">in2</td><td>the second output buffer </td></tr>
    <tr><td class="paramname">length</td><td>the length of the three buffers </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mem__ops_8h_source.html#l00209">209</a> of file <a class="el" href="mem__ops_8h_source.html">mem_ops.h</a>.</p>

</div>
</div>
<a id="a2534f0fffcfe960b963990832bd1d26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2534f0fffcfe960b963990832bd1d26e">&#9670;&nbsp;</a></span>zap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Botan::zap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zeroise the values then free the memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector to zeroise and free </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="secmem_8h_source.html#l00170">170</a> of file <a class="el" href="secmem_8h_source.html">secmem.h</a>.</p>

</div>
</div>
<a id="a09ce987463cc4e1b7682f31bb486fdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ce987463cc4e1b7682f31bb486fdb1">&#9670;&nbsp;</a></span>zeroise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Botan::zeroise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zeroise the values; length remains unchanged </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector to zeroise </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="secmem_8h_source.html#l00160">160</a> of file <a class="el" href="secmem_8h_source.html">secmem.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afbb6ea5fa1423573816f3aeb42fb5062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb6ea5fa1423573816f3aeb42fb5062">&#9670;&nbsp;</a></span>allowed_signature_paddings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;const std::string, std::vector&lt;std::string&gt; &gt; Botan::allowed_signature_paddings</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">   {</div><div class="line">   { <span class="stringliteral">&quot;DSA&quot;</span>, {<span class="stringliteral">&quot;EMSA1&quot;</span>} },</div><div class="line">   { <span class="stringliteral">&quot;ECDSA&quot;</span>, {<span class="stringliteral">&quot;EMSA1&quot;</span>} },</div><div class="line">   { <span class="stringliteral">&quot;ECGDSA&quot;</span>, {<span class="stringliteral">&quot;EMSA1&quot;</span>} },</div><div class="line">   { <span class="stringliteral">&quot;ECKCDSA&quot;</span>, {<span class="stringliteral">&quot;EMSA1&quot;</span>} },</div><div class="line">   { <span class="stringliteral">&quot;GOST-34.10&quot;</span>, {<span class="stringliteral">&quot;EMSA1&quot;</span>} },</div><div class="line">   { <span class="stringliteral">&quot;RSA&quot;</span>, {<span class="stringliteral">&quot;EMSA4&quot;</span>, <span class="stringliteral">&quot;EMSA3&quot;</span>} },</div><div class="line">   }</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="padding_8cpp_source.html#l00020">20</a> of file <a class="el" href="padding_8cpp_source.html">padding.cpp</a>.</p>

</div>
</div>
<a id="ad1f2122e900d9b65e6c949734915b67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f2122e900d9b65e6c949734915b67b">&#9670;&nbsp;</a></span>DES_SPBOX1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t Botan::DES_SPBOX1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DES Triple DES </p>

<p class="definition">Definition at line <a class="el" href="des__tab_8cpp_source.html#l00012">12</a> of file <a class="el" href="des__tab_8cpp_source.html">des_tab.cpp</a>.</p>

</div>
</div>
<a id="a84160e8d4f120a4f232bf20ecb80be0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84160e8d4f120a4f232bf20ecb80be0e">&#9670;&nbsp;</a></span>format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">secure_vector&lt;uint8_t&gt; uint8_t Botan::format</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">   std::vector&lt;uint8_t&gt; enc = point.encode(static_cast&lt;PointGFp::Compression_Type&gt;(format))</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="point__gfp_8h_source.html#l00383">383</a> of file <a class="el" href="point__gfp_8h_source.html">point_gfp.h</a>.</p>

</div>
</div>
<a id="a74718b9df0b68e9b2d04755c39d3b55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74718b9df0b68e9b2d04755c39d3b55d">&#9670;&nbsp;</a></span>HEX_CODEC_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t Botan::HEX_CODEC_BUFFER_SIZE = 256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size used for internal buffer in hex encoder/decoder </p>

<p class="definition">Definition at line <a class="el" href="hex__filt_8cpp_source.html#l00018">18</a> of file <a class="el" href="hex__filt_8cpp_source.html">hex_filt.cpp</a>.</p>

</div>
</div>
<a id="aad9020384b0dc79f1bc8dcc59d5ee6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9020384b0dc79f1bc8dcc59d5ee6fc">&#9670;&nbsp;</a></span>MAC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a> (2,0) MessageAuthenticationCode typedef MessageAuthenticationCode Botan::MAC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This class represents Message Authentication Code (MAC) objects. </p>

<p class="definition">Definition at line <a class="el" href="mac_8h_source.html#l00021">21</a> of file <a class="el" href="mac_8h_source.html">mac.h</a>.</p>

</div>
</div>
<a id="a137fc6f2c61b1ee506513b92b09618c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137fc6f2c61b1ee506513b92b09618c6">&#9670;&nbsp;</a></span>PK_KA_Key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a> (2,0) Private_Key class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a> (2,0) PK_Key_Agreement_Key typedef PK_Key_Agreement_Key Botan::PK_KA_Key</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Private Key Base Class PK Secret Value Derivation Key </p>

<p class="definition">Definition at line <a class="el" href="pk__keys_8h_source.html#l00281">281</a> of file <a class="el" href="pk__keys_8h_source.html">pk_keys.h</a>.</p>

</div>
</div>
<a id="a501e4632aed1ca4799b03efff7dc59d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501e4632aed1ca4799b03efff7dc59d7">&#9670;&nbsp;</a></span>PRIME_TABLE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t Botan::PRIME_TABLE_SIZE = 6541</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The size of the PRIMES[] array </p>

<p class="definition">Definition at line <a class="el" href="numthry_8h_source.html#l00276">276</a> of file <a class="el" href="numthry_8h_source.html">numthry.h</a>.</p>

</div>
</div>
<a id="a7aedf36a60e3180255517925fa25efca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aedf36a60e3180255517925fa25efca">&#9670;&nbsp;</a></span>SHA_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a> (2,0) SHA_160 final typedef SHA_160 Botan::SHA_1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NIST's SHA-160 </p>

<p class="definition">Definition at line <a class="el" href="sha160_8h_source.html#l00018">18</a> of file <a class="el" href="sha160_8h_source.html">sha160.h</a>.</p>

</div>
</div>
<a id="a021ffc520728602cd2f027a40b68bc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021ffc520728602cd2f027a40b68bc5f">&#9670;&nbsp;</a></span>Transform_Filter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="namespace_botan.html#a6b9388030d872e586a4655b776ac9501">BOTAN_PUBLIC_API</a> (2,0) Cipher_Mode_Filter final typedef Cipher_Mode_Filter Botan::Transform_Filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filter interface for cipher modes </p>

<p class="definition">Definition at line <a class="el" href="cipher__filter_8h_source.html#l00020">20</a> of file <a class="el" href="cipher__filter_8h_source.html">cipher_filter.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
