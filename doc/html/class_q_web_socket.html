<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>even-network: QWebSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="2018-12-27 at 10-36-23.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">even-network
   </div>
   <div id="projectbrief">EVEN Network â€” is an open cross-chain platform with EVEN cryptocurrency that allows users to interact with more than one blockchain at a time.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_q_web_socket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">QWebSocket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a TCP socket that talks the WebSocket protocol.  
 <a href="class_q_web_socket.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for QWebSocket:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_q_web_socket.png" usemap="#QWebSocket_map" alt=""/>
  <map id="QWebSocket_map" name="QWebSocket_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr class="memitem:ae1c9af16e7f53666ccd423864b8e2c35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ae1c9af16e7f53666ccd423864b8e2c35">close</a> (<a class="el" href="namespace_q_web_socket_protocol.html#a9f236676f594451d8d723f260b71028c">QWebSocketProtocol::CloseCode</a> <a class="el" href="class_q_web_socket.html#ac0392e28fa81d5452868813d5e907d71">closeCode</a>=QWebSocketProtocol::CloseCodeNormal, const QString &amp;reason=QString())</td></tr>
<tr class="memdesc:ae1c9af16e7f53666ccd423864b8e2c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gracefully closes the socket with the given <em>closeCode</em> and <em>reason</em>.  <a href="#ae1c9af16e7f53666ccd423864b8e2c35">More...</a><br /></td></tr>
<tr class="separator:ae1c9af16e7f53666ccd423864b8e2c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0351c89316b6914a58bc2f5c8ed9e6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ac0351c89316b6914a58bc2f5c8ed9e6b">open</a> (const QUrl &amp;url)</td></tr>
<tr class="memdesc:ac0351c89316b6914a58bc2f5c8ed9e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a WebSocket connection using the given <em>url</em>.  <a href="#ac0351c89316b6914a58bc2f5c8ed9e6b">More...</a><br /></td></tr>
<tr class="separator:ac0351c89316b6914a58bc2f5c8ed9e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f321a0eb76101df28f9f3ebefa0ee3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a7f321a0eb76101df28f9f3ebefa0ee3d">open</a> (const QNetworkRequest &amp;<a class="el" href="class_q_web_socket.html#a17b0d131ad2e4a0140f5faf23d30335c">request</a>)</td></tr>
<tr class="memdesc:a7f321a0eb76101df28f9f3ebefa0ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a WebSocket connection using the given <em>request</em>.  <a href="#a7f321a0eb76101df28f9f3ebefa0ee3d">More...</a><br /></td></tr>
<tr class="separator:a7f321a0eb76101df28f9f3ebefa0ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add33f933cd9ceffdc03d6b3c6e948d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#add33f933cd9ceffdc03d6b3c6e948d89">ping</a> (const QByteArray &amp;payload=QByteArray())</td></tr>
<tr class="memdesc:add33f933cd9ceffdc03d6b3c6e948d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pings the server to indicate that the connection is still alive. Additional <em>payload</em> can be sent along the ping message.  <a href="#add33f933cd9ceffdc03d6b3c6e948d89">More...</a><br /></td></tr>
<tr class="separator:add33f933cd9ceffdc03d6b3c6e948d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed580d710b6613a6218a78f4c07fb856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#aed580d710b6613a6218a78f4c07fb856">ignoreSslErrors</a> ()</td></tr>
<tr class="separator:aed580d710b6613a6218a78f4c07fb856"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:a74faf7acf77a4b74cf2c5caa74b1d77a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a74faf7acf77a4b74cf2c5caa74b1d77a">aboutToClose</a> ()</td></tr>
<tr class="separator:a74faf7acf77a4b74cf2c5caa74b1d77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176c51371ba6d3b13fec0f7f287b6102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a176c51371ba6d3b13fec0f7f287b6102">connected</a> ()</td></tr>
<tr class="memdesc:a176c51371ba6d3b13fec0f7f287b6102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when a connection is successfully established. A connection is successfully established when the socket is connected and the handshake was successful.  <a href="#a176c51371ba6d3b13fec0f7f287b6102">More...</a><br /></td></tr>
<tr class="separator:a176c51371ba6d3b13fec0f7f287b6102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba1f43d105bea22b4021a68f924169b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#aaba1f43d105bea22b4021a68f924169b">disconnected</a> ()</td></tr>
<tr class="memdesc:aaba1f43d105bea22b4021a68f924169b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when the socket is disconnected.  <a href="#aaba1f43d105bea22b4021a68f924169b">More...</a><br /></td></tr>
<tr class="separator:aaba1f43d105bea22b4021a68f924169b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba46b4ae0292aee9632297a56122902a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#aba46b4ae0292aee9632297a56122902a">stateChanged</a> (QAbstractSocket::SocketState <a class="el" href="class_q_web_socket.html#abf40a05dfbb85a86355c73f7c2f2c492">state</a>)</td></tr>
<tr class="separator:aba46b4ae0292aee9632297a56122902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5c2e589b072ef513b67c29fd69976c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#acd5c2e589b072ef513b67c29fd69976c">proxyAuthenticationRequired</a> (const QNetworkProxy &amp;<a class="el" href="class_q_web_socket.html#a6451f984f2eb43cbc5fcd6f0dd4421d9">proxy</a>, QAuthenticator *pAuthenticator)</td></tr>
<tr class="separator:acd5c2e589b072ef513b67c29fd69976c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d4ab6c6fe8017626fb079cee6518a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a17d4ab6c6fe8017626fb079cee6518a6">readChannelFinished</a> ()</td></tr>
<tr class="separator:a17d4ab6c6fe8017626fb079cee6518a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0feabc8f7979f054b15d903a54882a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#af0feabc8f7979f054b15d903a54882a6">textFrameReceived</a> (const QString &amp;frame, bool isLastFrame)</td></tr>
<tr class="separator:af0feabc8f7979f054b15d903a54882a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bf9793d8edec549ea45d503e9be366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a43bf9793d8edec549ea45d503e9be366">binaryFrameReceived</a> (const QByteArray &amp;frame, bool isLastFrame)</td></tr>
<tr class="separator:a43bf9793d8edec549ea45d503e9be366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f93d1bf2b5e973dbc3acc4378505e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ad0f93d1bf2b5e973dbc3acc4378505e4">textMessageReceived</a> (const QString &amp;message)</td></tr>
<tr class="separator:ad0f93d1bf2b5e973dbc3acc4378505e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefdf77b949880d571e64a30b01f75e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#aaefdf77b949880d571e64a30b01f75e7">binaryMessageReceived</a> (const QByteArray &amp;message)</td></tr>
<tr class="separator:aaefdf77b949880d571e64a30b01f75e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8b42c52eef7982f50dd1131b3133f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a2c8b42c52eef7982f50dd1131b3133f6">error</a> (QAbstractSocket::SocketError error)</td></tr>
<tr class="separator:a2c8b42c52eef7982f50dd1131b3133f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de4b00bd909961bfc5179d2859c4d65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a8de4b00bd909961bfc5179d2859c4d65">pong</a> (quint64 elapsedTime, const QByteArray &amp;payload)</td></tr>
<tr class="separator:a8de4b00bd909961bfc5179d2859c4d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4be1036cba153baa4a7a7c2bfa3fe91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ad4be1036cba153baa4a7a7c2bfa3fe91">bytesWritten</a> (qint64 bytes)</td></tr>
<tr class="separator:ad4be1036cba153baa4a7a7c2bfa3fe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d3eebd5b595e4e869d2ad6cef45ed7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ae0d3eebd5b595e4e869d2ad6cef45ed7">sslErrors</a> (const QList&lt; QSslError &gt; &amp;errors)</td></tr>
<tr class="separator:ae0d3eebd5b595e4e869d2ad6cef45ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12bc04c9c86d4b76238d8f3a25dcfa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ab12bc04c9c86d4b76238d8f3a25dcfa1">preSharedKeyAuthenticationRequired</a> (QSslPreSharedKeyAuthenticator *authenticator)</td></tr>
<tr class="separator:ab12bc04c9c86d4b76238d8f3a25dcfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1dd87330154f6f06e63b3904ccb3aabe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a1dd87330154f6f06e63b3904ccb3aabe">QWebSocket</a> (const QString &amp;<a class="el" href="class_q_web_socket.html#af03bb3ce5ec1bcab0882e29fd3e62961">origin</a>=QString(), <a class="el" href="namespace_q_web_socket_protocol.html#ad53f2684577effe0a517eadb48714df3">QWebSocketProtocol::Version</a> <a class="el" href="class_q_web_socket.html#a691b38b043dfa8295242b39e04d2c0e7">version</a>=QWebSocketProtocol::VersionLatest, QObject *parent=Q_NULLPTR)</td></tr>
<tr class="memdesc:a1dd87330154f6f06e63b3904ccb3aabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> with the given <em>origin</em>, the <em>version</em> of the protocol to use and <em>parent</em>.  <a href="#a1dd87330154f6f06e63b3904ccb3aabe">More...</a><br /></td></tr>
<tr class="separator:a1dd87330154f6f06e63b3904ccb3aabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8fadd9fbc92bb1a1d8ecac45a3e526"><td class="memItemLeft" align="right" valign="top"><a id="a7c8fadd9fbc92bb1a1d8ecac45a3e526"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a7c8fadd9fbc92bb1a1d8ecac45a3e526">~QWebSocket</a> ()</td></tr>
<tr class="memdesc:a7c8fadd9fbc92bb1a1d8ecac45a3e526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a>. Closes the socket if it is still open, and releases any used resources. <br /></td></tr>
<tr class="separator:a7c8fadd9fbc92bb1a1d8ecac45a3e526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f91d8d8c8df94bbcdd97c03e28c3f7"><td class="memItemLeft" align="right" valign="top"><a id="a37f91d8d8c8df94bbcdd97c03e28c3f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a37f91d8d8c8df94bbcdd97c03e28c3f7">abort</a> ()</td></tr>
<tr class="memdesc:a37f91d8d8c8df94bbcdd97c03e28c3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the current socket and resets the socket. Unlike <a class="el" href="class_q_web_socket.html#ae1c9af16e7f53666ccd423864b8e2c35" title="Gracefully closes the socket with the given closeCode and reason. ">close()</a>, this function immediately closes the socket, discarding any pending data in the write buffer. <br /></td></tr>
<tr class="separator:a37f91d8d8c8df94bbcdd97c03e28c3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e9ba3091c73531678a55982f954dae"><td class="memItemLeft" align="right" valign="top">QAbstractSocket::SocketError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a98e9ba3091c73531678a55982f954dae">error</a> () const</td></tr>
<tr class="separator:a98e9ba3091c73531678a55982f954dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6ec5ee08cb1d5b3ca4d562cf1cb1b8"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#aed6ec5ee08cb1d5b3ca4d562cf1cb1b8">errorString</a> () const</td></tr>
<tr class="separator:aed6ec5ee08cb1d5b3ca4d562cf1cb1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d175f62f7db36e2e4ade46b1523efa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a3d175f62f7db36e2e4ade46b1523efa1">flush</a> ()</td></tr>
<tr class="separator:a3d175f62f7db36e2e4ade46b1523efa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d5224aa46a4e4429d17b0c4f6854c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ad5d5224aa46a4e4429d17b0c4f6854c2">isValid</a> () const</td></tr>
<tr class="separator:ad5d5224aa46a4e4429d17b0c4f6854c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba293f65947a7690afe4e142cc77aa54"><td class="memItemLeft" align="right" valign="top">QHostAddress&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#aba293f65947a7690afe4e142cc77aa54">localAddress</a> () const</td></tr>
<tr class="separator:aba293f65947a7690afe4e142cc77aa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c606f929fe8860b5f3e2f581fd4e02"><td class="memItemLeft" align="right" valign="top">quint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#af5c606f929fe8860b5f3e2f581fd4e02">localPort</a> () const</td></tr>
<tr class="separator:af5c606f929fe8860b5f3e2f581fd4e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15778b8a5f6ffb83c61b5e9b1701eb28"><td class="memItemLeft" align="right" valign="top">QAbstractSocket::PauseModes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a15778b8a5f6ffb83c61b5e9b1701eb28">pauseMode</a> () const</td></tr>
<tr class="separator:a15778b8a5f6ffb83c61b5e9b1701eb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7788b65ef72c825dc9ffcb314c20ef4d"><td class="memItemLeft" align="right" valign="top">QHostAddress&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a7788b65ef72c825dc9ffcb314c20ef4d">peerAddress</a> () const</td></tr>
<tr class="separator:a7788b65ef72c825dc9ffcb314c20ef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de6e280d531c748d22898775b7f87f3"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a9de6e280d531c748d22898775b7f87f3">peerName</a> () const</td></tr>
<tr class="separator:a9de6e280d531c748d22898775b7f87f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8587d64043f65c8da7944541fab584c"><td class="memItemLeft" align="right" valign="top">quint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ab8587d64043f65c8da7944541fab584c">peerPort</a> () const</td></tr>
<tr class="separator:ab8587d64043f65c8da7944541fab584c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6451f984f2eb43cbc5fcd6f0dd4421d9"><td class="memItemLeft" align="right" valign="top">QNetworkProxy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a6451f984f2eb43cbc5fcd6f0dd4421d9">proxy</a> () const</td></tr>
<tr class="separator:a6451f984f2eb43cbc5fcd6f0dd4421d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab567ac6d43bb2f0526a1a5d0e2872034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ab567ac6d43bb2f0526a1a5d0e2872034">setProxy</a> (const QNetworkProxy &amp;networkProxy)</td></tr>
<tr class="separator:ab567ac6d43bb2f0526a1a5d0e2872034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e24c3101e75a42264aa527936573e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a3f0e24c3101e75a42264aa527936573e">setMaskGenerator</a> (const <a class="el" href="class_q_mask_generator.html">QMaskGenerator</a> *<a class="el" href="class_q_web_socket.html#a20ba00f459a7e448bd611a24500d94c6">maskGenerator</a>)</td></tr>
<tr class="separator:a3f0e24c3101e75a42264aa527936573e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ba00f459a7e448bd611a24500d94c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_q_mask_generator.html">QMaskGenerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a20ba00f459a7e448bd611a24500d94c6">maskGenerator</a> () const</td></tr>
<tr class="separator:a20ba00f459a7e448bd611a24500d94c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3755970eca2be3d792ceb9c8e560ae32"><td class="memItemLeft" align="right" valign="top">qint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a3755970eca2be3d792ceb9c8e560ae32">readBufferSize</a> () const</td></tr>
<tr class="separator:a3755970eca2be3d792ceb9c8e560ae32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6582dd40792bb2c8309a4890236510"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#adc6582dd40792bb2c8309a4890236510">setReadBufferSize</a> (qint64 size)</td></tr>
<tr class="separator:adc6582dd40792bb2c8309a4890236510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21dbd52b116cc5dae811548000001ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#af21dbd52b116cc5dae811548000001ee">resume</a> ()</td></tr>
<tr class="separator:af21dbd52b116cc5dae811548000001ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6650c827cace4ccb27988894872bcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a7d6650c827cace4ccb27988894872bcc">setPauseMode</a> (QAbstractSocket::PauseModes <a class="el" href="class_q_web_socket.html#a15778b8a5f6ffb83c61b5e9b1701eb28">pauseMode</a>)</td></tr>
<tr class="separator:a7d6650c827cace4ccb27988894872bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf40a05dfbb85a86355c73f7c2f2c492"><td class="memItemLeft" align="right" valign="top"><a id="abf40a05dfbb85a86355c73f7c2f2c492"></a>
QAbstractSocket::SocketState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#abf40a05dfbb85a86355c73f7c2f2c492">state</a> () const</td></tr>
<tr class="memdesc:abf40a05dfbb85a86355c73f7c2f2c492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of the socket. <br /></td></tr>
<tr class="separator:abf40a05dfbb85a86355c73f7c2f2c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691b38b043dfa8295242b39e04d2c0e7"><td class="memItemLeft" align="right" valign="top"><a id="a691b38b043dfa8295242b39e04d2c0e7"></a>
<a class="el" href="namespace_q_web_socket_protocol.html#ad53f2684577effe0a517eadb48714df3">QWebSocketProtocol::Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a691b38b043dfa8295242b39e04d2c0e7">version</a> () const</td></tr>
<tr class="memdesc:a691b38b043dfa8295242b39e04d2c0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version the socket is currently using. <br /></td></tr>
<tr class="separator:a691b38b043dfa8295242b39e04d2c0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f3bd6750efba819a8ca6eeca0270a9"><td class="memItemLeft" align="right" valign="top"><a id="a93f3bd6750efba819a8ca6eeca0270a9"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a93f3bd6750efba819a8ca6eeca0270a9">resourceName</a> () const</td></tr>
<tr class="memdesc:a93f3bd6750efba819a8ca6eeca0270a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the resource currently accessed. <br /></td></tr>
<tr class="separator:a93f3bd6750efba819a8ca6eeca0270a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5aa3a3efad1d7663d81e1979aaa63f"><td class="memItemLeft" align="right" valign="top"><a id="a7a5aa3a3efad1d7663d81e1979aaa63f"></a>
QUrl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a7a5aa3a3efad1d7663d81e1979aaa63f">requestUrl</a> () const</td></tr>
<tr class="memdesc:a7a5aa3a3efad1d7663d81e1979aaa63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the url the socket is connected to or will connect to. <br /></td></tr>
<tr class="separator:a7a5aa3a3efad1d7663d81e1979aaa63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b0d131ad2e4a0140f5faf23d30335c"><td class="memItemLeft" align="right" valign="top">QNetworkRequest&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a17b0d131ad2e4a0140f5faf23d30335c">request</a> () const</td></tr>
<tr class="memdesc:a17b0d131ad2e4a0140f5faf23d30335c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the request that was or will be used to open this socket.  <a href="#a17b0d131ad2e4a0140f5faf23d30335c">More...</a><br /></td></tr>
<tr class="separator:a17b0d131ad2e4a0140f5faf23d30335c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03bb3ce5ec1bcab0882e29fd3e62961"><td class="memItemLeft" align="right" valign="top"><a id="af03bb3ce5ec1bcab0882e29fd3e62961"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#af03bb3ce5ec1bcab0882e29fd3e62961">origin</a> () const</td></tr>
<tr class="memdesc:af03bb3ce5ec1bcab0882e29fd3e62961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current origin. <br /></td></tr>
<tr class="separator:af03bb3ce5ec1bcab0882e29fd3e62961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0392e28fa81d5452868813d5e907d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_q_web_socket_protocol.html#a9f236676f594451d8d723f260b71028c">QWebSocketProtocol::CloseCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ac0392e28fa81d5452868813d5e907d71">closeCode</a> () const</td></tr>
<tr class="memdesc:ac0392e28fa81d5452868813d5e907d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the code indicating why the socket was closed.  <a href="#ac0392e28fa81d5452868813d5e907d71">More...</a><br /></td></tr>
<tr class="separator:ac0392e28fa81d5452868813d5e907d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64964f85bc0736ee350975ca6e47c3fe"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a64964f85bc0736ee350975ca6e47c3fe">closeReason</a> () const</td></tr>
<tr class="memdesc:a64964f85bc0736ee350975ca6e47c3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reason why the socket was closed.  <a href="#a64964f85bc0736ee350975ca6e47c3fe">More...</a><br /></td></tr>
<tr class="separator:a64964f85bc0736ee350975ca6e47c3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bdc1e29c50c1e0d88c0977eb298a17"><td class="memItemLeft" align="right" valign="top">qint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#aa3bdc1e29c50c1e0d88c0977eb298a17">sendTextMessage</a> (const QString &amp;message)</td></tr>
<tr class="memdesc:aa3bdc1e29c50c1e0d88c0977eb298a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given <em>message</em> over the socket as a text message and returns the number of bytes actually sent.  <a href="#aa3bdc1e29c50c1e0d88c0977eb298a17">More...</a><br /></td></tr>
<tr class="separator:aa3bdc1e29c50c1e0d88c0977eb298a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56992d89ffba061ec6dc7c3e4a010f6"><td class="memItemLeft" align="right" valign="top">qint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#aa56992d89ffba061ec6dc7c3e4a010f6">sendBinaryMessage</a> (const QByteArray &amp;data)</td></tr>
<tr class="memdesc:aa56992d89ffba061ec6dc7c3e4a010f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given <em>data</em> over the socket as a binary message and returns the number of bytes actually sent.  <a href="#aa56992d89ffba061ec6dc7c3e4a010f6">More...</a><br /></td></tr>
<tr class="separator:aa56992d89ffba061ec6dc7c3e4a010f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c765afbdc0e0afad03b8ad8c958fab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#ae3c765afbdc0e0afad03b8ad8c958fab">ignoreSslErrors</a> (const QList&lt; QSslError &gt; &amp;errors)</td></tr>
<tr class="separator:ae3c765afbdc0e0afad03b8ad8c958fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47402d89258caa95e46452b698cc3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a2b47402d89258caa95e46452b698cc3a">setSslConfiguration</a> (const QSslConfiguration &amp;<a class="el" href="class_q_web_socket.html#a002b89e651c50e9b73ec23d07f4f7eba">sslConfiguration</a>)</td></tr>
<tr class="separator:a2b47402d89258caa95e46452b698cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002b89e651c50e9b73ec23d07f4f7eba"><td class="memItemLeft" align="right" valign="top">QSslConfiguration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_web_socket.html#a002b89e651c50e9b73ec23d07f4f7eba">sslConfiguration</a> () const</td></tr>
<tr class="separator:a002b89e651c50e9b73ec23d07f4f7eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adb12d7272bd4b12f96de1b85a2c64ee5"><td class="memItemLeft" align="right" valign="top"><a id="adb12d7272bd4b12f96de1b85a2c64ee5"></a>
static <a class="el" href="class_q_web_socket.html">QWebSocket</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>upgradeFrom</b> (QTcpSocket *tcpSocket, const QString &amp;serverName, bool isSecure, QObject *parent=Q_NULLPTR) Q_REQUIRED_RESULT</td></tr>
<tr class="separator:adb12d7272bd4b12f96de1b85a2c64ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements a TCP socket that talks the WebSocket protocol. </p>
<p>QtWebSockets </p><dl class="section since"><dt>Since</dt><dd>5.3 WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as  {RFC 6455} in 2011. <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> can both be used in a client application and server application.</dd></dl>
<p>This class was modeled after QAbstractSocket.</p>
<p><a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> currently does not support  {WebSocket Extensions} and  {WebSocket Subprotocols}.</p>
<p><a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> only supports version 13 of the WebSocket protocol, as outlined in  {RFC 6455}.</p>
<dl class="section note"><dt>Note</dt><dd>Some proxies do not understand certain HTTP headers used during a WebSocket handshake. In that case, non-secure WebSocket connections fail. The best way to mitigate against this problem is to use WebSocket over a secure connection.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>To generate masks, this implementation of WebSockets uses the cryptographically insecure qrand() function. For more information about the importance of good masking, see  {"Talking to Yourself for Fun and Profit" by Lin-Shung Huang et al}. The best measure against attacks mentioned in the document above, is to use <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> over a secure connection (<em>wss://</em>). In general, always be careful to not have 3rd party script access to a <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> in your application.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>QAbstractSocket, QTcpSocket</dd>
<dd>
{<a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> client example} </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8h_source.html#l00064">64</a> of file <a class="el" href="qwebsocket_8h_source.html">qwebsocket.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1dd87330154f6f06e63b3904ccb3aabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd87330154f6f06e63b3904ccb3aabe">&#9670;&nbsp;</a></span>QWebSocket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QWebSocket::QWebSocket </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>origin</em> = <code>QString()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_q_web_socket_protocol.html#ad53f2684577effe0a517eadb48714df3">QWebSocketProtocol::Version</a>&#160;</td>
          <td class="paramname"><em>version</em> = <code>QWebSocketProtocol::VersionLatest</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>Q_NULLPTR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> with the given <em>origin</em>, the <em>version</em> of the protocol to use and <em>parent</em>. </p>
<p>The <em>origin</em> of the client is as specified in  {RFC 6454}. (The <em>origin</em> is not required for non-web browser clients (see  {RFC 6455})). The <em>origin</em> may not contain new line characters, otherwise the connection will be aborted immediately during the handshake phase. </p><dl class="section note"><dt>Note</dt><dd>Currently only V13 ( {RFC 6455}) is supported </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00301">301</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a74faf7acf77a4b74cf2c5caa74b1d77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74faf7acf77a4b74cf2c5caa74b1d77a">&#9670;&nbsp;</a></span>aboutToClose</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::aboutToClose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted when the socket is about to close. Connect this signal if you have operations that need to be performed before the socket closes (e.g., if you have data in a separate buffer that needs to be written to the device).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#ae1c9af16e7f53666ccd423864b8e2c35" title="Gracefully closes the socket with the given closeCode and reason. ">close()</a> </dd></dl>

</div>
</div>
<a id="a43bf9793d8edec549ea45d503e9be366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bf9793d8edec549ea45d503e9be366">&#9670;&nbsp;</a></span>binaryFrameReceived</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::binaryFrameReceived </td>
          <td>(</td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLastFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever a binary frame is received. The <em>frame</em> contains the data and <em>isLastFrame</em> indicates whether this is the last frame of the complete message.</p>
<p>This signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#af0feabc8f7979f054b15d903a54882a6">textFrameReceived()</a> </dd></dl>

</div>
</div>
<a id="aaefdf77b949880d571e64a30b01f75e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefdf77b949880d571e64a30b01f75e7">&#9670;&nbsp;</a></span>binaryMessageReceived</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::binaryMessageReceived </td>
          <td>(</td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever a binary message is received. The <em>message</em> contains the received bytes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#ad0f93d1bf2b5e973dbc3acc4378505e4">textMessageReceived()</a> </dd></dl>

</div>
</div>
<a id="ad4be1036cba153baa4a7a7c2bfa3fe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4be1036cba153baa4a7a7c2bfa3fe91">&#9670;&nbsp;</a></span>bytesWritten</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::bytesWritten </td>
          <td>(</td>
          <td class="paramtype">qint64&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted every time a payload of data has been written to the socket. The <em>bytes</em> argument is set to the number of bytes that were written in this payload.</p>
<dl class="section note"><dt>Note</dt><dd>This signal has the same meaning both for secure and non-secure WebSockets. As opposed to QSslSocket, <a class="el" href="class_q_web_socket.html#ad4be1036cba153baa4a7a7c2bfa3fe91">bytesWritten()</a> is only emitted when encrypted data is effectively written (see QSslSocket::encryptedBytesWritten()). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#ae1c9af16e7f53666ccd423864b8e2c35" title="Gracefully closes the socket with the given closeCode and reason. ">close()</a> </dd></dl>

</div>
</div>
<a id="ae1c9af16e7f53666ccd423864b8e2c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c9af16e7f53666ccd423864b8e2c35">&#9670;&nbsp;</a></span>close</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_q_web_socket_protocol.html#a9f236676f594451d8d723f260b71028c">QWebSocketProtocol::CloseCode</a>&#160;</td>
          <td class="paramname"><em>closeCode</em> = <code>QWebSocketProtocol::CloseCodeNormal</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>reason</em> = <code>QString()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gracefully closes the socket with the given <em>closeCode</em> and <em>reason</em>. </p>
<p>Any data in the write buffer is flushed before the socket is closed. The <em>closeCode</em> is a <a class="el" href="namespace_q_web_socket_protocol.html#a9f236676f594451d8d723f260b71028c">QWebSocketProtocol::CloseCode</a> indicating the reason to close, and <em>reason</em> describes the reason of the closure more in detail </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00459">459</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="ac0392e28fa81d5452868813d5e907d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0392e28fa81d5452868813d5e907d71">&#9670;&nbsp;</a></span>closeCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_q_web_socket_protocol.html#a9f236676f594451d8d723f260b71028c">QWebSocketProtocol::CloseCode</a> QWebSocket::closeCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the code indicating why the socket was closed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_q_web_socket_protocol.html#a9f236676f594451d8d723f260b71028c">QWebSocketProtocol::CloseCode</a>, <a class="el" href="class_q_web_socket.html#a64964f85bc0736ee350975ca6e47c3fe" title="Returns the reason why the socket was closed. ">closeReason()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00638">638</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a64964f85bc0736ee350975ca6e47c3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64964f85bc0736ee350975ca6e47c3fe">&#9670;&nbsp;</a></span>closeReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString QWebSocket::closeReason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reason why the socket was closed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#ac0392e28fa81d5452868813d5e907d71" title="Returns the code indicating why the socket was closed. ">closeCode()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00648">648</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a176c51371ba6d3b13fec0f7f287b6102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176c51371ba6d3b13fec0f7f287b6102">&#9670;&nbsp;</a></span>connected</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted when a connection is successfully established. A connection is successfully established when the socket is connected and the handshake was successful. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#ac0351c89316b6914a58bc2f5c8ed9e6b" title="Opens a WebSocket connection using the given url. ">open()</a>, <a class="el" href="class_q_web_socket.html#aaba1f43d105bea22b4021a68f924169b" title="Emitted when the socket is disconnected. ">disconnected()</a> </dd></dl>

</div>
</div>
<a id="aaba1f43d105bea22b4021a68f924169b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba1f43d105bea22b4021a68f924169b">&#9670;&nbsp;</a></span>disconnected</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::disconnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted when the socket is disconnected. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#ae1c9af16e7f53666ccd423864b8e2c35" title="Gracefully closes the socket with the given closeCode and reason. ">close()</a>, <a class="el" href="class_q_web_socket.html#a176c51371ba6d3b13fec0f7f287b6102" title="Emitted when a connection is successfully established. A connection is successfully established when ...">connected()</a> </dd></dl>

</div>
</div>
<a id="a98e9ba3091c73531678a55982f954dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e9ba3091c73531678a55982f954dae">&#9670;&nbsp;</a></span>error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QAbstractSocket::SocketError QWebSocket::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of error that last occurred </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#aed6ec5ee08cb1d5b3ca4d562cf1cb1b8">errorString()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00383">383</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a2c8b42c52eef7982f50dd1131b3133f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8b42c52eef7982f50dd1131b3133f6">&#9670;&nbsp;</a></span>error <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::error </td>
          <td>(</td>
          <td class="paramtype">QAbstractSocket::SocketError&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted after an error occurred. The <em>error</em> parameter describes the type of error that occurred.</p>
<p>QAbstractSocket::SocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#a98e9ba3091c73531678a55982f954dae">error()</a>, <a class="el" href="class_q_web_socket.html#aed6ec5ee08cb1d5b3ca4d562cf1cb1b8">errorString()</a> </dd></dl>

</div>
</div>
<a id="aed6ec5ee08cb1d5b3ca4d562cf1cb1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6ec5ee08cb1d5b3ca4d562cf1cb1b8">&#9670;&nbsp;</a></span>errorString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString QWebSocket::errorString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a human-readable description of the last error that occurred</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#a98e9ba3091c73531678a55982f954dae">error()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00406">406</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a3d175f62f7db36e2e4ade46b1523efa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d175f62f7db36e2e4ade46b1523efa1">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QWebSocket::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned. Call this function if you need <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> will start sending data automatically once control goes back to the event loop. </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00422">422</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="ae3c765afbdc0e0afad03b8ad8c958fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c765afbdc0e0afad03b8ad8c958fab">&#9670;&nbsp;</a></span>ignoreSslErrors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::ignoreSslErrors </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; QSslError &gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This method tells <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> to ignore the errors given in <em>errors</em>.</p>
<p>Note that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</p>
<div class="fragment"></div><!-- fragment --><p> Multiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#ae0d3eebd5b595e4e869d2ad6cef45ed7">sslErrors()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00552">552</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="aed580d710b6613a6218a78f4c07fb856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed580d710b6613a6218a78f4c07fb856">&#9670;&nbsp;</a></span>ignoreSslErrors <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::ignoreSslErrors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This slot tells <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> to ignore errors during <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a>'s handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to <a class="el" href="class_q_web_socket.html#ae0d3eebd5b595e4e869d2ad6cef45ed7">sslErrors()</a>, or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the <a class="el" href="class_q_web_socket.html#ae0d3eebd5b595e4e869d2ad6cef45ed7">sslErrors()</a> signal has been emitted.</p>
<dl class="section warning"><dt>Warning</dt><dd>Be sure to always let the user inspect the errors reported by the <a class="el" href="class_q_web_socket.html#ae0d3eebd5b595e4e869d2ad6cef45ed7">sslErrors()</a> signal, and only call this method upon confirmation from the user that proceeding is ok. If there are unexpected errors, the connection should be aborted. Calling this method without inspecting the actual errors will most likely pose a security risk for your application. Use it with great care!</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#ae0d3eebd5b595e4e869d2ad6cef45ed7">sslErrors()</a>, QSslSocket::ignoreSslErrors(), QNetworkReply::ignoreSslErrors() </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00528">528</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="ad5d5224aa46a4e4429d17b0c4f6854c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d5224aa46a4e4429d17b0c4f6854c2">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QWebSocket::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the socket is ready for reading and writing; otherwise returns <code>false</code>. </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00821">821</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="aba293f65947a7690afe4e142cc77aa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba293f65947a7690afe4e142cc77aa54">&#9670;&nbsp;</a></span>localAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QHostAddress QWebSocket::localAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the local address </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00666">666</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="af5c606f929fe8860b5f3e2f581fd4e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c606f929fe8860b5f3e2f581fd4e02">&#9670;&nbsp;</a></span>localPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint16 QWebSocket::localPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the local port </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00675">675</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a20ba00f459a7e448bd611a24500d94c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ba00f459a7e448bd611a24500d94c6">&#9670;&nbsp;</a></span>maskGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_q_mask_generator.html">QMaskGenerator</a> * QWebSocket::maskGenerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mask generator that is currently used by this <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a>. </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00751">751</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="ac0351c89316b6914a58bc2f5c8ed9e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0351c89316b6914a58bc2f5c8ed9e6b">&#9670;&nbsp;</a></span>open <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::open </td>
          <td>(</td>
          <td class="paramtype">const QUrl &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a WebSocket connection using the given <em>url</em>. </p>
<p>If the url contains newline characters (\r\n), then the error signal will be emitted with QAbstractSocket::ConnectionRefusedError as error type. </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00471">471</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a7f321a0eb76101df28f9f3ebefa0ee3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f321a0eb76101df28f9f3ebefa0ee3d">&#9670;&nbsp;</a></span>open <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::open </td>
          <td>(</td>
          <td class="paramtype">const QNetworkRequest &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a WebSocket connection using the given <em>request</em>. </p>
<dl class="section since"><dt>Since</dt><dd>5.6</dd></dl>
<p>The <em>request</em> url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake. </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00486">486</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a15778b8a5f6ffb83c61b5e9b1701eb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15778b8a5f6ffb83c61b5e9b1701eb28">&#9670;&nbsp;</a></span>pauseMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QAbstractSocket::PauseModes QWebSocket::pauseMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pause mode of this socket </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00684">684</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a7788b65ef72c825dc9ffcb314c20ef4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7788b65ef72c825dc9ffcb314c20ef4d">&#9670;&nbsp;</a></span>peerAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QHostAddress QWebSocket::peerAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the peer address </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00693">693</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a9de6e280d531c748d22898775b7f87f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de6e280d531c748d22898775b7f87f3">&#9670;&nbsp;</a></span>peerName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString QWebSocket::peerName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the peerName </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00702">702</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="ab8587d64043f65c8da7944541fab584c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8587d64043f65c8da7944541fab584c">&#9670;&nbsp;</a></span>peerPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint16 QWebSocket::peerPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the peerport </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00711">711</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="add33f933cd9ceffdc03d6b3c6e948d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add33f933cd9ceffdc03d6b3c6e948d89">&#9670;&nbsp;</a></span>ping</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::ping </td>
          <td>(</td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>payload</em> = <code>QByteArray()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pings the server to indicate that the connection is still alive. Additional <em>payload</em> can be sent along the ping message. </p>
<p>The size of the <em>payload</em> cannot be bigger than 125. If it is larger, the <em>payload</em> is clipped to 125 bytes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#a8de4b00bd909961bfc5179d2859c4d65">pong()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00501">501</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a8de4b00bd909961bfc5179d2859c4d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de4b00bd909961bfc5179d2859c4d65">&#9670;&nbsp;</a></span>pong</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::pong </td>
          <td>(</td>
          <td class="paramtype">quint64&#160;</td>
          <td class="paramname"><em>elapsedTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Emitted when a pong message is received in reply to a previous ping. <em>elapsedTime</em> contains the roundtrip time in milliseconds and <em>payload</em> contains an optional payload that was sent with the ping.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#add33f933cd9ceffdc03d6b3c6e948d89" title="Pings the server to indicate that the connection is still alive. Additional payload can be sent along...">ping()</a> </dd></dl>

</div>
</div>
<a id="ab12bc04c9c86d4b76238d8f3a25dcfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12bc04c9c86d4b76238d8f3a25dcfa1">&#9670;&nbsp;</a></span>preSharedKeyAuthenticationRequired</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::preSharedKeyAuthenticationRequired </td>
          <td>(</td>
          <td class="paramtype">QSslPreSharedKeyAuthenticator *&#160;</td>
          <td class="paramname"><em>authenticator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>5.8</dd></dl>
<p>This signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</p>
<p>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <em>authenticator</em> object according to their needs.</p>
<dl class="section note"><dt>Note</dt><dd>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</dd>
<dd>
The <em>authenticator</em> object is owned by the websocket and must not be deleted by the application.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>QSslPreSharedKeyAuthenticator </dd>
<dd>
QSslSocket::preSharedKeyAuthenticationRequired() </dd></dl>

</div>
</div>
<a id="a6451f984f2eb43cbc5fcd6f0dd4421d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6451f984f2eb43cbc5fcd6f0dd4421d9">&#9670;&nbsp;</a></span>proxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QNetworkProxy QWebSocket::proxy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the currently configured proxy </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00721">721</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="acd5c2e589b072ef513b67c29fd69976c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5c2e589b072ef513b67c29fd69976c">&#9670;&nbsp;</a></span>proxyAuthenticationRequired</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::proxyAuthenticationRequired </td>
          <td>(</td>
          <td class="paramtype">const QNetworkProxy &amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QAuthenticator *&#160;</td>
          <td class="paramname"><em>authenticator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal can be emitted when a <em>proxy</em> that requires authentication is used. The <em>authenticator</em> object can then be filled in with the required details to allow authentication and continue the connection.</p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>QAuthenticator, QNetworkProxy </dd></dl>

</div>
</div>
<a id="a3755970eca2be3d792ceb9c8e560ae32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3755970eca2be3d792ceb9c8e560ae32">&#9670;&nbsp;</a></span>readBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qint64 QWebSocket::readBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size in bytes of the readbuffer that is used by the socket. </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00760">760</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a17d4ab6c6fe8017626fb079cee6518a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d4ab6c6fe8017626fb079cee6518a6">&#9670;&nbsp;</a></span>readChannelFinished</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::readChannelFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#ae1c9af16e7f53666ccd423864b8e2c35" title="Gracefully closes the socket with the given closeCode and reason. ">close()</a> </dd></dl>

</div>
</div>
<a id="a17b0d131ad2e4a0140f5faf23d30335c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b0d131ad2e4a0140f5faf23d30335c">&#9670;&nbsp;</a></span>request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QNetworkRequest QWebSocket::request </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the request that was or will be used to open this socket. </p>
<dl class="section since"><dt>Since</dt><dd>5.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00619">619</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="af21dbd52b116cc5dae811548000001ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21dbd52b116cc5dae811548000001ee">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Continues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is <a class="el" href="class_q_web_socket.html#ae0d3eebd5b595e4e869d2ad6cef45ed7">sslErrors()</a>. Calling this method if the socket is not paused results in undefined behavior.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#a15778b8a5f6ffb83c61b5e9b1701eb28">pauseMode()</a>, <a class="el" href="class_q_web_socket.html#a7d6650c827cace4ccb27988894872bcc">setPauseMode()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00774">774</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="aa56992d89ffba061ec6dc7c3e4a010f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56992d89ffba061ec6dc7c3e4a010f6">&#9670;&nbsp;</a></span>sendBinaryMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qint64 QWebSocket::sendBinaryMessage </td>
          <td>(</td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the given <em>data</em> over the socket as a binary message and returns the number of bytes actually sent. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#aa3bdc1e29c50c1e0d88c0977eb298a17" title="Sends the given message over the socket as a text message and returns the number of bytes actually se...">sendTextMessage()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00446">446</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="aa3bdc1e29c50c1e0d88c0977eb298a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bdc1e29c50c1e0d88c0977eb298a17">&#9670;&nbsp;</a></span>sendTextMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qint64 QWebSocket::sendTextMessage </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the given <em>message</em> over the socket as a text message and returns the number of bytes actually sent. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#aa56992d89ffba061ec6dc7c3e4a010f6" title="Sends the given data over the socket as a binary message and returns the number of bytes actually sen...">sendBinaryMessage()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00434">434</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a3f0e24c3101e75a42264aa527936573e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0e24c3101e75a42264aa527936573e">&#9670;&nbsp;</a></span>setMaskGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::setMaskGenerator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_q_mask_generator.html">QMaskGenerator</a> *&#160;</td>
          <td class="paramname"><em>maskGenerator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the generator to use for creating masks to <em>maskGenerator</em>. The default <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> generator can be reset by supplying a <em>Q_NULLPTR</em>. The mask generator can be changed at any time, even while the connection is open. </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00742">742</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a7d6650c827cace4ccb27988894872bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6650c827cace4ccb27988894872bcc">&#9670;&nbsp;</a></span>setPauseMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::setPauseMode </td>
          <td>(</td>
          <td class="paramtype">QAbstractSocket::PauseModes&#160;</td>
          <td class="paramname"><em>pauseMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_controls.html" title="Entity Controls combined all control widgets for change parameters on main window app...">Controls</a> whether to pause upon receiving a notification. The <em>pauseMode</em> parameter specifies the conditions in which the socket should be paused.</p>
<p>The only notification currently supported is <a class="el" href="class_q_web_socket.html#ae0d3eebd5b595e4e869d2ad6cef45ed7">sslErrors()</a>. If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling <a class="el" href="class_q_web_socket.html#af21dbd52b116cc5dae811548000001ee">resume()</a>. By default, this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#a15778b8a5f6ffb83c61b5e9b1701eb28">pauseMode()</a>, <a class="el" href="class_q_web_socket.html#af21dbd52b116cc5dae811548000001ee">resume()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00792">792</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="ab567ac6d43bb2f0526a1a5d0e2872034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab567ac6d43bb2f0526a1a5d0e2872034">&#9670;&nbsp;</a></span>setProxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::setProxy </td>
          <td>(</td>
          <td class="paramtype">const QNetworkProxy &amp;&#160;</td>
          <td class="paramname"><em>networkProxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the proxy to <em>networkProxy</em> </p>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00730">730</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="adc6582dd40792bb2c8309a4890236510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6582dd40792bb2c8309a4890236510">&#9670;&nbsp;</a></span>setReadBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::setReadBufferSize </td>
          <td>(</td>
          <td class="paramtype">qint64&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the size of <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a>'s internal read buffer to be <em>size</em> bytes.</p>
<p>If the buffer size is limited to a certain size, <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default. This option is useful if you only read the data at certain points in time (for example, in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#a3755970eca2be3d792ceb9c8e560ae32">readBufferSize()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00811">811</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a2b47402d89258caa95e46452b698cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b47402d89258caa95e46452b698cc3a">&#9670;&nbsp;</a></span>setSslConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::setSslConfiguration </td>
          <td>(</td>
          <td class="paramtype">const QSslConfiguration &amp;&#160;</td>
          <td class="paramname"><em>sslConfiguration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the socket's SSL configuration to be the contents of <em>sslConfiguration</em>.</p>
<p>This function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in <em>sslConfiguration</em>. It is not possible to set the SSL-state related fields. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#a002b89e651c50e9b73ec23d07f4f7eba">sslConfiguration()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00566">566</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="a002b89e651c50e9b73ec23d07f4f7eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002b89e651c50e9b73ec23d07f4f7eba">&#9670;&nbsp;</a></span>sslConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSslConfiguration QWebSocket::sslConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate. The SSL configuration also contains fields that can change with time without notice.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#a2b47402d89258caa95e46452b698cc3a">setSslConfiguration()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qwebsocket_8cpp_source.html#l00580">580</a> of file <a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a>.</p>

</div>
</div>
<a id="ae0d3eebd5b595e4e869d2ad6cef45ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d3eebd5b595e4e869d2ad6cef45ed7">&#9670;&nbsp;</a></span>sslErrors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::sslErrors </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; QSslError &gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted. If you want to continue connecting despite the errors that have occurred, you must call <a class="el" href="class_q_web_socket.html#aed580d710b6613a6218a78f4c07fb856">QWebSocket::ignoreSslErrors()</a> from inside a slot connected to this signal. If you need to access the error list at a later point, you can call <a class="el" href="class_q_web_socket.html#ae0d3eebd5b595e4e869d2ad6cef45ed7">sslErrors()</a> (without arguments).</p>
<p><em>errors</em> contains one or more errors that prevent <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a> from verifying the identity of the peer.</p>
<dl class="section note"><dt>Note</dt><dd>You cannot use Qt::QueuedConnection when connecting to this signal, or calling <a class="el" href="class_q_web_socket.html#aed580d710b6613a6218a78f4c07fb856">QWebSocket::ignoreSslErrors()</a> will have no effect. </dd></dl>

</div>
</div>
<a id="aba46b4ae0292aee9632297a56122902a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba46b4ae0292aee9632297a56122902a">&#9670;&nbsp;</a></span>stateChanged</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::stateChanged </td>
          <td>(</td>
          <td class="paramtype">QAbstractSocket::SocketState&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever <a class="el" href="class_q_web_socket.html" title="Implements a TCP socket that talks the WebSocket protocol. ">QWebSocket</a>'s state changes. The <em>state</em> parameter is the new state.</p>
<dl class="section note"><dt>Note</dt><dd>QAbstractSocket::ConnectedState is emitted after the handshake with the server has succeeded.</dd></dl>
<p>QAbstractSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and qRegisterMetaType().</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#abf40a05dfbb85a86355c73f7c2f2c492" title="Returns the current state of the socket. ">state()</a> </dd></dl>

</div>
</div>
<a id="af0feabc8f7979f054b15d903a54882a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0feabc8f7979f054b15d903a54882a6">&#9670;&nbsp;</a></span>textFrameReceived</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::textFrameReceived </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLastFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever a text frame is received. The <em>frame</em> contains the data and <em>isLastFrame</em> indicates whether this is the last frame of the complete message.</p>
<p>This signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#a43bf9793d8edec549ea45d503e9be366">binaryFrameReceived()</a> </dd></dl>

</div>
</div>
<a id="ad0f93d1bf2b5e973dbc3acc4378505e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f93d1bf2b5e973dbc3acc4378505e4">&#9670;&nbsp;</a></span>textMessageReceived</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QWebSocket::textMessageReceived </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This signal is emitted whenever a text message is received. The <em>message</em> contains the received text.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_q_web_socket.html#aaefdf77b949880d571e64a30b01f75e7">binaryMessageReceived()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>prerequisites/QtWebApp/QtWebApp/qtwebsockets/src/websockets/<a class="el" href="qwebsocket_8h_source.html">qwebsocket.h</a></li>
<li>prerequisites/QtWebApp/QtWebApp/qtwebsockets/src/websockets/<a class="el" href="qwebsocket_8cpp_source.html">qwebsocket.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
