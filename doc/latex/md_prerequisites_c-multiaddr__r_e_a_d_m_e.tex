multiaddr for I\+P\+FS in C.

\subsubsection*{Multiaddr provides easy networking protocols nesting, easy encapsulation of extra protocols, easy tunneling, etc.}

\section*{Usage\+:}

\paragraph*{All you need to include is \mbox{\hyperlink{multiaddr_8h_source}{multiaddr.\+h}}}

\subsection*{Maddr struct\+:}


\begin{DoxyItemize}
\item char $\ast$ string; // String that contains addresses such as /ip4/192.168.\+1.\+1/
\item uint8\+\_\+t $\ast$ bytes; // uint8\+\_\+t $\ast$ that contains the enecoded address
\item size\+\_\+t bsize; //size\+\_\+t that contains the real bytes size (Use it whenever using the bytes so you don\textquotesingle{}t input trash!)
\end{DoxyItemize}

\subsection*{New Multi Address From String(multiaddress\+\_\+new\+\_\+from\+\_\+string)}

struct Multi\+Address$\ast$ a = multiaddress\+\_\+new\+\_\+from\+\_\+string(\char`\"{}/ip4/127.\+0.\+0.\+1/tcp/8080/\char`\"{}); \subsection*{Obtaining the byte buffer(.bytes, .bsize\mbox{[}0\mbox{]})\+:}

printf(\char`\"{}\+T\+E\+S\+T B\+Y\+T\+E\+S\+: \%s\textbackslash{}n\char`\"{},Var\+\_\+\+To\+\_\+\+Hex(a-\/$>$bsize, a-\/$>$bytes)); Var\+\_\+\+To\+\_\+\+Hex = Byte Buffer to Hex String Hex\+\_\+\+To\+\_\+\+Var = Hex String to Byte Buffer \subsection*{Encapsulation \& Decapsulation(m\+\_\+encapsulate, m\+\_\+decapsulate)}

\paragraph*{Remember, Decapsulation happens from right to left, never in reverse, if you have /ip4/udp/ipfs/ if you decapsulate \char`\"{}udp\char`\"{} you will also take out ipfs!}


\begin{DoxyItemize}
\item Now the string is\+: /ip4/192.168.\+1.\+1/
\item multiaddress\+\_\+encapsulate(a,\char`\"{}/udp/3333/\char`\"{}); //\+Adds udp/3333/
\item Now the string is\+: /ip4/192.168.\+1.\+1/udp/3333/
\item multiaddress\+\_\+decapsulate(a,\char`\"{}udp\char`\"{}); //\+Removes udp protocol and its address
\item Now the string is\+: /ip4/192.168.\+1.\+1/
\item multiaddress\+\_\+encapsulate(a,\char`\"{}/tcp/8080\char`\"{});
\item Now the string is\+: /ip4/192.168.\+1.\+1/tcp/8080/
\end{DoxyItemize}

\section*{Constructing a multiaddress from bytes\+:}


\begin{DoxyItemize}
\item struct Multi\+Address$\ast$ beta;
\item beta = multiaddress\+\_\+new\+\_\+from\+\_\+bytes(a-\/$>$bytes,a-\/$>$bsize); //\+This will already construct back to the string too!
\item printf(\char`\"{}\+B S\+T\+R\+I\+N\+G\+: \%s\textbackslash{}n\char`\"{},beta-\/$>$string); //\+So after encapsulation and decapsulation atm this string would
\item contain\+: /ip4/192.168.\+1.\+1/tcp/8080/ 
\end{DoxyItemize}