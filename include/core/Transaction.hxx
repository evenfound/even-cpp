/**
 * @file    Transaction.hxx
 * @author  E. Pozdnyakov
 *
 * @date    Created on October 31, 2018, 06:48 PM
 */

#pragma once

#include "Hash.hxx"
#include "Config.hxx"

#include <QString>
#include <QStringList>
#include <QDateTime>

namespace even {

/** @brief Transaction structure in bytes member size. All: 1248 bytes
 *  32      - hash
 *  1024    - signatureMessageFragment
 *  32      - address
 *  24      - tag
 *  4       - value
 *  4       - timestamp
 *  4       - currentIndex
 *  4       - lastIndex
 *  32      - messageHash
 *  32      - trunkHash
 *  32      - branchHash
 *  24      - nonce
 */

/** @brief Entitity of storage handler */
class Transaction : public Config {
    public:
        Transaction();
        virtual ~Transaction();

        /** @brief Check transaction file name and internal hash value */
        bool checkHash_wFileName(QString fileName_);

        /** @brief Load transaction and and read data */
        bool ipfsLoad(QString fileName_);

        /** @brief Flush transaction to ipfs shared */
        bool ipfsFlush(QString filePath_);

        /** @brief Add address to transaction */
        void addAddress(QString address_);

        /** @brief Set value to transaction */
        inline void setValue(int value_) { _value = value_; }

        /** @brief Got a some error strings if pressent its */
        inline const QStringList errors() const { return _errors; }

        /** @brief Return values in json array packed by path_ set */
        bool serialize(QString path_, QJsonObject& other_) override;

    private:
        /** @brief Pack data to binary body for flush */
        void _packBody();

        /** @brief Unpack QByteArray value */
        void _unpackHash(QDataStream &stream_, Hash &value_);

        /** @brief Unpack QString value */
        void _unpackString(QDataStream &stream_, QString &value_, uint size_);

        /** @brief Unpack UInt value */
        void _unpackUInt(QDataStream &stream_, uint &value_);

        /** @brief Unpack Int value */
        void _unpackInt(QDataStream &stream_, int &value_);

        /** @brief Unpack data from binary body from read */
        void _unpackBody();

        /** @brief  String unique hash of this transaction  */
        Hash _hash;

        /** @brief String signature message fragment. In case there
         *  is a spent input, the signature of the private key is stored
         * here. If no signature is required, it is empty (all 9's) and
         * can be used for storing the message value when making a transfer.
         * More to that later.
         */

        QString _signatureMessageFragment;
        /** @brief String address. In case this is an *output*, then
         * this is the address of the recipient. In case it is an *input*,
         * then it is the address of the input which is used to send the
         * tokens from (i.e. address generated from the private key)
         */
        Hash _address;

        /** @brief The transaction object field is used to search transaction
         * for srecific tag value
         */
        QString _tag;

        /** @brief Int value transferred in this transaction */
        int _value = 0.0;

        /** @brief Int timestamp of the transaction. It is important
         * to know that timestamps are not enforced.*/
        uint _timestamp = 1010;

        /** @brief Int the index of this transaction in the message. */
        int _currentIndex = -1;

        /** @brief Int the total number of transactions in this message */
        int _lastIndex = -1;

        /** @brief String message hash, which is used for grouping
         * transactions of the message together. With the message hash you
         * can identify transactions which were in the same message.
         */
        Hash _messageHash;

        /** @brief String hash of the first transaction that
         * was approved with this transaction
         */
        Hash _trunkHash;

        /** @brief String hash of the second transaction that was
         * approved with this transaction
         */
        Hash _branchHash;

        /** @brief String hash. The nonce is required for the transaction
         *  to be accepted by the network. It is generated by doing Proof
         * of Work (either in IRI via the attachToTangle API call, or with
         * one of the libraries such as ccurl).
         */
        QString _nonce = "BOFFIN-TEST";

        /** @brief Indicates that transaction pending or accepted */
        bool _persistence;

        /** @brief Body of transacton - size no more 2.5Kb */
        QByteArray _body;

        /** @brief Error list filled in load or other process */
        QStringList _errors;

};

};

